[{"body":"以下の手順で Leafony Basic Kit 開発環境の設定を行いましょう。\nArduino IDEのインストール Leafonyに書き込むプログラムは、Arduino IDEを使って開発します。\nArduino ホームページから「SOFTWARE」→「DOWNLOADS」をクリックし、Arduino IDE インストーラをダウンロードしましょう。\nWindowsの場合は下記の手順でダウンロードできます。\n ボード設定 Arduino IDEでLeafonyの開発を行うために、下記の手順でIDEの設定を行いましょう。\n  Arduino IDEを起動\n  「ツール」→「ボード」から、Arduino Pro or Pro Miniを選択、「プロセッサ」で**ATmega328P(3.3V,8MHz)**を選択\n  「ツール」→「シリアルポート」から、Leafonyが接続されているシリアルポートを選択  Leafonyにプログラムを書き込む Leafonyを組み立ててLEDを点滅させてみましょう。\n Basic Kitを組み立てる  Arduino IDEで「ファイル」→「スケッチ例」→「01.Basics」→「Blink」をクリックし、サンプルコードを開く 「マイコンボードに書き込む」ボタンを押す  AP01A AVR MCUに搭載されたLEDが点滅していることが確認できれば完了です。\nライブラリのインストール Basic Kitに含まれているリーフを使用するには、一部追加のライブラリをインストールする必要があります。\n下記の説明を参考に、予めライブラリをインストールしておきましょう。\n\r\rリーフ名\r必要なライブラリ名\r説明\r\r\rBLE\rTBGLib\rBluetoothライブラリ\r\r\r4-Sensors\rAdafruit_Sensor.h\rユニファイドセンサドライバ\r\r\rHTS221.h\r温湿度センサライブラリ\r\r\rClosedCube_OPT3001.h\r照度センサライブラリ\r\r\rAdafruit_LSI3DH.h\r加速度センサライブラリ\r\r\rLCD\rST7032.h\rLCDライブラリ\r\r\rAVR MCU\rMsTimer2.h\rタイマ割り込みライブラリ\r\r\rRTC\u0026MicroSD\rRTClib.h\rRTCライブラリ\r\r\rArduinoのライブラリは、通常以下の2カ所に保存されています。\n C:\\Program Files (x86)\\Arduino\\libraries C:\\Users\\ユーザ名\\Documents\\Arduino\\libraries  Arduino IDE をインストールした時、1）にライブラリが保存される。（Arduino IDE Standard Libraries） また、GitHubなどからダウンロードしたライブラリ（ZIPファイル）は、「スケッチ」→「ライブラリをインクルード」→「.ZIP形式のライブラリをインストール」を選択することで、 2)に保存される。\n1. Githubからライブラリをダウンロード\n「Clone or download」→「Download ZIP」をクリックする。\n2. ライブラリのインクルード\nArduinoを立ち上げ、スケッチ→ライブラリをインクルード→ZIP形式のライブラリうをインストールの順に選択して保存する。\nトラブルシューティング  USBシリアル変換ボードのデバイスドライバが見つからない場合  USBシリアル変換ドライバーをインストールすることで、AVR MCUへの書き込みが可能。Aruduino UNOと異なるため、要注意。 FTDI VCP Driverサイトからsetup executableをクリックしてインストールファイルをダウンロードし実行する。\n","excerpt":"以下の手順で Leafony Basic Kit 開発環境の設定を行いましょう。\nArduino IDEのインストール Leafonyに書き込むプログラムは、Arduino IDEを使って開発します。 …","ref":"/docs/environment/basic/","title":"Basic Kit"},{"body":"\r Basic Kit A1.0は、スマートフォンやパソコンに、Bluetoothを使って温度、湿度、照度、傾きセンサの値を送信し、簡単に表示できます。 スマートフォンやパソコンにセンサの値を表示させるには、ソフトウェア（Web Bluetooth）が必要です。 Web Bluetooth は、Android、Mac、WindowsのGoogle Chrome に対応しており、OSによって対応バージョンが異なります。詳細は、Implementation Statusを参照願います。 iPhoneの場合は、アプリ（有償）をダウンロードすれば、使えます。まずは、iPhoneの例の動画をご覧ください。  Android/Mac OS/Windowsの場合  Android 6.0 Marshmallow 以降、OS X Yosemite 以降、Windows 10 version 1703以降 でなければ、動作しません。端末のバージョンを確認してください。 Google Chromeウェブブラウザを立ち上げます。MacやWindowsの端末で、Chromeが無い場合は、インストールしてください。 Windowsの場合、Chromeのアドレスバーにchrome://flags/#enable-experimental-web-platform-features を入力し、enterを押し、Experimental Web Platform featuresでEnableを選択します。Android、Macの端末の場合は不要です。 次に、下記のリンクにアクセスするとアプリが立ち上がります。 https://trillion-node.org/wp/wp-content/SW/sensor-trillion-app/index.html Basic Kitの電池リーフに付属のコイン電池を入れて、電池リーフのスイッチをオンにします。 「Connect」 ボタンを押して「Leaf_A_xxxxx..」を選択後、「ペア設定」ボタンを押します。画面にセンサの値が表示されます。  iPhone/iPadの場合  App StoreからWebBLE (有償)をダウンロードします。 WebBLEを立ち上げ、一番上にあるアドレスバーに以下のURLを貼り付けてください。 https://trillion-node.org/wp/wp-content/SW/sensor-trillion-app/index.html WebBLEの「Connect」 ボタンを押して「Leaf_A_xxxxx..」を選択後、「Done」ボタンを押します。画面にセンサの値が表示されます。 画面上に「Download CSV 」のボタンはありますが、iPhoneでは使用できません。  重要：クイックスタートのプログラム等を詳しく知りたい方へは、Web Bluetoothを使ってセンサの値を表示　を参照してください。\n","excerpt":"Basic Kit A1.0は、スマートフォンやパソコンに、Bluetoothを使って温度、湿度、照度、傾きセンサの値を送信し、簡単に表示できます。 スマートフォンやパソコンにセンサの値を表示させるに …","ref":"/docs/getting-started/basic/","title":"Basic Kit A1.0"},{"body":"Leafony bus の仕様 Leafony busは、複数のリーフが電気信号および電源接続を行う共通経路部。リーフの相互接続を可能にするために、Leafony busは、リーフの20mm x 5.5mm領域の電気的及び、物理的な仕様が定められています。\nピンアウト コネクタ形状  基板の厚さは、t=0.8。パッド部分は、金めっき。レイアウト図のデータは（dxf、、KiCad、EAGLE)は、AX02A 29pin を参照願います。  コネクタの取り付け・取り外し リーフ基板にコネクタを取り付ける、または、外す場合は下図のように行ってください。\n 取り付け   取り外し  コネクタの試験結果 AX61Aコネクタ仕様書を参考\n接続不良時の対処 Connectorや基板の接点に汚れが付着すると、接続不良が生じることがあります。その場合、無水エタノールを含ませた紙製ウエスで払拭してください。それでも改善しない場合は、Connectorを交換してください。\nライセンス  Leafony busのアートワークの著作者は、Leafony Systems 社です。ライセンスは、 表示 4.0 国際(CC BY 4.0) で、提供されています。なお、著作権表示や無保証を参照する表示は、ありません。Leafony bus以外は、Leafony Systems社は、著作権を主張することはありません。 Leafony busのアートワークをコピーして、使用する場合は、「この製品の一部は、Leafony SystemsによるLeafony busのアートワークを利用しています。」と表示をお願いします。  ","excerpt":"Leafony bus の仕様 Leafony busは、複数のリーフが電気信号および電源接続を行う共通経路部。リーフの相互接続を可能にするために、Leafony busは、リーフの20mm x …","ref":"/docs/leaf/leafonybus/","title":"Leafony bus"},{"body":"概要 AVR MCUリーフに搭載されたLEDを1秒ごとに点灯、消灯を繰り返します。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP01A AVR MCU 1   AZ01A USB 1   AV01A CR2032 1   AZ62A コネクタカバー 1    CR2032 コイン電池 1    M2ネジ 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//=====================================================================\r// Blink\r//\r// (c) 2020 Trillion-Node Study Group\r// Released under the MIT license\r// https://opensource.org/licenses/MIT\r//\r// Rev.00 2020/05/05 First release\r//=====================================================================\r\rvoid setup() {\r// LEDピンを出力ピンに設定\r pinMode(LED_BUILTIN, OUTPUT);\r}\rvoid loop() {\rdigitalWrite(LED_BUILTIN, HIGH); // LEDを点灯\r delay(1000); // 1秒待つ\r digitalWrite(LED_BUILTIN, LOW); // LEDを消灯\r delay(1000); // 1秒待つ\r}\r","excerpt":"概要 AVR MCUリーフに搭載されたLEDを1秒ごとに点灯、消灯を繰り返します。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP01A AVR …","ref":"/docs/examples/blink/","title":"LED点滅"},{"body":"Leafontとは トリリオンノード・エンジンには以下のような特徴があり、製品名はLeafony（リーフォニー）です。LeafonyはIoT/CPSシステムやアプリ、サービスの研究開発効率を断然アップさせます。ビデオも同時にご覧ください。\n  超小型で組立簡単: 1円玉大の電子基板モジュール（リーフ）ですが、新規研究開発されたコネクタによって、組立はブロック玩具のように簡単。\n  超低消費電力: 低消費電力性に優れています。すべてのリーフにはスタンバイモードやソフトウェアで制御できる電源スイッチ装備されていて、コイン電池でも動作します。\n  オープンソース・ハード／ソフト: 商用でも無償でフリーに使える仕様・回路図・パターン図などのハードウェア情報が公開されています。ソフトウェアもすでに数万本あるフリーのArduinoソフトウェアが使えます。その他のソフトウェアでも使えます。\n  リーフの製作が簡単: リーフを作るときには、特殊な技術やコネクタは不要。Leafonyコネクタを後で手で付けられるなど、あなた自身の独自リーフも短工期で簡単に作れ、研究開発効率が断然アップします。\n  \r詳細はこちらの資料をご覧ください。\n利用シーン  企業  IoTのProof of Concept (PoC) R\u0026amp;D、実証実験、社会課題を解く IoTシステム試作サービス レファレンスモデルの作製 自社部品／技術の販売ツール 技術の再利用や伝承   個人  新しいアプリ サービスの探査 手軽なガジェット創り   教育・大学  IoT教育 研究／実験 研究成果をデモし実用化加速    はじめてみよう さっそくLeafonyを使ってみましょう。\n クイックスタート 開発環境設定 サンプルデザイン  ","excerpt":"Leafontとは トリリオンノード・エンジンには以下のような特徴があり、製品名はLeafony（リーフォニー）です。LeafonyはIoT/CPSシステムやアプリ、サービスの研究開発効率を断然アップ …","ref":"/docs/overview/","title":"はじめに"},{"body":"Arduino IDEのインストール Arduino ホームページから「SOFTWARE」→「DOWNLOADS」をクリックし、Arduino IDE インストーラをダウンロードする。下記赤枠はWindowsの例。\n寄付しない場合はJUST DOWNLOADをクリックする。\nボード設定 ESP32 MCUをArduino IDEで使用するには、Arduino core for the ESP32 のインストールが必要です。\n Arduino IDEのファイル→環境設定を開き、”追加のボードマネージャのURL:”に、下記URLを入力してください。 https://dl.espressif.com/dl/package_esp32_index.json  ツール→ボード→ボードマネージャを選択し、”全て”の右側に”esp32″と入力し、esp32 by Espressifl Systemsが表示されるので”インストール”のボタンを押します。  ツール→ボード→ESP32 Dev Moduleを選択すれば、ESP32 MCUが使えるようになります。  サンプルデザインで動作確認  「ファイル」→「スケッチ例」→「01.Basics」→「Blink」 「マイコンボードに書き込む」ボタンを押す  ライブラリのインストール Arduinoのライブラリは、通常以下の2カ所に保存されている。 1）C:\\Program Files (x86)\\Arduino\\libraries 2）C:\\Users\\ユーザ名\\Documents\\Arduino\\libraries\nArduino IDE をインストールした時、1）にライブラリが保存される。（Arduino IDE Standard Libraries） また、GitHubなどからダウンロードしたライブラリ（ZIPファイル）は、「スケッチ」→「ライブラリをインクルード」→「.ZIP形式のライブラリをインストール」を選択することで、 2)に保存される。\n1. Githubからライブラリをダウンロード\n「Clone or download」→「Download ZIP」をクリックする。\n2. ライブラリのインクルード\nArduinoを立ち上げ、スケッチ→ライブラリをインクルード→ZIP形式のライブラリうをインストールの順に選択して保存する。\n","excerpt":"Arduino IDEのインストール Arduino ホームページから「SOFTWARE」→「DOWNLOADS」をクリックし、Arduino IDE インストーラをダウンロードする。下記赤枠 …","ref":"/docs/environment/esp32/","title":"ESP32 Wi-Fi Kit"},{"body":"","excerpt":"","ref":"/docs/getting-started/esp32/","title":"ESP32 Wi-Fi Kit A1.0"},{"body":"Leafonyが届いたらさっそく使ってみましょう！ キットには電源を入れればすぐ使えるアプリがインストールされています。\nこちらのページを参考にIoTの世界を体験してみましょう。\n Basic Kit ESP32 Wi-Fi Kit  ","excerpt":"Leafonyが届いたらさっそく使ってみましょう！ キットには電源を入れればすぐ使えるアプリがインストールされています。\nこちらのページを参考にIoTの世界を体験してみましょう。\n Basic Kit …","ref":"/docs/getting-started/","title":"クイックスタート"},{"body":"Leafony（リーフォニー）または、Leafony platform（リーフォニー・プラットフォーム） 超小型、電池で動く、組み立て簡単なオープンイノベーション・プラットフォームです。特に、新しいITサービスやガジェット、マシンあるいはIoTのエッジノードなどを生み出すための試みが簡単になるエレクトロニクスおよびソフトウェアのプラットフォームとなっています。このようなプラットフォーム構築を目指して、トリリオンノード・エンジン・プロジェクト１）がその研究開発を進めています。このプロジェクトで研究開発が終了し、仕様などが確定したものをLeafonyと呼びます。LeafonyはLeafとSymphonyの造語ですが、個と全体の調和を目指した造語です。Symphonyでは、さまざまな楽器の出す音色が調和して素晴らしい楽曲を奏でるようにLeafが集まって素晴らしい価値を創造して欲しいという願いが込められています。「Leafony」は登録商標です。\nLeafonyは、現在Arduino Pro or Pro Mini (3.3V/8MHz) のソフトウェア環境で動作するようになっていますが、プロセッサリーフを変更することにより、どのようなプロセッサ環境／ソフトウェア環境でも使用できるようになっています。新規開発ソフトウェアは、MITライセンスで公開していますので、商用でも自由に無償で使用できます。\nトリリオンノード・エンジンプロジェクトでは、今後、Leafonyがより強力なプロセッサ環境にも対応できるように、また将来、AIなどの開発プラットフォームとしても使えることを目指して、引き続き各種の拡張を研究開発しています。\nLeaf（リーフ） Leafonyの基礎となる2cm角程度の電子基板／電子モジュールのことです。小さくて緑色なのでリーフ（木の葉）と呼んでいます。\nLeafony block（リーフォニー・ブロック）作成中 複数のリーフを組合わせて出来上がった電子機器のことです。Leafony blockは、単体で使用する場合や、機器の中に組み込まれる場合があります。\nLeafony bus（リーフォニー・バス） 複数のリーフ間を相互に接続する共通経路部をLeafonyバスと呼びます。電気信号および電源接続を行うための電気的および物理的な仕様が定義されています。典型的にはリーフの20mm x 5.5mmの領域となります。Leafonyバス準拠のリーフは他のリーフと交信可能になりますが、Leafonyプラットフォームと完全に問題なく繋がるかはソフトウェアなどにもよるため、Leafonyバス準拠というのはあくまでも物理レベルに近いところで接続可能といっているに過ぎません。\nLeafonyバスのアートワークには著作権があり、CC-BYライセンスで公開していますので、商用でもLeafony準拠と明記すれば自由に無償で使用できます。従って、自由に独自のリーフを開発や販売ができます。ただし、Leafonyは登録商標ですので、独自に作ったリーフそのものにはLeafonyとは表示しないでください。Leafonyと表示のあるリーフは製品品質が確かめられていることがわかり、混乱を避けられます。\nLEAFONY SYSTEMS Co.,Ltd.（リーフォニー・システムズ 株式会社） トリリオンノード・エンジン・プロジェクトが研究開発したLeafonyを製造、販売する唯一の会社です。LeafにLeafonyを表示しているのはLEAFONY SYSTEMS社のLeafだけです。Leafonyと表示されたLeafは、相互接続などがトリリオンノード・エンジン・プロジェクトによって確認されています。\nLeafonyバス準拠のリーフ、他の企業や個人などから多数販売されますし、そのような活動を推奨していますが、リーフ自体にLeafonyの表示はされません。\nトリリオンノード研究会 IoT/CPS２）など将来非常に多くのITノードが社会で使われるようになると言われています。そのような未来を議論し情報を共有するための研究会です。具体的に考えるベースとして、Leafonyを使っており、IoT/CPSの発展のため、Leafonyの普及に力を入れています。また、ニーズとシーズを持った関連企業をつなぐ場も提供しています。\n １）トリリオンノード・エンジン・プロジェクトは、国立研究開発法人新エネルギー・産業技術総合開発機構（ＮＥＤＯ）の委託・助成事業による研究開発プロジェクトです。\n２）IoTはInternet of Things、CPSはCyber-Physical Systemsの略です。特に、CPSはネットにつながらずとも、リアルな物理的空間とデジタル空間をつなぐような システムです。\n","excerpt":"Leafony（リーフォニー）または、Leafony platform（リーフォニー・プラットフォーム） 超小型、電池で動く、組み立て簡単なオープンイノベーション・プラットフォームです。特に、新し …","ref":"/docs/overview/terms/","title":"用語の説明"},{"body":"これからLeafonyを使った開発を行うために、PCの環境を整えましょう。\n必要なツールやライブラリのインストール方法、Leafonyの組み立て方などはここから学べます。\n Basic Kit ESP32 Wi-Fi Kit  ","excerpt":"これからLeafonyを使った開発を行うために、PCの環境を整えましょう。\n必要なツールやライブラリのインストール方法、Leafonyの組み立て方などはここから学べます。\n Basic Kit …","ref":"/docs/environment/","title":"開発環境設定"},{"body":"Leafonyの基板設計にはCADテンプレートを用いると便利です。 各CADごとの利用方法は下記をご覧ください。\nKiCad https://github.com/Leafony/cad-template\n","excerpt":"Leafonyの基板設計にはCADテンプレートを用いると便利です。 各CADごとの利用方法は下記をご覧ください。\nKiCad …","ref":"/docs/leaf/pcb_template/","title":"基板設計テンプレート"},{"body":"  \n特徴 温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\n性能    項目 内容　     温湿度センサ    温度計測範囲 -40～120℃   Temperature accuracy ±0.5°C (15 to +40°C)   Relative humidity range 0 to 100%   Humidity accuracy 3.5% rH (20 to +80% rH)   Interfaces I2C       照度センサ    Measurement range 0.01 lux to 83 k lux   IR Rejects \u0026gt; 99% (typ)   Interfaces I2C       加速度センサ    Measurement range ±2g/±4g/±8g/±16g (selectable)   Function 6D/4D orientation detection   Freefall detection    Motion detection    Interfaces I2C    ブロック図 \nピン配置 サンプルプロジェクト  LED点滅  ライブラリ(関数の概要は、仕様書に記載）  ユニファイドセンサドライバ include file: Adafruit_Sensor.h 温湿度センサデータ取得 include file: HTS221.h 照度センサデータ取得 include file: ClosedCube_OPT3001.h 加速度センサデータ取得 include file : Adafruit_LIS3DH.h※ ※：このまま使用すると書き込みエラーになります。こちらを参照して編集してください。  温度（または、湿度）の補正の仕方 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。詳しくは、こちら。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"特徴 温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\n性能    項目 内容　     温湿度センサ    温度計測範囲 -40～120℃ …","ref":"/docs/leaf/io/ai01a/","title":"AI01A 4-Sensors"},{"body":"  \n特徴 ATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。 USB接続する場合はUSB を接続、ICSPを使用する場合はShield を接続します。 Arduino IDE使用時は、ボードをArduino Pro or Pro　Mini、プロセッサをATmega328P(3.3V,8MHz)選択。\n性能    項目 内容     MCU ATmega328P   動作電圧 3.3V   動作電圧範囲 1.5-5V   Digital I/O 14   Analog input 6   Flash Memory 32 KB   SRAM 2KB   EEPROM 1KB   動作周波数 8MHz    ブロック図 \nピン配置 \nサンプルプロジェクト  LED点滅  ライブラリ ・関数の概要は、仕様書に記載\n・タイマ割込み include file: MsTimer2.h\n以下は、Standard Libraries。IDEをインストールすると、C:\\Program Files (x86)\\Arduino\\libraries に保存されています。\n・ソフトウェアシリアル通信　include file: SoftwareSerial.h\n・I2C通信 include file: Wire.h\n・ウォッチドッグタイマ include file: avr/wdt.h\n・スリープモード include file: avr/sleep.h\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) ブートローダ  ","excerpt":"特徴 ATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。 USB接続する場 …","ref":"/docs/leaf/processor/ap01a/","title":"AP01A AVR MCU"},{"body":"  \n特徴 EASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。MCUリーフとはUARTで接続されます。\n性能    項目 内容     SoC MKL16Z128 (ARM Cortex-M0+)   RF transceiver SX1276 (SEMTECH)   Frequency range 920.6～928.0MHz   伝送速度 146bps～22kbps   RX sensitivity -118～-142dBm   TX power 13dBm（20mW)以下   RF certification TELEC   通信距離目安(ワイヤーアンテナ) 見通し 5km   Flash 128KB   RAM 32KB   Interfaces UART    ブロック図 \nピン配置 サンプルプロジェクト  LED点滅  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"特徴 EASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。MCUリーフとはUARTで接続されます。\n性能    項目 内容     SoC MKL16Z128 (ARM …","ref":"/docs/leaf/communication/ac03a/","title":"AC03A LoRa Easy"},{"body":"  \n特徴 圧電スピーカと人感センサを搭載したリーフです。圧電スピーカはPWM、人感センサはI2CでMCUリーフと接続されます。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で接近を検知することが出来、接近検知時に割り込み信号を出力することが可能です。\n性能    項目 内容     圧電スピーカ    dimensions 12 x 12 x 3mm   rated frequency 4kHz(typ)   sound pressure level 81dB(min) at 10 cm, 5 Vp-p, 4,000 Hz square wave   Current consumption 5mA(max) at 5 Vp-p, 4,000 Hz square wave       人感センサ    Sensor Quantum-type IR Sensor   Integrated digital filters Cut-off Frequency 0.9Hz,0.445Hz *Only with 10Hz of Data Output Rate(ODR)   Interfaces I2C    ブロック図 ピン配置 サンプルプロジェクト  LED点滅  ドキュメント  仕様書 回路図 SP\u0026amp;PIR 回路図 PIR 部品配置図 レイアウト図 SP＆PIR (Zuken) レイアウト図 PIR (Zuken) レイアウト図 SP＆PIR (dxf) レイアウト図 PIR (dxf)  ","excerpt":"特徴 圧電スピーカと人感センサを搭載したリーフです。圧電スピーカはPWM、人感センサはI2CでMCUリーフと接続されます。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で接近を検知すること …","ref":"/docs/leaf/io/ai02a/","title":"AI02A SP\u0026PIR"},{"body":"各種Leafを使ったサンプルアプリケーションを紹介します。\n実際に動かして使い方を学んでいきましょう。\nBasic Kit Basic Kitで遊べるサンプル\n LED点滅 バッテリ電圧読み取り 温湿度センサ読み取り 照度センサ読み取り 加速度センサ読み取り Web Bluetoothを使ったIoTアプリ入門 Google sheetsを使ったIoTサービス入門  Extension Kit Basic KitとExtension Kitと組み合わせて遊べるサンプル\n スピーカ 人感センサ サウンドレベルメータ LCD ディスプレイ リアルタイムクロック MicroSDカード  ESP32 Wi-Fi ESP32 Wi-Fi Kitで遊べるサンプル\n Wi-Fi タッチセンサ  Grove Extention KitのGroveリーフとGroveモジュールで遊べるサンプル\n 超音波センサで距離測定 カメラの撮影  サンプルコードGithubリポジトリ その他様々なサンプルコードが公開されています。\n GitHub - Leafony/Sample-Sketches  ","excerpt":"各種Leafを使ったサンプルアプリケーションを紹介します。\n実際に動かして使い方を学んでいきましょう。\nBasic Kit Basic Kitで遊べるサンプル\n LED点滅 バッテリ電圧読み取り 温湿 …","ref":"/docs/examples/","title":"サンプルデザイン"},{"body":"概要 CR2032コイン電池リーフに搭載されたADコンバータを使って電池の電圧を読み取りましょう。 このサンプルはAV03A AA BATリーフや、AV04A 2V～4.5Vリーフなどの電池リーフでも動作します。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP01A AVR MCU 1   AZ01A USB 1   AV01A CR2032 1   AZ62A コネクタカバー 1    CR2032 コイン電池 1    M2ネジ 2    リーフの組み立て ソースコード Arduino IDEで下記のプログラムを書きましょう。\n//=====================================================================\r// Battery Voltage\r//\r// (c) 2020 Trillion-Node Study Group\r// Released under the MIT license\r// https://opensource.org/licenses/MIT\r//\r// Rev.00 2020/05/05 First release\r//=====================================================================\r\r#include \u0026lt;Wire.h\u0026gt;\r\rconst int BATT_ADC_ADDR = 0x50\rvoid setup() {\r// initialize serial communication at 9600 second per second:\r Serial.begin(9600);\r// initialize I2C communication at 100kHz:\r Wire.begin();\rdelay(10);\r}\rvoid loop(){\r// read ADC registers:\r Wire.beginTransmission(BATT_ADC_ADDR);\rWire.write(0x00);\rWire.endTransmission(false);\rWire.requestFrom(BATT_ADC_ADDR,2);\ruint8_t adcVal1 = Wire.read();\ruint8_t adcVal2 = Wire.read();\r// when ADC is not connected, read values are 0xFF:\r if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) {\radcVal1 = adcVal2 = 0;\r}\r// voltage mV = adcVal * Vref(3.3V) / resolution(8bit) * Vdiv(2)\r double tempMillivolt = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256;\rfloat dataBatt = (float)(tempMillivolt / 1000);\rSerial.println(\u0026#34;Batt[V] = \u0026#34; + String(dataBatt));\rdelay(1000);\r}\r動作 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsすると、電池の電圧が表示されます。\n","excerpt":"概要 CR2032コイン電池リーフに搭載されたADコンバータを使って電池の電圧を読み取りましょう。 このサンプルはAV03A AA BATリーフや、AV04A 2V～4.5Vリーフなどの電池リーフでも …","ref":"/docs/examples/read_battery/","title":"バッテリ残量"},{"body":"プロセッサ \rAVR MCU\rAP01A\rATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。 USB接続する場合はUSB を接続、ICSPを使用する場合はShield を接続します。 Arduino IDE使用時は、ボードをArduino Pro or Pro　Mini、プロセッサをATmega328P(3.3V,8MHz)選択。\nBasic Kit\r\r\rESP32 MCU\rAP02A\rEspressif SystemsのXtensa Dual-Core 32-bit LX6 マイクロプロセッサ、技的認証済みWi-FiとBLEを内蔵したESP32-WROOM-32を搭載した32bit MCUリーフである。 無線の認証は、 FCC、CE-RED、IC、TELEC、KCC、SRRC、NCCを取得（Espressif Systems Data Sheet V2.9）。USB電源を供給して、VBUS(5V)電源として使用可能。\nESP32 Wi-Fi Kit\r \r","excerpt":"プロセッサ \rAVR MCU\rAP01A\rATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタ …","ref":"/docs/leaf/processor/","title":"プロセッサリーフ"},{"body":"  \n特徴 Espressif SystemsのXtensa Dual-Core 32-bit LX6 マイクロプロセッサ、技的認証済みWi-FiとBLEを内蔵したESP32-WROOM-32を搭載した32bit MCUリーフである。無線の認証は、 FCC、CE-RED、IC、TELEC、KCC、SRRC、NCCを取得（Espressif Systems Data Sheet V2.9）。 USB電源を供給して、VBUS(5V)電源として使用可能。\n性能    項目 内容     SoC ESP32-D0WDQ6 (CPU:Xtensa LX6)   動作電圧 3.3V   動作電圧範囲 2.2-3.6V   Digital I/O 14   Analog input 6   TouchSensor I/F 6   Flash Memory 4 MB   SRAM 520 KB   動作周波数 80M-240MHz   Wi-Fi protocols IEEE 802.11b/g/n   Bluetooth protocols Bluetooth v4.2 BR/EDR and BLE specification   RF certification FCC/CE-RED/IC/TELEC/KCC/SRRC/NCC    ブロック図 \nピン配置 \nサンプルプロジェクト  Wi-Fi を使ってタッチセンサの値を表示 ※リンク先 要変更  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ソフトウェア仕様 ","excerpt":"特徴 Espressif SystemsのXtensa Dual-Core 32-bit LX6 マイクロプロセッサ、技的認証済みWi-FiとBLEを内蔵したESP32-WROOM-32を搭載し …","ref":"/docs/leaf/processor/ap02a/","title":"AP02A ESP32 MCU"},{"body":"  \n特徴 Silicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証は、CE、FCC、ISED Canada、TELEC、KC South-Korea、NCC Taiwanを取得（SLICON LABS Module Data Sheet　Revision 1.2)。\n性能    項目　 内容     SoC EFR32BG1 (ARM Cortex-M4)   Bluetooth version 4.2   Frequency range 2400M ~ 2483.5MHz   Internetsecurity　 General Purpose CRC    Random Number Generator    Hardware Cryptographic Acceleration for AES 128/256,SHA-1, SHA-2 (SHA-224 and SHA-256) and ECC   RX sensitivity -90 dBm @ 1 Mbit/s GFSK   TX power +8dBm以下   RF certification CE, full FCC, ISED Canada, Japan and South-Korea   Flash 256KB   RAM 32KB   Interfaces UART    ブロック図 \nピン配置 \nサンプルプロジェクト  Web Bluetooth を使ってセンサの値を表示 ※リンク先要変更  ライブラリ ・関数の概要は、仕様書に記載\n・BLE制御　include file: TBGLib\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"特徴 Silicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証は、CE、FCC、ISED …","ref":"/docs/leaf/communication/ac02a/","title":"AC02A BLE Sugar"},{"body":"Leafony規格・開発データ \rLeafony bus\r\rLeafonyで使用される基板間インターフェイスです。\n\r\r\r基板設計テンプレート\r\rPCB CAD向けテンプレートファイル\n\r \rプロセッサ \rAVR MCU\rAP01A\rATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。 USB接続する場合はUSB を接続、ICSPを使用する場合はShield を接続します。 Arduino IDE使用時は、ボードをArduino Pro or Pro　Mini、プロセッサをATmega328P(3.3V,8MHz)選択。\nBasic Kit\r\r\rESP32 MCU\rAP02A\rEspressif SystemsのXtensa Dual-Core 32-bit LX6 マイクロプロセッサ、技的認証済みWi-FiとBLEを内蔵したESP32-WROOM-32を搭載した32bit MCUリーフである。 無線の認証は、 FCC、CE-RED、IC、TELEC、KCC、SRRC、NCCを取得（Espressif Systems Data Sheet V2.9）。USB電源を供給して、VBUS(5V)電源として使用可能。\n\r \r通信 \rBLE Sugar\rAC02A\rSilicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証は、CE、FCC、ISED Canada、TELEC、KC South-Korea、NCC Taiwanを取得（SLICON LABS Module Data Sheet　Revision 1.2)。\nBasic Kit\r\r\rLoRa Easy\rAC03A\rEASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。MCUリーフとはUARTで接続されます。\n\r \rIO \r4-Sensors\rAI01A\r温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\nBasic Kit\r\r\rSP\u0026amp;PIR\rAI02A\r圧電スピーカと人感センサを搭載したリーフです。圧電スピーカはPWM、人感センサはI2CでMCUリーフと接続されます。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で接近を検知することが出来、接近検知時に割り込み信号を出力することが可能です。\nExtension Kit\r \rMIC\u0026amp;VR\u0026amp;LED\rAI03A\rMEMSマイク、ボリューム、LEDを搭載したリーフです。MEMSマイクとボリュームはアナログ入力ピン、LEDはデジタル出力ピンでMCUリーフと接続されます。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\nExtension Kit\r \rLCD\rAI04A\rキャラクタLCDユニットとスイッチ2個を搭載したリーフです。LCDユニットはI2CでMCUリーフと接続される。スイッチはMCUのデジタル入力ピンとI2C ExpanderのP1ピンに接続されています。 低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\nExtension Kit\r \r電源 \rCR2032\rAV01A\rCR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\nBasic Kit\r\r\rCR2450\rAV02A\rCR2450コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n\r \rAA BAT\rAV03A\r単3電池ホルダを実装し、1.5Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\nExtension Kit\r \r2V～4.5V\rAV04A\rSHコネクタを実装し、2～4.5Vの電池電圧を昇降圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。 SHコネクタに接続可能な電池は乾電池2～3本またはLi-Po、Li-ION電池を想定しています。\nExtension Kit\r \r拡張 \rShield\rAX01A\rArduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。(Connectorは1つのみ）\nExtension Kit\r\r\r29pin\rAX02A\rリーフI/Fの29ピン全てをスルーホールに接続したリーフです。\nBasic Kit\r \rLeaf x2\rAX03A\r全てのリーフI/F端子を接続したリーフを横に接続するためのリーフです。\nExtension Kit\r \rSpacer\rAX04A\r全てのリーフI/F端子を接続した高さが2mm以上ある部品を使用しているリーフの上に別のリーフを接続するためのリーフです。\nExtension Kit\r \rI Meas.\rAX05A\r3.3VおよびVBUSの消費電流を測定することが出来るリーフです。 電流測定リーフでは3.3VとVBUSは表面と裏面のパッドが電気的に切り離されているので、下記の各々スルーホールに電流計を接続することで、電池リーフから遠い部分にある単体リーフあるいは複数リーフ群の全電源電流を測定できます。下の例では、センサリーフとBLEリーフが電流測定リーフを介して、電池リーフの遠い側に配置されているので、両リーフの合計電流が測定できます。\nExtension Kit\r \rGrove\u0026amp;5V\rAX06A\rSeeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。Grove対応ピンの仕様は以下の通り。 低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\nExtension Kit\r \rBack to back\rAX07A\r全てのリーフI/F端子を接続したリーフを反転させて接続するためのリーフです。\nESP32 Wi-Fi Kit\r \r29pin header\rAX08A\rリーフI/Fの29ピン全てをピンヘッダに接続したリーフです。\nESP32 Wi-Fi Kit\r \rその他 \rUSB\rAZ01A\rAVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\nBasic Kit\r\r\rRTC\u0026amp;microSD\rAZ02A\rNXPのReal-Time Clock PCF8523TKおよびMicro SDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。micro SDカードはSPIでアクセスします。\nESP32 Wi-Fi Kit\r \rConnector\rAZ61A\rLeafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\n\r \rConnector Cover\rAZ62A\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \rNut Plate\rAZ63A\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意\n\r \rUppercase\rAZ64A\rケース（上）\nBasic Kit\r \rLowercase\rAZ65A\rケース（下）\nBasic Kit\r ","excerpt":"Leafony規格・開発データ \rLeafony bus\r\rLeafonyで使用される基板間インターフェイスです。\n\r\r\r基板設計テンプレート\r\rPCB CAD向けテンプレートファイル\n\r \rプロセッ …","ref":"/docs/leaf/","title":"リーフ技術資料"},{"body":"概要 4-Sensorsリーフに搭載された温湿度センサ、の値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI01A 4-Sensors 1   AP01A AVR MCU 1   AZ01A USB 1   AV01A CR2032 1   AZ62A コネクタカバー 1    CR2032 コイン電池 1    M2ネジ 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//=====================================================================\r// Thermo-hygrometer\r//\r// (c) 2020 Trillion-Node Study Group\r// Released under the MIT license\r// https://opensource.org/licenses/MIT\r//\r// Rev.00 2020/05/05 First release\r//=====================================================================\r#include \u0026lt;Wire.h\u0026gt;\r#include \u0026lt;HTS221.h\u0026gt;\r\r//---------------------------\r// 2点補正用データ\r//---------------------------\r// 温度補正用データ0\rfloat TL0 = 25.0; // 4-Sensors温度測定値\rfloat TM0 = 25.0; // 温度計等測定値\r// 温度補正用データ1\rfloat TL1 = 40.0; // 4-Sensors温度測定値\rfloat TM1 = 40.0; // 温度計等測定値\r\r// 湿度補正用データ0\rfloat HL0 = 60.0; // 4-Sensors湿度測定値\rfloat HM0 = 60.0; // 湿度計等測定値\r// 湿度補正用データ1\rfloat HL1 = 80.0; // 4-Sensors湿度測定値\rfloat HM1 = 80.0; // 湿度計等測定値\r\rvoid setup() {\r// initialize serial communication at 9600 second per second:\r Serial.begin(9600);\r// initialize i2c communication with HTS221:\r smeHumidity.begin();\rdelay(10);\r}\rvoid loop() {\r// read temperature and humidity:\r float dataTemp = (float)smeHumidity.readTemperature();\rfloat dataHumid = (float)smeHumidity.readHumidity();\r// calibration:\r dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // 温度補正\r dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // 湿度補正\r\rSerial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;);\rdelay(1000);\r}\rソースコードのビルド 4-Sensors リーフを使うためにはライブラリのインストールが必要です。 まだインストールしていない場合はこちらのページを参考にライブラリをインストールしてください。\n","excerpt":"概要 4-Sensorsリーフに搭載された温湿度センサ、の値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name …","ref":"/docs/examples/temp_humid_sensors/","title":"温湿度センサ読み取り"},{"body":"通信 \rBLE Sugar\rAC02A\rSilicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証は、CE、FCC、ISED Canada、TELEC、KC South-Korea、NCC Taiwanを取得（SLICON LABS Module Data Sheet　Revision 1.2)。\nBasic Kit\r\r\rLoRa Easy\rAC03A\rEASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。MCUリーフとはUARTで接続されます。\n\r \r","excerpt":"通信 \rBLE Sugar\rAC02A\rSilicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証 …","ref":"/docs/leaf/communication/","title":"通信"},{"body":"特徴 ファイル  仕様書 回路図 レイアウト図  ピン配置 サンプルプロジェクト ソフトウェア仕様 ","excerpt":"特徴 ファイル  仕様書 回路図 レイアウト図  ピン配置 サンプルプロジェクト ソフトウェア仕様 ","ref":"/docs/leaf/communication/ac03a/_index-2/","title":"AC03A LoRa Easy"},{"body":"概要 4-Sensorsリーフに搭載された照度センサ、の値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI01A 4-Sensors 1   AP01A AVR MCU 1   AZ01A USB 1   AV01A CR2032 1   AZ62A コネクタカバー 1    CR2032 コイン電池 1    M2ネジ 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//=====================================================================\r// Illuminance meter\r//\r// (c) 2020 Trillion-Node Study Group\r// Released under the MIT license\r// https://opensource.org/licenses/MIT\r//\r// Rev.00 2020/05/05 First release\r//=====================================================================\r#include \u0026lt;Wire.h\u0026gt;\r#include \u0026lt;ClosedCube_OPT3001.h\u0026gt;\r\r#define OPT3001_ADDRESS 0x45 // ADDR pin = VCC\r\rClosedCube_OPT3001 illum;\rfloat dataIllum;\rvoid setup() {\rSerial.begin(115200); // UART 115200bps\r Wire.begin(); // I2C 100KHz\r\rdelay(10);\rOPT3001_Config illumConfig;\rOPT3001_ErrorCode illumErrorConfig;\rillum.begin(OPT3001_ADDRESS);\rillumConfig.RangeNumber = B1100; // automatic full scale\r illumConfig.ConvertionTime = B1; // convertion time = 800ms\r illumConfig.ModeOfConversionOperation = B11; // continous conversion\r illumConfig.Latch = B0; // hysteresis-style\r\rillumErrorConfig = illum.writeConfig(illumConfig);\rif(illumErrorConfig != NO_ERROR){\rillumErrorConfig = illum.writeConfig(illumConfig); //retry\r }\r}\rvoid loop() {\rOPT3001 result = illum.readResult();\rif(result.error == NO_ERROR){\rdataIllum = result.lux;\r}\rSerial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum));\rdelay(1000);\r}\rソースコードのビルド 4-Sensors リーフを使うためにはライブラリのインストールが必要です。 まだインストールしていない場合はこちらのページを参考にライブラリをインストールしてください。\n","excerpt":"概要 4-Sensorsリーフに搭載された照度センサ、の値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/illum_sensor/","title":"照度センサ読み取り"},{"body":"概要 4-Sensorsリーフに搭載された加速度センサ、の値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI01A 4-Sensors 1   AP01A AVR MCU 1   AZ01A USB 1   AV01A CR2032 1   AZ62A コネクタカバー 1    CR2032 コイン電池 1    M2ネジ 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//=====================================================================\r// Accelerometer\r//\r// (c) 2020 Trillion-Node Study Group\r// Released under the MIT license\r// https://opensource.org/licenses/MIT\r//\r// Rev.00 2020/05/05 First release\r//=====================================================================\r#include \u0026lt;Wire.h\u0026gt;\r#include \u0026lt;Adafruit_LIS3DH.h\u0026gt;\r\r#define LIS2DH_ADDRESS 0x19 // SD0/SA0 pin = VCC\r\r#define DIVIDER_2G 16383 // full scale 2G (=0xFFFF/4)\r#define DIVIDER_4G 8191 // full scale 4G (=0xFFFF/4/2)\r#define DIVIDER_8G 4096 // full scale 8G (=0xFFFF/4/4)\r#define DIVIDER_16G 1365 // full scale 16G (=0xFFFF/4/12)\r\rAdafruit_LIS3DH accel = Adafruit_LIS3DH();\rfloat dataX_g, dataY_g, dataZ_g;\rfloat dataTilt;\rvoid setup() {\rSerial.begin(115200); // UART 115200bps\r Wire.begin(); // I2C 100KHz\r\rdelay(10);\raccel.begin(LIS2DH_ADDRESS);\r// register\r accel.writeRegister8(LIS3DH_REG_CTRL1, 0x07); // X,Y,Z axis = enable\r accel.setDataRate(LIS3DH_DATARATE_1_HZ); // Data rate = 1Hz\r\raccel.writeRegister8(LIS3DH_REG_CTRL2, 0x00);\raccel.writeRegister8(LIS3DH_REG_CTRL3, 0x00); // INT Disable\r accel.writeRegister8(LIS3DH_REG_CTRL4, 0x80); // BUD = enable, Scale = +/-2g\r}\rvoid loop() {\raccel.read();\rdataX_g = accel.x_g; //X軸\r dataY_g = accel.y_g; //Y軸\r dataZ_g = accel.z_g; //Z軸\r\rif(dataZ_g \u0026gt;= 1.0){\rdataZ_g = 1.00;\r} else if (dataZ_g \u0026lt;= -1.0){\rdataZ_g = -1.00;\r}\rdataTilt = acos(dataZ_g)/PI*180; // 傾き\r\rSerial.println(\u0026#34; X [g] = \u0026#34; + String(dataX_g));\rSerial.println(\u0026#34; Y [g] = \u0026#34; + String(dataY_g));\rSerial.println(\u0026#34; Z [g] = \u0026#34; + String(dataZ_g));\rSerial.println(\u0026#34; Ang[arc deg] = \u0026#34; + String(dataTilt));\rdelay(100);\r}\rソースコードのビルド 4-Sensors リーフを使うためにはライブラリのインストールが必要です。 まだインストールしていない場合はこちらのページを参考にライブラリをインストールしてください。\n","excerpt":"概要 4-Sensorsリーフに搭載された加速度センサ、の値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name …","ref":"/docs/examples/accelerometer/","title":"加速度センサ読み取り"},{"body":"IO \r4-Sensors\rAI01A\r温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\nBasic Kit\r\r\rSP\u0026amp;PIR\rAI02A\r圧電スピーカと人感センサを搭載したリーフです。圧電スピーカはPWM、人感センサはI2CでMCUリーフと接続されます。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で接近を検知することが出来、接近検知時に割り込み信号を出力することが可能です。\nExtension Kit\r \rMIC\u0026amp;VR\u0026amp;LED\rAI03A\rMEMSマイク、ボリューム、LEDを搭載したリーフです。MEMSマイクとボリュームはアナログ入力ピン、LEDはデジタル出力ピンでMCUリーフと接続されます。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\nExtension Kit\r \rLCD\rAI04A\rキャラクタLCDユニットとスイッチ2個を搭載したリーフです。LCDユニットはI2CでMCUリーフと接続される。スイッチはMCUのデジタル入力ピンとI2C ExpanderのP1ピンに接続されています。 低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\nExtension Kit\r \r","excerpt":"IO \r4-Sensors\rAI01A\r温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\nBasic Kit\r\r\rSP\u0026amp;PIR\rAI02A\r圧 …","ref":"/docs/leaf/io/","title":"IO"},{"body":"AVR MCUリーフに搭載されたLEDを1秒ごとに点灯、消灯を繰り返します。\nここに動作のイメージ図を載せる\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP01A AVR MCU 1   AZ01A USB 1   AV01A CR2032 1   AZ62A コネクタカバー 1    CR2032 コイン電池 1    M2ネジ 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nvoid setup() {\r// LEDピンを出力ピンに設定\r pinMode(LED_BUILTIN, OUTPUT);\r}\rvoid loop() {\rdigitalWrite(LED_BUILTIN, HIGH); // LEDを点灯\r delay(1000); // 1秒待つ\r digitalWrite(LED_BUILTIN, LOW); // LEDを消灯\r delay(1000); // 1秒待つ\r}\r","excerpt":"AVR MCUリーフに搭載されたLEDを1秒ごとに点灯、消灯を繰り返します。\nここに動作のイメージ図を載せる\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/webbluetooth_iot/","title":"Web BluetoothをつかったIoTアプリ入門"},{"body":"   \u0026lt;\n特徴 MEMSマイク、ボリューム、LEDを搭載したリーフです。MEMSマイクとボリュームはアナログ入力ピン、LEDはデジタル出力ピンでMCUリーフと接続されます。低消費電力を実現するのためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n性能    項目 内容     マイク    Type MEMS   Direction Omnidirectional   Frequency range 100Hz ～ 10kHz   Gain 0dB   Interfaces Interfaces       ボリューム    Nominal resistance 10kΩ   Resistance law Linear law (B)   Effective electrical angle 210° (1 turn)       LED    Package type Side-view   Emitting color Yellow    ブロック図 \nピン配置 サンプルプロジェクト  LED点滅  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"\u0026lt;\n特徴 MEMSマイク、ボリューム、LEDを搭載したリーフです。MEMSマイクとボリュームはアナログ入力ピン、LEDはデジタル出力ピンでMCUリーフと接続されます。低消費電力を実現するのた …","ref":"/docs/leaf/io/ai03a/","title":"AI03A MIC\u0026VR\u0026LED"},{"body":"  \n特徴 キャラクタLCDユニットとスイッチ2個を搭載したリーフです。LCDユニットはI2CでMCUリーフと接続されます。スイッチはMCUのデジタル入力ピンとI2C ExpanderのP1ピンに接続されています。 低消費電力化を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n性能    項目 内容     Display format 8x2 Character   Viewing area (WxH) 27x10.5mm   Dot size (WxH) 0.45x0.5mm   Dot pitch (WxH) 0.5x0.55mm   Character size (WxH) 2.45x4.35mm   Character pitch (WxH) 2.95x4.9mm   Viewing direction 6:00 O\u0026rsquo;Clock   Driving method 1/16Duty,1/5Bias   Controller IC ST7032I-0D(Sitronix) or compatible   Display mode STN (Gray)/Positive/Reflective   Interfaces I2C    ブロック図 \nピン配置 サンプルプロジェクト  LED点滅  ライブラリ(関数の概要は、仕様書に記載）  LCDの制御 include file: ST7032.h  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"特徴 キャラクタLCDユニットとスイッチ2個を搭載したリーフです。LCDユニットはI2CでMCUリーフと接続されます。スイッチはMCUのデジタル入力ピンとI2C ExpanderのP1ピンに接続されて …","ref":"/docs/leaf/io/ai04a/","title":"AI04A LCD"},{"body":"  \n特徴 CR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能    項目 内容     電池電圧 0.7～3.8V   出力電圧 3.3V±2%   制御方式 PWM/PFM 自動切替制御   最大出力電流 300mA @3.3V to 5V   Protection circuit 過電流制限/サーマルシャットダウン   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C    ブロック図 \nピン配置 \nサンプルプロジェクト  電池の電圧をパソコンに表示 ※リンク先要変更  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 CR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。ま …","ref":"/docs/leaf/power/av01a/","title":"AV01A CR2032"},{"body":"AVR MCUリーフに搭載されたLEDを1秒ごとに点灯、消灯を繰り返します。\nここに動作のイメージ図を載せる\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP01A AVR MCU 1   AZ01A USB 1   AV01A CR2032 1   AZ62A コネクタカバー 1    CR2032 コイン電池 1    M2ネジ 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nvoid setup() {\r// LEDピンを出力ピンに設定\r pinMode(LED_BUILTIN, OUTPUT);\r}\rvoid loop() {\rdigitalWrite(LED_BUILTIN, HIGH); // LEDを点灯\r delay(1000); // 1秒待つ\r digitalWrite(LED_BUILTIN, LOW); // LEDを消灯\r delay(1000); // 1秒待つ\r}\r","excerpt":"AVR MCUリーフに搭載されたLEDを1秒ごとに点灯、消灯を繰り返します。\nここに動作のイメージ図を載せる\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/google_sheets_iot/","title":"Google SheetsをつかったIoTサービス入門"},{"body":"Leafony bus のライセンスについて  Leafony busのアートワークの著作者は、Leafony Systems 社です。ライセンスは、 表示 4.0 国際(CC BY 4.0) で、提供されています。なお、著作権表示や無保証を参照する表示は、ありません。Leafony bus以外は、Leafony Systems社は、著作権を主張することはありません。 Leafony busのアートワークをコピーして、使用する場合は、「この製品の一部は、Leafony SystemsによるLeafony busのアートワークを利用しています。」と表示をお願いします。  Leafony bus 準拠のオリジナルリーフを制作する場合 Leafony は、Leafony Systems社の商標です。 オリジナルのリーフを作成する場合は、他のリーフとの互換性を確保するため、Leafony busの電気的・物理的仕様に合致させてください。合致させたものは、「Leafony bus 準拠」と表示して頂いても結構です。勿論、商業的にも自由に無償で使えますが、商品名称に、Leafony の名前を付けることは、Leafony Systems社の製品ラインナップと混同してしまうので、控えて下さい。\n","excerpt":"Leafony bus のライセンスについて  Leafony busのアートワークの著作者は、Leafony Systems 社です。ライセンスは、 表示 4.0 国際(CC BY 4.0) で、提 …","ref":"/docs/license/","title":"ライセンス・規約"},{"body":"電源 \rCR2032\rAV01A\rCR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\nBasic Kit\r\r\rCR2450\rAV02A\rCR2450コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n\r \rAA BAT\rAV03A\r単3電池ホルダを実装し、1.5Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\nExtension Kit\r \r2V～4.5V\rAV04A\rSHコネクタを実装し、2～4.5Vの電池電圧を昇降圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。 SHコネクタに接続可能な電池は乾電池2～3本またはLi-Po、Li-ION電池を想定しています。\nExtension Kit\r \r","excerpt":"電源 \rCR2032\rAV01A\rCR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッ …","ref":"/docs/leaf/power/","title":"電源リーフ"},{"body":"  \n特徴 CR2450コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能　    項目 内容     電池電圧 0.7～3.8V   出力電圧 3.3V±2%   制御方式 PWM/PFM 自動切替制御   最大出力電流 300mA @3.3V to 5V   Protection circuit 過電流制限/サーマルシャットダウン   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C    ブロック図 \nピン配置 \nサンプルプロジェクト  電池の電圧をパソコンに表示 ※リンク先要変更  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 CR2450コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。ま …","ref":"/docs/leaf/power/av02a/","title":"AV02A CR2450"},{"body":"  \n特徴 単3電池ホルダを実装し、1.5Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能    項目 内容     電池電圧 0.7～3.8V   出力電圧 3.3V±2%   制御方式 PWM/PFM 自動切替制御   最大出力電流 300mA @3.3V to 5V   Protection circuit 過電流制限/サーマルシャットダウン   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C    ブロック図 \nピン配置 \nサンプルプロジェクト  電池の電圧をパソコンに表示 ※リンク先要変更  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 単3電池ホルダを実装し、1.5Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電 …","ref":"/docs/leaf/power/av03a/","title":"AV03A AA BAT"},{"body":"  \n特徴 SHコネクタを実装し、2～4.5Vの電池電圧を昇降圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニターするためのADコンバータを実装しています。 SHコネクタに接続可能な電池は乾電池2～3本またはLi-Po、Li-ION電池を想定しています。\n性能　    項目 内容     電池電圧 1.8～5.5V   出力電圧 3.3V±2%   制御方式 PWM/PFM 自動切替制御   最大出力電流 300mA (降圧時)   Protection circuit 過電流制限/サーマルシャットダウン   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C    ブロック図 \nピン配置 \nサンプルプロジェクト  電池の電圧をパソコンに表示 ※リンク先要変更  ドキュメント  仕様書 回路図 部品配置図(表面) 部品配置図(裏面) レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 SHコネクタを実装し、2～4.5Vの電池電圧を昇降圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電 …","ref":"/docs/leaf/power/av04a/","title":"AV04A 2V～4.5V"},{"body":"  \n特徴 Arduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\nブロック図 \nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 Arduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\nブロック図 \nドキュメント  仕様書 回路図 部品配置図 レイアウト …","ref":"/docs/leaf/extension/ax01a/","title":"AX01A Shield"},{"body":"拡張 \rShield\rAX01A\rArduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。(Connectorは1つのみ）\nExtension Kit\r\r\r29pin\rAX02A\rリーフI/Fの29ピン全てをスルーホールに接続したリーフです。\nBasic Kit\r \rLeaf x2\rAX03A\r全てのリーフI/F端子を接続したリーフを横に接続するためのリーフです。\nExtension Kit\r \rSpacer\rAX04A\r全てのリーフI/F端子を接続した高さが2mm以上ある部品を使用しているリーフの上に別のリーフを接続するためのリーフです。\nExtension Kit\r \rI Meas.\rAX05A\r3.3VおよびVBUSの消費電流を測定することが出来るリーフです。 電流測定リーフでは3.3VとVBUSは表面と裏面のパッドが電気的に切り離されているので、下記の各々スルーホールに電流計を接続することで、電池リーフから遠い部分にある単体リーフあるいは複数リーフ群の全電源電流を測定できます。下の例では、センサリーフとBLEリーフが電流測定リーフを介して、電池リーフの遠い側に配置されているので、両リーフの合計電流が測定できます。\nExtension Kit\r \rGrove\u0026amp;5V\rAX06A\rSeeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。Grove対応ピンの仕様は以下の通り。 低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\nExtension Kit\r \rBack to back\rAX07A\r全てのリーフI/F端子を接続したリーフを反転させて接続するためのリーフです。\nESP32 Wi-Fi Kit\r \r29pin header\rAX08A\rリーフI/Fの29ピン全てをピンヘッダに接続したリーフです。\nESP32 Wi-Fi Kit\r \r","excerpt":"拡張 \rShield\rAX01A\rArduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。(Connectorは1つのみ） …","ref":"/docs/leaf/extension/","title":"拡張リーフ"},{"body":"  \n特徴 リーフI/Fの29ピン全てをスルーホールに接続したリーフです。\nKiCadとEAGLEのデータ 個人の方が、多く利用しているKiCadとEAGLEのデータをご用意しました。Zuken のCADデータを変換して作成したので、変換ミスの可能性をぬぐいきれません。各自で、寸法等十分確認の上、ご使用ください。\n レイアウト図(KiCad) レイアウト図(EAGLE)  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 リーフI/Fの29ピン全てをスルーホールに接続したリーフです。\nKiCadとEAGLEのデータ 個人の方が、多く利用しているKiCadとEAGLEのデータをご用意しました。Zuken  …","ref":"/docs/leaf/extension/ax02a/","title":"AX02A 29 pin"},{"body":"概要 圧電スピーカを使って、メロディーを鳴らします。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI02A SP\u0026amp;PIR 1   AP01A AVR MCU 1   AV01A CR2032 1   AZ01A USB 1   AZ62A Connector Cover 1    CR2032 コイン電池 1    M2ネジ 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nプログラムの実行  以下を同じフォルダに保存してください。\n[toneMelody.ino]\n[pitches.h]  ソースコード Arduino IDEで下記のプログラムを書きましょう。\n/*\rMelody\rPlays a melody\rcircuit:\r- 8 ohm speaker on digital pin 8\rcreated 21 Jan 2010\rmodified 30 Aug 2011\rby Tom Igoe\rThis example code is in the public domain.\rhttp://www.arduino.cc/en/Tutorial/Tone\r*/\r#include \u0026#34;pitches.h\u0026#34;\r\r// notes in the melody:\rint melody[] = {\rNOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4\r};\r// note durations: 4 = quarter note, 8 = eighth note, etc.:\rint noteDurations[] = {\r4, 8, 8, 4, 4, 4, 4, 4\r};\rvoid setup() {\r// iterate over the notes of the melody:\r for (int thisNote = 0; thisNote \u0026lt; 8; thisNote++) {\r// to calculate the note duration, take one second divided by the note type.\r //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.\r int noteDuration = 1000 / noteDurations[thisNote];\rtone(8, melody[thisNote], noteDuration);\r// to distinguish the notes, set a minimum time between them.\r // the note\u0026#39;s duration + 30% seems to work well:\r int pauseBetweenNotes = noteDuration * 1.30;\rdelay(pauseBetweenNotes);\r// stop the tone playing:\r noTone(8);\r}\r}\rvoid loop() {\r// no need to repeat the melody.\r}\r","excerpt":"概要 圧電スピーカを使って、メロディーを鳴らします。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI02A SP\u0026amp;PIR 1 …","ref":"/docs/examples/speaker/","title":"スピーカ"},{"body":"  \n特徴 全てのリーフI/F端子を接続したリーフを横に接続するためのリーフです\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 全てのリーフI/F端子を接続したリーフを横に接続するためのリーフです\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","ref":"/docs/leaf/extension/ax03a/","title":"AX03A Leaf x2"},{"body":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI03A MIC\u0026amp;VR\u0026amp;LED 1   AP01A AVR MCU 1   AV01A CR2032 1   AZ01A USB 1   AZ62A Connector Cover 1    CR2032 コイン電池 1    M2ネジ 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nプログラムの実行  書き込みには、AVR MCUライブラリ（タイマ割り込み）が必要です。\n予め、ライブラリをインクルードしておいて下さい。\n詳しくは、こちら。  ソースコード Arduino IDEで下記のプログラムを書きましょう。\n//=====================================================================\r// Leafony Platform sample sketch\r// Platform : MIC\u0026amp;VR\u0026amp;LED\r// Processor : ATmega328P (3.3V /8MHz)\r// Application : LED MIC demo\r//\r// Leaf configuration\r// (1) AI03 MIC\u0026amp;VR\u0026amp;LED\r// (2) AP01 AVR MCU\r// (3) AZ01 USB\r//\r//\t(c) 2019 Trillion-Node Study Group\r//\tReleased under the MIT license\r//\thttps://opensource.org/licenses/MIT\r//\r// Rev.00 2019/08/01 First release\r//=====================================================================\r// LED4-6:VRのレベル表示\r// LED1-3:MICの音圧レベル表示\r//=====================================================================\r//use libraries\r//\r//=====================================================================\r\r//=====================================================================\r// difinition\r//=====================================================================\r#include \u0026lt;MsTimer2.h\u0026gt;\r#include \u0026lt;avr/wdt.h\u0026gt;\r#include \u0026lt;avr/sleep.h\u0026gt;\r#include \u0026lt;avr/power.h\u0026gt;\r\r#include \u0026lt;Wire.h\u0026gt;\r\r//=====================================================================\r// IOピンの名前定義\r// 接続するリーフに合わせて定義する\r//=====================================================================\r// --------------------------------------------\r// PD port\r// digital 0: PD0 = PCRX (HW UART)\r// digital 1: PD1 = PCTX (HW UART)\r// digital 2: PD2 = PIR INT0\r// digital 3: PD3 = MIC\u0026amp;VR\u0026amp;LED Leaf LED1\r// digital 4: PD4 = MIC\u0026amp;VR\u0026amp;LED Leaf LED2\r// digital 5: PD5 = MIC\u0026amp;VR\u0026amp;LED Leaf LED3 SP\r// digital 6: PD6 = MIC\u0026amp;VR\u0026amp;LED Leaf LED4\r// digital 7: PD7 = MIC\u0026amp;VR\u0026amp;LED Leaf LED5\r// --------------------------------------------\r#define PCTX 0\r#define PCRX 1\r#define INT0 2\r#define INT1 3\r#define D4 4 #define SP 5\r#define LED1 6\r#define LED2 7\r\r// --------------------------------------------\r// PB port\r// digital 8: PB0 = MIC\u0026amp;VR\u0026amp;LED Leaf LED6\r// digital 9: PB1 = D9 /* not use */\r// digital 10:PB2 = SS#\r// digital 11:PB3 = MOSI\r// digital 12:PB4 = MISO\r// digital 13:PB5 = SCK (LED)\r// PB6 = XTAL1\r// PB7 = XTAL2\r//---------------------------------------------\r#define LED3 8\r#define LED4 9\r#define LED5 10\r#define LED6 11\r#define MISO 12\r#define AVR_LED 13\r\r// --------------------------------------------\r// PC port\r// digital 14/ Analog0: PC0 = D14\r// digital 15/ Analog1: PC1 = D15\r// digital 16/ Analog2: PC2 = MIC\r// digital 17/ Analog3: PC3 = VR\r// digital 18/ SDA : PC4 = SDA (I2C)\r// digital 19/ SCL : PC5 = SCL (I2C)\r// RESET : PC6 = RESET#\r//-----------------------------------------------\r#define D14 14\r#define D15 15\r#define MIC 16\r#define VR 17\r#define SDA 18\r#define SCL 19\r\r//=====================================================================\r// プログラム内で使用する定数定義\r// //=====================================================================\r//-----------------------------------------------\r//３軸センサ、輝度センサ I2Cアドレス\r//-----------------------------------------------\r#define I2C_ADC_ADDR_BAT 0x50\r\r#define I2C_SEND_BUF_LENGTH 10\runsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH];\r#define I2C_RECEIVE_BUF_LENGTH 10\runsigned char i2c_receiveBuf[I2C_RECEIVE_BUF_LENGTH];\r//-----------------------------------------------\r// loop() interval\r// MsTimer2のタイマー割り込み発生間隔(ms)\r//-----------------------------------------------\r#define LOOP_INTERVAL 100 // interval\r\r//=====================================================================\r// object\r//=====================================================================\r //=====================================================================\r// プログラムで使用する変数定義\r// //=====================================================================\r\runsigned int dataVR;\runsigned int dataMic;\rfloat dataBatt = 0;\rvolatile bool bInterval = false;\r//=====================================================================\r// setup\r//=====================================================================\r//-----------------------------------------------\r// port\r//-----------------------------------------------\r//=====================================================================\r// IOピンの入出力設定\r// 接続するリーフに合わせて設定する\r//=====================================================================\rvoid setupPort(){\r//---------------------\r // PD port\r //---------------------\r // PD0 : digital 0 = RX\r // PD1 : digital 1 = TX\r\rpinMode(INT0, INPUT); // PD2 : digital 2 = INT0#\r pinMode(INT1, INPUT); // PD3 : digital 3 = INT1#\r pinMode(D4, INPUT); // PD4 : digital 4 = not used\r pinMode(SP, OUTPUT); // PD5 : digital 5 = SP not used\r digitalWrite(SP, LOW);\rpinMode(LED1, OUTPUT); // PD6 : digital 6 = LED1\r digitalWrite(LED1, LOW);\rpinMode(LED2, OUTPUT); // PD7 : digital 7 = LED2\r digitalWrite(LED2, LOW);\r//---------------------\r // PB port\r //---------------------\r pinMode(LED3, OUTPUT); // PB0 : digital 8 = LED3\r digitalWrite(LED3, LOW);\rpinMode(LED4, OUTPUT); // PB1 : digital 9 = LED4\r digitalWrite(LED4, LOW);\rpinMode(LED5, OUTPUT); // PB2 : digital 10 = LED5\r digitalWrite(LED5, LOW);\rpinMode(LED6, OUTPUT); // PB3 : digital 11 = LED6\r digitalWrite(LED6, LOW);\rpinMode(MISO, INPUT); // PB4 : digital 12 = not used\r pinMode(AVR_LED, OUTPUT); // PB5 : digital 13 =LED on 8bit-Dev. Leaf\r digitalWrite(AVR_LED, LOW);\r//---------------------\r // PC port\r //---------------------\r pinMode(D14, INPUT); // PC0 : digital 14 = not used\r pinMode(D15, INPUT); // PC1 : digital 14 = not used\r\rpinMode(MIC, INPUT); // PC2 : digital 14 = not used\r pinMode(VR, INPUT); // PC3 : digital 14 = not used\r\r// PC4 : digital 18 = I2C SDA\r // PC5 : digital 19 = I2C SCL }\r//=====================================================================\r// 割り込み処理初期設定\r// //=====================================================================\r//-----------------------------------------------\r// external interrupt\r// 外部割り込み設定\r//-----------------------------------------------\rvoid setupExtInt(){\rdetachInterrupt(0); // INT0# = disabled\r detachInterrupt(1); // INT1# = disabled\r}\r//-----------------------------------------------\r// timer2 interrupt (interval=125ms, int=overflow)\r// メインループのタイマー割り込み設定\r//-----------------------------------------------\rvoid setupTC2Int(){\rMsTimer2::set(LOOP_INTERVAL, intTimer2);\r}\r//----------------------------------------------\r// INT0\r// INT0割り込み関数\r//----------------------------------------------\rvoid intExtInt0(){\rSerial.println(\u0026#34;int\u0026#34;);\r}\r//----------------------------------------------\r// Timer2 INT\r// タイマー割り込み関数\r//----------------------------------------------\rvoid intTimer2(){\rbInterval = true;\r}\r//=====================================================================\r// I2C　制御関数\r// //=====================================================================\r//-----------------------------------------------\r//I2C スレーブデバイスに1バイト書き込む\r//-----------------------------------------------\rvoid i2c_write_byte(int device_address, int reg_address, int write_data){\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.write(write_data);\rWire.endTransmission();\r}\r//-----------------------------------------------\r//I2C スレーブデバイスから1バイト読み込む\r//-----------------------------------------------\runsigned char i2c_read_byte(int device_address, int reg_address){\rint read_data = 0;\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.endTransmission(false);\rWire.requestFrom(device_address, 1);\rread_data = Wire.read();\rreturn read_data;\r}\r//-----------------------------------------------\r// I2C スレーブデバイスに複数バイト書き込む\r//-----------------------------------------------\rvoid i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rfor (int i = 0; i \u0026lt; lengrh; i++){\rWire.write(write_byte[i]);\r}\rWire.endTransmission();\r}\r//-----------------------------------------------\r//I2C スレーブデバイスから複数バイト読み込む\r//-----------------------------------------------\rvoid i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.endTransmission(false);\rWire.requestFrom(device_address, lengrh);\rfor (int i = 0; i \u0026lt; lengrh; i++){\rread_byte[i] = Wire.read();\r}\r}\r//-----------------------------------------------\r// I2C 受信バッファクリア\r//-----------------------------------------------\rvoid clearI2CReadbuf(){\rmemcpy(i2c_receiveBuf, 0x00, I2C_RECEIVE_BUF_LENGTH);\r}\r//-----------------------------------------------\r// VRとMIC、電池のデータを取得する\r//-----------------------------------------------\rvoid getSencerData()\r{\rdataVR = analogRead(A3); dataMic = analogRead(A2);\r//-------------------------\r // ADC081C027（ADC)\r // 電池リーフ電池電圧取得\r //-------------------------\r uint8_t adcVal1 = 0;\ruint8_t adcVal2 = 0;\rWire.beginTransmission(I2C_ADC_ADDR_BAT);\rWire.write(0x00);\rWire.endTransmission(false);\rWire.requestFrom(I2C_ADC_ADDR_BAT,2);\radcVal1 = Wire.read();\radcVal2 = Wire.read();\rif (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { //測定値がFFならバッテリリーフはつながっていない\r adcVal1 = adcVal2 = 0;\r}\r//電圧計算　ADC　* （(リファレンス電圧(3.3V)/ ADCの分解能(256)) * 分圧比（２倍））\r double temp_mv = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256;\rdataBatt = (float)(temp_mv / 1000);\rSerial.println(\u0026#34;--------------------------------------------------\u0026#34;);\rSerial.print(\u0026#34;MIC = \u0026#34;);\rSerial.println(dataMic,DEC);\rSerial.print(\u0026#34;VR = \u0026#34;);\rSerial.println(dataVR,DEC);\rSerial.print(\u0026#34;VBAT = \u0026#34;);\rSerial.println(dataBatt,DEC); }\r//-----------------------------------------------\r// VRとMICの値にあわせてLEDを点灯、消灯させる\r//-----------------------------------------------\rvoid viewSencerData()\r{ if (dataVR \u0026lt; 400)\r{\rdigitalWrite(LED4,LOW);\rdigitalWrite(LED5,LOW);\rdigitalWrite(LED6,LOW); }\relse if (dataVR \u0026gt;= 400 \u0026amp;\u0026amp; dataVR \u0026lt; 800)\r{\rdigitalWrite(LED4,LOW);\rdigitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); }\relse if (dataVR \u0026gt;= 800 \u0026amp;\u0026amp; dataVR \u0026lt; 900)\r{\rdigitalWrite(LED4,LOW);\rdigitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); }\relse\r{\rdigitalWrite(LED4,HIGH);\rdigitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); }\rif (dataMic \u0026lt; 300)\r{\rdigitalWrite(LED1,LOW);\rdigitalWrite(LED2,LOW); digitalWrite(LED3,LOW); }\relse if (dataMic \u0026gt;= 300 \u0026amp;\u0026amp; dataMic \u0026lt; 350)\r{\rdigitalWrite(LED1,LOW);\rdigitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); }\relse if (dataMic \u0026gt;= 350 \u0026amp;\u0026amp; dataMic \u0026lt; 450)\r{\rdigitalWrite(LED1,LOW);\rdigitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); }\relse\r{\rdigitalWrite(LED1,HIGH);\rdigitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); }\r}\r//-----------------------------------------------\r// setup\r//-----------------------------------------------\rvoid setup() {\r//WDT disable\r wdt_disable();\r//内部の各モジュールの電源OFF\r power_all_disable();\rpower_timer0_enable();\rpower_timer2_enable();\rpower_twi_enable();\rpower_usart0_enable();\rpower_adc_enable();\rdelay(10);\rSerial.begin(115200);\rWire.begin();\rSerial.println(\u0026#34;start!!\u0026#34;);\r//起動テスト(LED)\r digitalWrite(LED1,HIGH);\rdelay(1000);\rdigitalWrite(LED2,HIGH);\rdelay(1000);\rdigitalWrite(LED3,HIGH);\rdelay(1000);\rdigitalWrite(LED4,HIGH);\rdelay(1000);\rdigitalWrite(LED5,HIGH);\rdelay(1000);\rdigitalWrite(LED6,HIGH);\rdelay(1000);\rdigitalWrite(LED1,LOW);\rdigitalWrite(LED2,LOW);\rdigitalWrite(LED3,LOW);\rdigitalWrite(LED4,LOW);\rdigitalWrite(LED5,LOW);\rdigitalWrite(LED6,LOW);\r//\r delay(2000);\rsetupExtInt();\rsetupTC2Int();\rMsTimer2::start();\r}\r//-----------------------------------------------\r// Main\r//-----------------------------------------------\rvoid loop() {\rif (bInterval == true)\r{\rbInterval = false;\rgetSencerData();\rviewSencerData();\r} }\r","excerpt":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type …","ref":"/docs/examples/sound_level/","title":"サウンドレベルメータ"},{"body":"  \n特徴 全てのリーフI/F端子を接続した高さが2mm以上ある部品を使用しているリーフの上に別のリーフを接続するためのリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 全てのリーフI/F端子を接続した高さが2mm以上ある部品を使用しているリーフの上に別のリーフを接続するためのリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト …","ref":"/docs/leaf/extension/ax04a/","title":"AX04A Spacer"},{"body":"概要 工場出荷時に、ESP32 MCUリーフにArduinoのスケッチが書き込まれているので、スマートフォンやパソコンのWi-Fiを使ってタッチセンサの値を送信して、表示がされます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP02A ESP32 MCU 1   AV04A 2V~4.5V 1   AX07A Back to back 1   AX08A 29pin header 1    Screw M2×？mm 4    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード  ESP32 MCUをArduino IDEで使用するには、Arduino core for the ESP32 のインストールが必要です。詳しくは、[こちら]。 Arduino IDEで、以下のスケッチをマイコンボードに書き込んでください。  //=====================================================================\r// Leafony Platform sample sketch\r// Platform : ESP32\r// Processor : ESP32-WROOM-32\r// Application : ESP32 Touch Sensor\r//\r// Leaf configuration\r// (1) AP02A ESP MCU\r// (2) AX08A 29pin header\r//\r// (c) 2019 Trillion-Node Study Group\r// Released under the MIT license\r// https://opensource.org/licenses/MIT\r//\r// Rev.00 2019/11/21 First release\r//=====================================================================\r#include \u0026lt;WiFi.h\u0026gt; // ESP32用WiFiライブラリ\r#include \u0026lt;WiFiClient.h\u0026gt;\r#include \u0026lt;WiFiAP.h\u0026gt;\r\r//----------------------------------------------\r// Wi-Fi Set these to your desired credentials.\r//----------------------------------------------\rconst char *ssid = \u0026#34;Leafony_ESP32-AP\u0026#34;;\rconst char *password = \u0026#34;password\u0026#34;;\rWiFiServer server(80);\r#define TIMEOUT 20000 // タイムアウト 20秒\rint update=1; // ブラウザのページ更新間隔(秒)初期値\r\r//----------------------------------------------\r// Touch\r//----------------------------------------------\rint threshold = 20; // Touch 検出閾値\r// bool touch1detected = false;\r// bool touch2detected = false;\r// bool touch3detected = false;\r// bool touch4detected = false;\r// bool touch5detected = false;\r// bool touch6detected = false;\r\r//----------------------------------------------\r// Touch 割り込み\r//----------------------------------------------\r// ------ T0 ------\r// void gotTouch1(){\r// touch1detected = true;\r// }\r// ------ T3 ------\r// void gotTouch2(){\r// touch2detected = true;\r// }\r// ------ T4 ------\r// void gotTouch3(){\r// touch3detected = true;\r// }\r// ------ T5 ------\r// void gotTouch4(){\r// touch4detected = true;\r// }\r// ------ T6 ------\r// void gotTouch5(){\r// touch5detected = true;\r// }\r// ------ T7 ------\r// void gotTouch6(){\r// touch6detected = true;\r// }\r\r//====================================================================\rvoid setup(){ Serial.begin(115200); // デバッグシリアル出力開始\r Serial.println(\u0026#34;Wi-Fi \u0026amp; Touch Sensor Test\u0026#34;); // シリアル出力表示\r\rWiFi.softAP(ssid, password);\rIPAddress myIP = WiFi.softAPIP();\rSerial.print(\u0026#34;AP IP address: \u0026#34;);\rSerial.println(myIP);\rserver.begin(); // サーバ起動\r delay(1000); // Wait\r Serial.println(\u0026#34;Server started\u0026#34;);\r//----------------------------------------------\r// Touch 割り込み設定\r//----------------------------------------------\r// touchAttachInterrupt(T0, gotTouch1, threshold); // D2/22pin\r// touchAttachInterrupt(T3, gotTouch2, threshold); // D7/9pin\r// touchAttachInterrupt(T4, gotTouch3, threshold); // D5/28pin\r// touchAttachInterrupt(T5, gotTouch4, threshold); // D4/26pin\r// touchAttachInterrupt(T6, gotTouch5, threshold); // D6/7pin\r// touchAttachInterrupt(T7, gotTouch6, threshold); // D3/24pin\r}\r//====================================================================\rvoid loop(){\rdelay(1000); // Wait：これが短いと”このページは動作していません\u0026#34;が頻発する\r WiFiClient client = server.available(); // 接続中のクライアントからデータを受信\r\rchar read_data; // 文字変数を定義\r char s[65]; // 文字列変数を定義 65バイト64文字\r byte data[32]; // 画像転送用の一時保存変数\r int len=0; // 文字列等の長さカウント用\r int t_wait=0; // 更新時間カウント用\r int i,f_size;\rdelay(500); // Wait：これが短いと”このページは動作していません\u0026#34;が頻発する\r client = server.available(); // 接続されたクライアントを生成\r\rif(!client)return; // loop()の先頭に戻る\r// Serial.println(\u0026#34;Connected\u0026#34;); // シリアル出力表示\r while(client.connected()){ // 当該クライアントの接続状態を確認\r if(client.available()){ // クライアントからのデータを確認\r t_wait=0; // 待ち時間変数をリセット\r read_data=client.read(); // データを文字変数read_dataに代入\r\rif(read_data==\u0026#39;\\n\u0026#39;){ // 改行を検出した時\r if(len\u0026gt;5 \u0026amp;\u0026amp; strncmp(s,\u0026#34;GET /\u0026#34;,5)==0) break;\rlen=0; // 文字列長を0に\r }else if(read_data!=\u0026#39;\\r\u0026#39; \u0026amp;\u0026amp; read_data!=\u0026#39;\\0\u0026#39;){\rs[len]=read_data; // 文字列変数に文字read_dataを追加\r len++; // 変数lenに1を加算\r s[len]=\u0026#39;\\0\u0026#39;; // 文字列を終端\r if(len\u0026gt;=64) len=63; // 文字列変数の上限\r }\r}\rt_wait++; // 変数t_waitの値を1増加させる\r if(t_wait\u0026gt;TIMEOUT) break; else delay(1); // TIMEOUTに到達したらwhileを抜ける\r }\rdelay(1); // クライアント側の応答待ち時間\r if(!client.connected()||len\u0026lt;6) return; // 切断された場合はloop()の先頭へ\r// Serial.println(s); // 受信した命令をシリアル出力表示\r if(strncmp(s,\u0026#34;GET / \u0026#34;,6)==0){ // コンテンツ取得命令時\r //----------------------------------------------\r // Web 表示\r //----------------------------------------------\r html(client,update,WiFi.softAPIP()); // コンテンツ表示\r client.flush(); // ESP32用 ERR_CONNECTION_RESET対策\r// client.stop(); // クライアントの切断\r return; // 処理の終了・loop()の先頭へ\r }\r//----------------------------------------------\r // 更新時間の設定\r //----------------------------------------------\r if(strncmp(s,\u0026#34;GET /?INT=\u0026#34;,10)==0){ // 更新時間の設定命令を受けた時\r update = atoi(\u0026amp;s[10]); // 受信値を変数updateに代入\r }\r//----------------------------------------------\r // コマンド送信\r //----------------------------------------------\r for(i=6;i\u0026lt;strlen(s);i++) if(s[i]==\u0026#39; \u0026#39;||s[i]==\u0026#39;+\u0026#39;) s[i]=\u0026#39;\\0\u0026#39;;\rhtmlMesg(client,\u0026amp;s[6],WiFi.softAPIP()); // メッセージ表示\r client.flush(); // ESP32用 ERR_CONNECTION_RESET対策\r// client.stop(); // クライアント切断\r Serial.println(\u0026#34;Sent HTML\u0026#34;); // シリアル出力表示\r}\r* ESP32_AP_Touch.inoと同じフォルダに保存してください。自動的に読み込まれます\r//=====================================================================\r// Leafony Platform sample sketch\r// Application : html\r//\r// (c) 2019 Trillion-Node Study Group\r// Released under the MIT license\r// https://opensource.org/licenses/MIT\r//\r// Rev.00 2019/11/07 First release\r//=====================================================================\r//====================================================================\r// Web表示\r//====================================================================\rvoid html(WiFiClient \u0026amp;client, int update, uint32_t ip){\rchar s[65],s_ip[16];\ruint16_t touchData;\ruint16_t touchTemp;\rsprintf(s_ip,\u0026#34;%d.%d.%d.%d\u0026#34;,\rip \u0026amp; 255,\rip\u0026gt;\u0026gt;8 \u0026amp; 255,\rip\u0026gt;\u0026gt;16 \u0026amp; 255,\rip\u0026gt;\u0026gt;24\r);\rclient.println(\u0026#34;HTTP/1.1 200 OK\u0026#34;); // HTTP OKを応答\r client.println(\u0026#34;Content-Type: text/html\u0026#34;); // HTMLコンテンツ\r client.println(\u0026#34;Connection: close\u0026#34;); // 応答終了後にセッションを閉じる\r client.println();\rclient.println(\u0026#34;\u0026lt;html\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Test Page\u0026lt;/title\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;meta http-equiv=\\\u0026#34;Content-type\\\u0026#34;content=\\\u0026#34;text/html; charset=UTF-8\\\u0026#34;\u0026gt;\u0026#34;);\rif(update){\rclient.print(\u0026#34;\u0026lt;meta http-equiv=\\\u0026#34;refresh\\\u0026#34;content=\\\u0026#34;\u0026#34;);\rclient.print(update);\rclient.print(\u0026#34;;URL=http://\u0026#34;);\rclient.print(s_ip);\rclient.println(\u0026#34;/\\\u0026#34;\u0026gt;\u0026#34;);\r}\rclient.println(\u0026#34;\u0026lt;/head\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;body\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;h3\u0026gt;Wi-Fi \u0026amp; Touch Sensor Test\u0026lt;/h3\u0026gt;\u0026#34;);\r// ------ T6 ------\r touchData=touchRead(T6);\rclient.print(\u0026#34;F7 /D6:\u0026#34;);\rfor (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){\rclient.print(\u0026#34;*\u0026#34;);\r}\rclient.print(\u0026#34;:\u0026#34;+String(touchData));\r// if(touch5detected){\r if(touchData\u0026lt;=threshold){\r// touch5detected = false;\r Serial.println(\u0026#34;T6/D6/ 7pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;);\rclient.println(\u0026#34; :Touch detected\u0026#34;);\r}\rclient.println(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;);\r// ------ T3 ------\r touchData=touchRead(T3);\rclient.print(\u0026#34;F9 /D7:\u0026#34;);\rfor (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){\rclient.print(\u0026#34;*\u0026#34;);\r}\rclient.print(\u0026#34;:\u0026#34;+String(touchData));\r// if(touch2detected){\r if(touchData\u0026lt;=threshold){\r// touch2detected = false;\r Serial.println(\u0026#34;T3/D7/ 9pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;);\rclient.println(\u0026#34; :Touch detected\u0026#34;);\r}\rclient.println(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;);\r// ------ T0 ------\r touchData=touchRead(T0);\rclient.print(\u0026#34;F22/D2:\u0026#34;);\rfor (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){\rclient.print(\u0026#34;*\u0026#34;);\r}\rclient.print(\u0026#34;:\u0026#34;+String(touchData));\r// if(touch1detected){\r if(touchData\u0026lt;=threshold){\r// touch1detected = false;\r Serial.println(\u0026#34;T0/D2/22pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;);\rclient.println(\u0026#34; :Touch detected\u0026#34;);\r}\rclient.println(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;);\r/*\r// ------ T7 ------\rtouchData=touchRead(T7);\rclient.print(\u0026#34;F24/D3:\u0026#34;);\rfor (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){\rclient.print(\u0026#34;*\u0026#34;);\r}\rclient.print(\u0026#34;:\u0026#34;+String(touchData));\r// if(touch6detected){\rif(touchData\u0026lt;=threshold){\r// touch6detected = false;\rSerial.println(\u0026#34;T7/D3/24pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;);\rclient.println(\u0026#34; :Touch detected\u0026#34;);\r}\rclient.print(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;);\r*/\r// ------ T5 ------\r touchData=touchRead(T5);\rclient.print(\u0026#34;F26/D4:\u0026#34;);\rfor (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){\rclient.print(\u0026#34;*\u0026#34;);\r}\rclient.print(\u0026#34;:\u0026#34;+String(touchData));\r// if(touch4detected){\r if(touchData\u0026lt;=threshold){\r// touch4detected = false;\r Serial.println(\u0026#34;T5/D4/26pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;);\rclient.println(\u0026#34; :Touch detected\u0026#34;);\r}\rclient.println(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;);\r// ------ T4 ------\r touchData=touchRead(T4);\rclient.print(\u0026#34;F28/D5:\u0026#34;);\rfor (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){\rclient.print(\u0026#34;*\u0026#34;);\r}\rclient.print(\u0026#34;:\u0026#34;+String(touchData));\r// if(touch3detected){\r if(touchData\u0026lt;=threshold){\r// touch3detected = false;\r Serial.println(\u0026#34;T4/D5/28pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;);\rclient.println(\u0026#34; :Touch detected\u0026#34;);\r}\rclient.println(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;);\rclient.print(\u0026#34;更新間隔 = \u0026#34;);\rclient.print(update);\rclient.println(\u0026#34; 秒\u0026lt;/p\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;hr\u0026gt;\u0026#34;);\r// client.println(\u0026#34;\u0026lt;h3\u0026gt;HTTP GET\u0026lt;/h3\u0026gt;\u0026#34;);\r client.print(\u0026#34;\u0026lt;p\u0026gt;http://\u0026#34;);\rclient.print(s_ip);\rsprintf(s,\u0026#34;\u0026lt;form method=\\\u0026#34;GET\\\u0026#34;action=\\\u0026#34;http://%s/\\\u0026#34;\u0026gt;\u0026#34;,s_ip);\rclient.println(s);\rclient.println(\u0026#34;自動更新:\u0026lt;input type=\\\u0026#34;submit\\\u0026#34;name=\\\u0026#34;INT\\\u0026#34;value=\\\u0026#34;0 停止\\\u0026#34;\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;input type=\\\u0026#34;submit\\\u0026#34;name=\\\u0026#34;INT\\\u0026#34;value=\\\u0026#34;1 秒\\\u0026#34;\u0026gt;\u0026#34;);\r// client.println(\u0026#34;\u0026lt;input type=\\\u0026#34;submit\\\u0026#34; name=\\\u0026#34;INT\\\u0026#34; value=\\\u0026#34;2 秒\\\u0026#34;\u0026gt;\u0026#34;);\r// client.println(\u0026#34;\u0026lt;input type=\\\u0026#34;submit\\\u0026#34; name=\\\u0026#34;INT\\\u0026#34; value=\\\u0026#34;5 秒\\\u0026#34;\u0026gt;\u0026#34;);\r// client.println(\u0026#34;\u0026lt;input type=\\\u0026#34;submit\\\u0026#34; name=\\\u0026#34;INT\\\u0026#34; value=\\\u0026#34;10 秒\\\u0026#34;\u0026gt;\u0026#34;);\r// client.println(\u0026#34;　\u0026lt;input type=\\\u0026#34;submit\\\u0026#34; name=\\\u0026#34;RESET\\\u0026#34; value=\\\u0026#34;リセット\\\u0026#34;\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026#34;);\r\rclient.println(\u0026#34;\u0026lt;/form\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;/body\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;/html\u0026gt;\u0026#34;);\r}\r//====================================================================\r// コマンド送信\r//====================================================================\rvoid htmlMesg(WiFiClient \u0026amp;client, char *txt, uint32_t ip){\rchar s_ip[16];\rsprintf(s_ip,\u0026#34;%d.%d.%d.%d\u0026#34;,\rip \u0026amp; 255,\rip\u0026gt;\u0026gt;8 \u0026amp; 255,\rip\u0026gt;\u0026gt;16 \u0026amp; 255,\rip\u0026gt;\u0026gt;24\r);\rclient.println(\u0026#34;HTTP/1.1 200 OK\u0026#34;); // HTTP OKを応答\r client.println(\u0026#34;Content-Type: text/html\u0026#34;); // HTMLコンテンツ\r client.println(\u0026#34;Connection: close\u0026#34;); // 応答終了後にセッションを閉じる\r client.println();\rclient.println(\u0026#34;\u0026lt;html\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Test Page2\u0026lt;/title\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;meta http-equiv=\\\u0026#34;Content-type\\\u0026#34;content=\\\u0026#34;text/html; charset=UTF-8\\\u0026#34;\u0026gt;\u0026#34;);\rclient.print(\u0026#34;\u0026lt;meta http-equiv=\\\u0026#34;refresh\\\u0026#34;content=\\\u0026#34;3;URL=http://\u0026#34;);\rclient.print(s_ip);\rclient.println(\u0026#34;/\\\u0026#34;\u0026gt;\u0026#34;);\rclient.print(\u0026#34;\u0026lt;p\u0026gt;\u0026#34;);\rclient.print(txt);\rclient.println(\u0026#34;\u0026lt;/p\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;/body\u0026gt;\u0026#34;);\rclient.println(\u0026#34;\u0026lt;/html\u0026gt;\u0026#34;);\r}\r Arduino IDE 1.8.9で動作を確認しています。書き込みエラーが発生したら、IDEのバージョンを確認してください  表示のやり方 表示のやり方は、クイックスタートに記載していますので、ご参照願います。\n","excerpt":"概要 工場出荷時に、ESP32 MCUリーフにArduinoのスケッチが書き込まれているので、スマートフォンやパソコンのWi-Fiを使ってタッチセンサの値を送信して、表示がされます。\n使用するリーフ  …","ref":"/docs/examples/wifi_touchsensor/","title":"Wi-Fi タッチセンサ"},{"body":"概要 SP\u0026amp;PIR(圧電スピーカと人感センサ）に接近すると、人感センサが検知し、圧電スピーカからビープ音（メロディ）が鳴ります。 使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI02A SP\u0026amp;PIR 1   AP01A AVR MCU 1   AZ01A USB 1   AV01A CR2032 1   AZ62A コネクタカバー 1    CR2032 コイン電池 1    M2ネジ 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n ビープ音の場合  //=====================================================================\r// Leafony Platform sample sketch\r// Platform : PIR\u0026amp;SP\r// Processor : ATmega328P (3.3V /8MHz)\r// Application : PIR with SP Beep\r//\r// Leaf configuration\r// (1) AI02 SP\u0026amp;PIR\r// (2) AP01 AVR MCU\r// (3) AZ01 USB\r//\r//\t(c) 2019 Trillion-Node Study Group\r//\tReleased under the MIT license\r//\thttps://opensource.org/licenses/MIT\r//\r// Rev.00 2019/08/01 First release\r//=====================================================================\r//=====================================================================\r// difinition\r//=====================================================================\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;Arduino.h\u0026gt;\r#include \u0026lt;Wire.h\u0026gt;\r\r#define I2C_PIR_ADDR 0x65\r#define I2C_SEND_BUF_LENGTH 10\runsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH];\r#define I2C_RECEIVE_BUF_LENGTH 10\runsigned char i2c_receiveBuf[I2C_RECEIVE_BUF_LENGTH];\runsigned char i2c_receiveLenght;\rbyte readReg;\rdouble irData;\rdouble tempData;\rchar buf[120];\rvolatile int state = 0; //=====================================================================\r// setup\r//=====================================================================\rvoid setup() {\r//pinMode(2, INPUT);\r attachInterrupt(0,catchHuman , FALLING ); //人接近検知割り込み\r Wire.begin();\rSerial.begin( 115200 );\rdelay(100);\r//人感センサ設定\r i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効\r i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)\r i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)\r delay(1000);\r}\r//=====================================================================\r// Main loop\r//=====================================================================\rvoid loop() {\rclearI2CReadbuf();\ri2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_receiveBuf);\rsprintf(buf, \u0026#34;REG = %02X , %02X , %02X , %02X , %02X , %02X\u0026#34;, i2c_receiveBuf[0], i2c_receiveBuf[1], i2c_receiveBuf[2], i2c_receiveBuf[3], i2c_receiveBuf[4], i2c_receiveBuf[5]);\rSerial.println(buf);\rsprintf(buf, \u0026#34;Human detection = %d\u0026#34;, (i2c_receiveBuf[0] \u0026amp; 0x10) \u0026gt;\u0026gt; 4 );\rSerial.println(buf);\r//IRセンサ測定データ\r irData = clacIR();\rSerial.print(\u0026#34;IR = \u0026#34;);\rSerial.print(irData,2);\rSerial.println(\u0026#34; pA\u0026#34;);\r//センサ温度\r tempData = clacTemp();\rSerial.print(\u0026#34;TSENS = \u0026#34;);\rSerial.print(tempData,2);\rSerial.println(\u0026#34; deg\u0026#34;);\rSerial.println(\u0026#34;===================================\u0026#34;);\rif (state == 1){\rtone(5, 262, 300);\rstate = 0;\r}\rdelay(1000); }\r//=====================================================================\rvoid catchHuman()\r{\rstate = 1;\rSerial.println(\u0026#34;!! Interrupt !!\u0026#34;); //人の接近を検知\r}\r//=====================================================================\rdouble clacTemp()\r{ double ret;\runsigned short val = (unsigned short)((i2c_receiveBuf[4] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[3]);\rif ( (val \u0026amp; 0x8000) == 0x8000)\r{\rval = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1;\r}\relse\r{\rret = (double)val * 0.0019837;\r}\rreturn ret + 25;\r}\r//=====================================================================\rdouble clacIR()\r{ double ret;\runsigned short val = (unsigned short)((i2c_receiveBuf[2] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[1]);\rif ( (val \u0026amp; 0x8000) == 0x8000)\r{\rval = ~val + 1;\rret = (double)(val * 0.4578 ) * -1;\r}\relse\r{\rret = (double)(val * 0.4578 );\r} return ret;\r}\r/**********************************************\r* I2C スレーブデバイスに1バイト書き込む\r**********************************************/\rvoid i2c_write_byte(int device_address, int reg_address, int write_data){\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.write(write_data);\rWire.endTransmission();\r}\r/**********************************************\r* I2C スレーブデバイスから1バイト読み込む\r**********************************************/\runsigned char i2c_read_byte(int device_address, int reg_address){\rint read_data = 0;\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.endTransmission(false);\rWire.requestFrom(device_address, 1);\rread_data = Wire.read();\rreturn read_data;\r}\r/**********************************************\r* I2C スレーブデバイスに複数バイト書き込む\r**********************************************/\rvoid i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rfor (int i = 0; i \u0026lt; lengrh; i++){\rWire.write(write_byte[i]);\r}\rWire.endTransmission();\r}\r/**********************************************\r* I2C スレーブデバイスから複数バイト読み込む\r**********************************************/\rvoid i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.endTransmission(false);\rWire.requestFrom(device_address, lengrh);\rfor (int i = 0; i \u0026lt; lengrh; i++){\rread_byte[i] = Wire.read();\r}\r}\r/**********************************************\r* I2C 受信バッファクリア\r**********************************************/\rvoid clearI2CReadbuf(){\rmemcpy(i2c_receiveBuf, 0x00, I2C_RECEIVE_BUF_LENGTH);\r}\r メロディの場合  //=====================================================================\r// Leafony Platform sample sketch\r// Platform : PIR\u0026amp;SP\r// Processor : ATmega328P (3.3V /8MHz)\r// Application : PIR with SP Beep\r//\r// Leaf configuration\r// (1) AI02 SP\u0026amp;PIR\r// (2) AP01 AVR MCU\r// (3) AZ01 USB\r//\r//\t(c) 2019 Trillion-Node Study Group\r//\tReleased under the MIT license\r//\thttps://opensource.org/licenses/MIT\r//\r// Rev.00 2019/08/01 First release\r//=====================================================================\r//=====================================================================\r// difinition\r//=====================================================================\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;Arduino.h\u0026gt;\r#include \u0026lt;Wire.h\u0026gt;\r#include \u0026#34;pitches.h\u0026#34;\r\r#define I2C_PIR_ADDR 0x65\r#define I2C_SEND_BUF_LENGTH 10\runsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH];\r#define I2C_RECEIVE_BUF_LENGTH 10\runsigned char i2c_receiveBuf[I2C_RECEIVE_BUF_LENGTH];\runsigned char i2c_receiveLenght;\r//------------------------------\r// buzzer output = 5pin\r//------------------------------\r#define BUZZER_OUT 5\r\rbyte readReg;\rdouble irData;\rdouble tempData;\rchar buf[120];\rvolatile int state = 0; //=====================================================================\r// setup\r//=====================================================================\rvoid setup() {\r//pinMode(2, INPUT);\r attachInterrupt(0,catchHuman , FALLING ); //人接近検知割り込み\r Wire.begin();\rSerial.begin( 115200 );\rdelay(100);\r//人感センサ設定\r i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効\r i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)\r i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)\r delay(1000);\r}\r//=====================================================================\r// Main loop\r//=====================================================================\rvoid loop() {\rclearI2CReadbuf();\ri2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_receiveBuf);\rsprintf(buf, \u0026#34;REG = %02X , %02X , %02X , %02X , %02X , %02X\u0026#34;, i2c_receiveBuf[0], i2c_receiveBuf[1], i2c_receiveBuf[2], i2c_receiveBuf[3], i2c_receiveBuf[4], i2c_receiveBuf[5]);\rSerial.println(buf);\rsprintf(buf, \u0026#34;Human detection = %d\u0026#34;, (i2c_receiveBuf[0] \u0026amp; 0x10) \u0026gt;\u0026gt; 4 );\rSerial.println(buf);\r//IRセンサ測定データ\r irData = clacIR();\rSerial.print(\u0026#34;IR = \u0026#34;);\rSerial.print(irData,2);\rSerial.println(\u0026#34; pA\u0026#34;);\r//センサ温度\r tempData = clacTemp();\rSerial.print(\u0026#34;TSENS = \u0026#34;);\rSerial.print(tempData,2);\rSerial.println(\u0026#34; deg\u0026#34;);\rSerial.println(\u0026#34;===================================\u0026#34;);\rif (state == 1){\r//------------------------------\r // notes in the melody:\r //------------------------------\r int melody[] = {\rNOTE_C5, NOTE_C5, NOTE_G5, NOTE_G5, NOTE_A5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_F5, NOTE_E5, NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5\r};\r//------------------------------\r // note durations: 4 = quarter note, 8 = eighth note, etc.:\r //------------------------------\r int noteDurations[] = {\r4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 2\r};\r//----------------------------------------\r // iterate over the notes of the melody:\r //----------------------------------------\r for (int thisNote = 0; thisNote \u0026lt; 14; thisNote++) {\r//----------------------------------------\r // to calculate the note duration, take one second\r // divided by the note type.\r //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.\r //----------------------------------------\r int noteDuration = 1000 / noteDurations[thisNote];\rtone(BUZZER_OUT, melody[thisNote], noteDuration);\r//----------------------------------------\r // to distinguish the notes, set a minimum time between them.\r // the note\u0026#39;s duration + 30% seems to work well:\r //----------------------------------------\r float pauseBetweenNotes = noteDuration * 1.30;\rdelay(pauseBetweenNotes);\r//-----------------------\r // stop the tone playing:\r //-----------------------\r noTone(BUZZER_OUT);\r}\rstate = 0;\r}\rdelay(1000); }\r//=====================================================================\rvoid catchHuman(){\rstate = 1;\rSerial.println(\u0026#34;!! Interrupt !!\u0026#34;); //人の接近を検知\r}\r//=====================================================================\rdouble clacTemp(){\rdouble ret;\runsigned short val = (unsigned short)((i2c_receiveBuf[4] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[3]);\rif ( (val \u0026amp; 0x8000) == 0x8000) {\rval = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1;\r}\relse {\rret = (double)val * 0.0019837;\r}\rreturn ret + 25;\r}\r//=====================================================================\rdouble clacIR(){\rdouble ret;\runsigned short val = (unsigned short)((i2c_receiveBuf[2] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[1]);\rif ( (val \u0026amp; 0x8000) == 0x8000) {\rval = ~val + 1;\rret = (double)(val * 0.4578 ) * -1;\r}\relse {\rret = (double)(val * 0.4578 );\r} return ret;\r}\r/**********************************************\r* I2C スレーブデバイスに1バイト書き込む\r**********************************************/\rvoid i2c_write_byte(int device_address, int reg_address, int write_data){\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.write(write_data);\rWire.endTransmission();\r}\r/**********************************************\r* I2C スレーブデバイスから1バイト読み込む\r**********************************************/\runsigned char i2c_read_byte(int device_address, int reg_address){\rint read_data = 0;\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.endTransmission(false);\rWire.requestFrom(device_address, 1);\rread_data = Wire.read();\rreturn read_data;\r}\r/**********************************************\r* I2C スレーブデバイスに複数バイト書き込む\r**********************************************/\rvoid i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rfor (int i = 0; i \u0026lt; lengrh; i++){\rWire.write(write_byte[i]);\r}\rWire.endTransmission();\r}\r/**********************************************\r* I2C スレーブデバイスから複数バイト読み込む\r**********************************************/\rvoid i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.endTransmission(false);\rWire.requestFrom(device_address, lengrh);\rfor (int i = 0; i \u0026lt; lengrh; i++){\rread_byte[i] = Wire.read();\r}\r}\r/**********************************************\r* I2C 受信バッファクリア\r**********************************************/\rvoid clearI2CReadbuf(){\rmemcpy(i2c_receiveBuf, 0x00, I2C_RECEIVE_BUF_LENGTH);\r}\r","excerpt":"概要 SP\u0026amp;PIR(圧電スピーカと人感センサ）に接近すると、人感センサが検知し、圧電スピーカからビープ音（メロディ）が鳴ります。 使用するリーフ 以下のリーフを使用します\n   Type …","ref":"/docs/examples/ir_sensor/","title":"人感センサ"},{"body":"  \n特徴 3.3VおよびVBUSの消費電流を測定することが出来るリーフです。 電流測定リーフでは3.3VとVBUSは表面と裏面のパッドが電気的に切り離されているので、下記の各々スルーホールに電流計を接続することで、電池リーフから遠い部分にある単体リーフあるいは複数リーフ群の全電源電流を測定出来ます。下の例では、センサーリーフとBLEリーフが電流測定リーフを介して、電池リーフの遠い側に配置されているので、両リーフの合計電流が測定出来ます。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 3.3VおよびVBUSの消費電流を測定することが出来るリーフです。 電流測定リーフでは3.3VとVBUSは表面と裏面のパッドが電気的に切り離されているので、下記の各々スルーホールに電流計を …","ref":"/docs/leaf/extension/ax05a/","title":"AX05A I Meas"},{"body":"概要 電源リーフには、電池電圧をモニタするためのADコンバータを実装。温度、湿度、照度、傾きだけでなく、電池電圧も測定し、LCDに表示させます。 温度（または、湿度）の補正の仕方 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。詳しくは、こちら。\n必要なハードウェアの準備    Type Name Q\u0026rsquo;ty     AI04A LCD 1   AI01A 4-Sensors 1   AP01A AVR MCU 1   AZ01A USB 1   AX03A Leaf×2 1   AV01A CR2032 1   AZ62A Connector Cover 2   AZ63A Nut Plate 1    CR2032 3V Lithium coin cell battery 1    Screw M2×25mm 4    リーフの組立 ソースコード  書き込みには、4-Sensors、LCD、AVR MCUライブラリ（タイマ割り込み）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、[こちら]。 Arduino IDEで、以下のスケッチをマイコンボードに書き込んでください。  //=====================================================================\r// Leafony Platform sample sketch\r// Platform : 4-Sensors\r// Processor : ATmega328P (3.3V /8MHz)\r// Application : 4-Sensors with LCD\r//\r// Leaf configuration\r// (1) AI01 4-Sensors\r// (2) AI04 LCD\r// (3) AP01 AVR MCU\r// (4) AV02 CR2450 or AV01 CR2032\r// (5) AZ01 USB\t(for debug)\r//\r//\t(c) 2019 Trillion-Node Study Group\r//\tReleased under the MIT license\r//\thttps://opensource.org/licenses/MIT\r//\r// Rev.00 2019/08/20 First release\r//=====================================================================\r//use libraries\r//Adafruit LIS3DH\r//https://github.com/adafruit/Adafruit_LIS3DH\r//※ Adafruit_LIS3DH.h\r// uint8_t readRegister8(uint8_t reg);\r// void writeRegister8(uint8_t reg, uint8_t value);\r// をpublic:に移動する\r//Adafruit Unified Sensor Driver\r//https://github.com/adafruit/Adafruit_Sensor\r//SmartEverything ST HTS221 Humidity Sensor\r//https://github.com/ameltech/sme-hts221-library\r//ClosedCube Arduino Library for ClosedCube OPT3001\r//https://github.com/closedcube/ClosedCube_OPT3001_Arduino\r//ST7032 - Arduino LiquidCrystal compatible library\r//https://github.com/tomozh/arduino_ST7032\r//=====================================================================\r\r//=====================================================================\r// difinition\r//=====================================================================\r#include \u0026lt;MsTimer2.h\u0026gt;\r#include \u0026lt;avr/wdt.h\u0026gt;\r#include \u0026lt;avr/sleep.h\u0026gt;\r#include \u0026lt;avr/power.h\u0026gt;\r\r#include \u0026lt;Wire.h\u0026gt;\r#include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #include \u0026lt;Adafruit_Sensor.h\u0026gt;\r#include \u0026lt;HTS221.h\u0026gt;\r#include \u0026lt;ClosedCube_OPT3001.h\u0026gt;\r#include \u0026lt;SoftwareSerial.h\u0026gt;\r#include \u0026lt;ST7032.h\u0026gt;\r//=====================================================================\r\r//=====================================================================\r// シリアルコンソールへのデバック出力\r// #define DEBUG = 出力あり\r//　//#define DEBUG = 出力なし（コメントアウトする）\r//=====================================================================\r#define DEBUG\r//=====================================================================\r\r//=====================================================================\r// IOピンの名前定義\r// 接続するリーフに合わせて定義する\r//=====================================================================\r// --------------------------------------------\r// PD port\r// digital 0: PD0 = PCRX (HW UART)\r// digital 1: PD1 = PCTX (HW UART)\r// digital 2: PD2 = INT0#\r// digital 3: PD3 = INT1#\r// digital 4: PD4 = Reserved /* not use */\r// digital 5: PD5 = Reserved /* not use */\r// digital 6: PD6 = Reserved /* not use */\r// digital 7: PD7 = Reserved /* not use */\r// --------------------------------------------\r#define PCTX 0\r#define PCRX 1\r#define INT0 2\r#define INT1 3\r#define RSV_D4 4 #define RSV_D5 5\r#define RSV_D6 6\r#define RSV_D7 7\r\r// --------------------------------------------\r// PB port\r// digital 8: PB0 = Reserved /* not use */\r// digital 9: PB1 = Reserved /* not use */\r// digital 10:PB2 = SS#\r// digital 11:PB3 = MOSI\r// digital 12:PB4 = MISO\r// digital 13:PB5 = SCK (LED)\r// PB6 = XTAL1\r// PB7 = XTAL2\r//---------------------------------------------\r#define RSV_D8 8\r#define RSV_D9 9\r#define SS 10\r#define MOSI 11\r#define MISO 12\r#define LED_PIN 13\r\r// --------------------------------------------\r// PC port\r// digital 14/ Analog0: PC0 = Reserved /* not use */\r// digital 15/ Analog1: PC1 = Reserved /* not use */\r// digital 16/ Analog2: PC2 = Reserved /* not use */\r// digital 17/ Analog3: PC3 = Reserved /* not use */\r// digital 18/ SDA : PC4 = SDA (I2C)\r// digital 19/ SCL : PC5 = SCL (I2C)\r// RESET : PC6 = RESET#\r//-----------------------------------------------\r#define RSV_D14 14\r#define RSV_D15 15\r#define RSV_D16 16\r#define RSV_D17 17\r#define SDA 18\r#define SCL 19\r\r//=====================================================================\r// プログラム内で使用する定数定義\r// //=====================================================================\r//-----------------------------------------------\r//３軸センサ、輝度センサ I2Cアドレス\r//-----------------------------------------------\r#define LIS2DH_ADDRESS 0x19 // SD0/SA0 pin = VCC #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC\r#define I2C_EXPANDER_ADDR_LCD 0x1A\r\r//-----------------------------------------------\r// loop() interval\r// MsTimer2のタイマー割り込み発生間隔(ms)\r//-----------------------------------------------\r#define LOOP_INTERVAL 125 // 125ms interval\r\r//-----------------------------------------------\r// LIS2DH\r//-----------------------------------------------\r#define DIVIDER_2G 16383 // full scale 2G (=0xFFFF/4)\r#define DIVIDER_4G 8191 // full scale 4G (=0xFFFF/4/2)\r#define DIVIDER_8G 4096 // full scale 8G (=0xFFFF/4/4)\r#define DIVIDER_16G 1365 // full scale 16G (=0xFFFF/4/12)\r\r//-----------------------------------------------\r// Batt ADC ADC081C027\r//-----------------------------------------------\r#define BATT_ADC_ADDR 0x50\r\r//=====================================================================\r// object\r//=====================================================================\r//-----------------------------------------------\r// Sensor\r//-----------------------------------------------\rAdafruit_LIS3DH accel = Adafruit_LIS3DH();\rClosedCube_OPT3001 light; //-----------------------------------------------\r// LCD\r//-----------------------------------------------\r ST7032 lcd;\r//=====================================================================\r// プログラムで使用する変数定義\r// //=====================================================================\r//=====================================================================\r// RAM data\r//=====================================================================\r//---------------------------\r// loop counter\r//---------------------------\ruint8_t iLoop1s = 0;\r//---------------------------\r// event\r//---------------------------\rbool eventSensorRead = false;\rbool eventWriteLCD = false;\r//---------------------------\r// int0 interrupt\r//---------------------------\rvolatile bool bEventSleep = false;\r//---------------------------\r// interval Timer2 interrupt\r//---------------------------\rvolatile bool bInterval = false;\r//---------------------------\r// LIS2DH : accelerometer\r//---------------------------\rint16_t dataX, dataY, dataZ;\rfloat dataX_g, dataY_g, dataZ_g;\rfloat dataTilt, avrTilt;\r//---------------------------\r// HTS221 : Temperature/Humidity\r//---------------------------\rfloat dataTemp, avrTemp;\rfloat dataHumid, avrHumid;\rfloat calcTemp = 0;\rfloat calcHumid = 0;\r//---------------------------\r// 2点補正用データ\r//---------------------------\r// 温度補正用データ0\rfloat TL0 = 25.0; // 4-Sensors温度測定値\rfloat TM0 = 25.0; // 温度計等測定値\r// 温度補正用データ1\rfloat TL1 = 40.0; // 4-Sensors温度測定値\rfloat TM1 = 40.0; // 温度計等測定値\r\r// 湿度補正用データ0\rfloat HL0 = 60.0; // 4-Sensors湿度測定値\rfloat HM0 = 60.0; // 湿度計等測定値\r// 湿度補正用データ1\rfloat HL1 = 80.0; // 4-Sensors湿度測定値\rfloat HM1 = 80.0; // 湿度計等測定値\r\r//---------------------------\r// OPT3001 : Light\r//---------------------------\rfloat dataLight, avrLight;\rfloat calcLight = 0;\r//---------------------------\r// LCD\r//---------------------------\rvolatile bool bLCDchange = false;\rvolatile int lcd_view_sts = 0; //---------------------------\r// Sleep, Watchdog Timer\r//---------------------------\r\rvolatile int countWDT = 0;\rvolatile int wakeupWDT = 2;\r//---------------------------\r// Batt\r//---------------------------\rfloat dataBatt = 0;\r//=====================================================================\r// setup\r//=====================================================================\r//-----------------------------------------------\r// port\r//-----------------------------------------------\r//=====================================================================\r// IOピンの入出力設定\r// 接続するリーフに合わせて設定する\r//=====================================================================\rvoid setupPort(){\r//---------------------\r // PD port\r //---------------------\r // PD0 : digital 0 = RX\r // PD1 : digital 1 = TX\r\rpinMode(INT0, INPUT); // PD2 : digital 2 = BLE interrupt\r pinMode(INT1, INPUT); // PD3 : digital 3 = sensor interrupt\r\r//---------------------\r // PB port\r //---------------------\r pinMode(LED_PIN, OUTPUT); // PB5 : digital 13 = DEV _LED\r digitalWrite(LED_PIN, LOW);\r//---------------------\r // PC port\r //---------------------\r // PC4 : digital 18 = I2C SDA\r // PC5 : digital 19 = I2C SCL }\r//=====================================================================\r// 割り込み処理初期設定\r// //=====================================================================\r//-----------------------------------------------\r// external interrupt\r// 外部割り込み設定\r//-----------------------------------------------\rvoid setupExtInt(){\rattachInterrupt(0, intExtInt0, FALLING); // Sw1 INT0# = enabled\r detachInterrupt(1); // sensor INT1# = disabled\r}\r//-----------------------------------------------\r// timer2 interrupt (interval=125ms, int=overflow)\r// メインループのタイマー割り込み設定\r//-----------------------------------------------\rvoid setupTC2Int(){\rMsTimer2::set(LOOP_INTERVAL, intTimer2);\r}\r//=====================================================================\r// I2C　制御関数\r// //=====================================================================\r//-----------------------------------------------\r//I2C スレーブデバイスに1バイト書き込む\r//-----------------------------------------------\rvoid i2c_write_byte(int device_address, int reg_address, int write_data){\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.write(write_data);\rWire.endTransmission();\r}\r//-----------------------------------------------\r//I2C スレーブデバイスから1バイト読み込む\r//-----------------------------------------------\runsigned char i2c_read_byte(int device_address, int reg_address){\rint read_data = 0;\rWire.beginTransmission(device_address);\rWire.write(reg_address);\rWire.endTransmission(false);\rWire.requestFrom(device_address, 1);\rread_data = Wire.read();\rreturn read_data;\r}\r//=====================================================================\r// 各デバイスの初期設定\r// //=====================================================================\r//-----------------------------------------------\r// sensor\r//-----------------------------------------------\rvoid setupSensor(){\r//-------------------------------------\r // LIS2DH (accelerometer)\r //-------------------------------------\r //-------------------\r // I2C address\r //------------------\r accel.begin(LIS2DH_ADDRESS);\r//-------------------\r // register\r //-------------------\r accel.writeRegister8(LIS3DH_REG_CTRL1, 0x07); //X,Y,Z axis = enable\r accel.setDataRate(LIS3DH_DATARATE_1_HZ); //Data rate = 1Hz\r accel.writeRegister8(LIS3DH_REG_CTRL2, 0x00);\raccel.writeRegister8(LIS3DH_REG_CTRL3, 0x00); // INT Disable\r accel.writeRegister8(LIS3DH_REG_CTRL4, 0x80); //BUD = enable, Scale = +/-2g\r\r//-------------------------------------\r // HTS221 (temperature /humidity)\r //-------------------------------------\r smeHumidity.begin(); //-------------------------------------\r // OPT3001 (light)\r //-------------------------------------\r OPT3001_Config newConfig;\rOPT3001_ErrorCode errorConfig;\r//-------------------\r // I2C address\r //-------------------\r light.begin(OPT3001_ADDRESS);\r//-------------------\r // config register\r //-------------------\r newConfig.RangeNumber = B1100; // automatic full scale\r newConfig.ConvertionTime = B1; // convertion time = 800ms\r newConfig.ModeOfConversionOperation = B11; // continous conversion\r newConfig.Latch = B0; // hysteresis-style\r errorConfig = light.writeConfig(newConfig);\rif(errorConfig != NO_ERROR){\rerrorConfig = light.writeConfig(newConfig); //retry\r }\r}\r//=====================================================================\r// 割り込み処理\r// //=====================================================================\r//=====================================================================\r// interrupt\r//=====================================================================\r//----------------------------------------------\r// Timer2 INT\r// タイマー割り込み関数\r//----------------------------------------------\rvoid intTimer2(){\rbInterval = 1;\r}\r//---------------------------------------------\r// Watchdog Timer INT\r// WDT割り込み関数\r//---------------------------------------------\rISR(WDT_vect){\rwdt_disable();\rcountWDT += 1;\rif (countWDT \u0026gt;= wakeupWDT){\rcountWDT = 0;\r}\r}\r//----------------------------------------------\r// INT0\r// INT0割り込み関数\r//----------------------------------------------\rvoid intExtInt0(){\rif (bEventSleep == false)\r{\rbEventSleep = true;\r}\relse\r{\rbEventSleep = false;\r}\r}\r//----------------------------------------------\r// INT1\r// INT1割り込み関数\r//----------------------------------------------\rvoid intExtInt1(){\r//bWakeupINT1 = true;\r}\r//====================================================================\r// functions\r//====================================================================\r//--------------------------------------------------------------------\r// counter /event\r//--------------------------------------------------------------------\r//-----------------------------------------\r// main loop\r// メインループのループ回数をカウントし\r// 1秒間隔でセンサーデータの取得をONにする\r// 4秒間隔でスリープ確認をONにする\r//-----------------------------------------\rvoid loopCounter(){\riLoop1s += 1;\r//--------------------\r // 1s period\r //--------------------\r if (iLoop1s \u0026gt;= 8){ // 125ms x 8 = 1s\r\riLoop1s = 0;\reventSensorRead = true;\reventWriteLCD = true;\r}\r}\r//--------------------------------------------------------------------\r// sensor\r//--------------------------------------------------------------------\r//-----------------------------------------\r// main loop\r// センサーデータ取得がONのとき、各センサーからデータを取得\r// コンソール出力がONのときシリアルに測定値と計算結果を出力する\r//-----------------------------------------\rvoid loopSensor(){\rdouble temp_mv;\r//---------------------------\r // 1s period\r //---------------------------\r if (eventSensorRead == true){\r//-------------------------\r // initialize parameter\r //-------------------------\r eventSensorRead = false;\r//-------------------------\r // LIS2DH\r // 3軸センサーのデータ取得\r //-------------------------\r accel.read();\rdataX_g = accel.x_g; //X軸\r dataY_g = accel.y_g; //Y軸\r dataZ_g = accel.z_g; //Z軸\r\rif(dataZ_g \u0026gt;= 1.0){\rdataZ_g = 1.00;\r} else if (dataZ_g \u0026lt;= -1.0){\rdataZ_g = -1.00;\r}\rdataTilt = acos(dataZ_g)/PI*180;\r//-------------------------\r // HTS221\r // 温湿度センサーデータ取得\r //-------------------------\r dataTemp = (float)smeHumidity.readTemperature(); //温度\r dataHumid = (float)smeHumidity.readHumidity(); //湿度\r\r//-------------------------\r // 温度と湿度の2点補正\r //-------------------------\r dataTemp=TM0+(TM1-TM0)*(dataTemp-TL0)/(TL1-TL0); // 温度補正\r dataHumid=HM0+(HM1-HM0)*(dataHumid-HL0)/(HL1-HL0); // 湿度補正\r\r//-------------------------\r // OPT3001\r // 照度センサーデータ取得\r //-------------------------\r OPT3001 result = light.readResult();\rif(result.error == NO_ERROR){\rdataLight = result.lux;\r}\r//-------------------------\r // ADC081C027（ADC)\r // 電池リーフ電池電圧取得\r //-------------------------\r uint8_t adcVal1 = 0;\ruint8_t adcVal2 = 0;\rWire.beginTransmission(BATT_ADC_ADDR);\rWire.write(0x00);\rWire.endTransmission(false);\rWire.requestFrom(BATT_ADC_ADDR,2);\radcVal1 = Wire.read();\radcVal2 = Wire.read();\rif (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { //測定値がFFならバッテリリーフはつながっていない\r adcVal1 = adcVal2 = 0;\r}\r//電圧計算　ADC　* （(リファレンス電圧(3.3V)/ ADCの分解能(256)) * 分圧比（２倍））\r //dataBatt = (((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * (3.3 / 256)) * 2 ;\r temp_mv = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256;\rdataBatt = (float)(temp_mv / 1000);\r//-------------------------\r // シリアルモニタ表示\r //-------------------------\r#ifdef DEBUG\r Serial.println(\u0026#34;\u0026#34;);\r#if 0Serial.println(\u0026#34;--- sensor data ---\u0026#34;); Serial.println(\u0026#34; Tmp[degC] = \u0026#34; + String(dataTemp));\rSerial.println(\u0026#34; Hum[%] = \u0026#34; + String(dataHumid));\rSerial.println(\u0026#34; Lum[lx] = \u0026#34; + String(dataLight));\rSerial.println(\u0026#34; Ang[arc deg] = \u0026#34; + String(dataTilt));\rSerial.println(\u0026#34; Bat[V] = \u0026#34; + String(dataBatt));\r//Serial.println(\u0026#34;\u0026#34;);\r//Serial.println(\u0026#34; Accel X,Y,Z\u0026#34; + String(dataX_g) + \u0026#34; \u0026#34; + String(dataY_g) + \u0026#34; \u0026#34; + String(dataZ_g));\r#else\r Serial.println(\u0026#34;T =\u0026#34; + String(dataTemp) + \u0026#34; H =\u0026#34; + String(dataHumid) + \u0026#34; L=\u0026#34; + String(dataLight) + \u0026#34; A=\u0026#34; + String(dataTilt) + \u0026#34; V=\u0026#34; + String(dataBatt));\r#endif #endif\r\r//bWakeupINT1 = false;\r }\r}\r//debug ///\rvoid getBattVal()\r{\ruint8_t adcVal1 = 0;\ruint8_t adcVal2 = 0;\rWire.beginTransmission(BATT_ADC_ADDR);\rWire.write(0x00);\rWire.endTransmission(false);\rWire.requestFrom(BATT_ADC_ADDR,2);\radcVal1 = Wire.read();\radcVal2 = Wire.read();\rif (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { //測定値がFFならバッテリリーフはつながっていない\r adcVal1 = adcVal2 = 0;\r}\r//電圧計算　ADC　* （(リファレンス電圧(3.3V)/ ADCの分解能(256)) * 分圧比（２倍））\r //dataBatt = (((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * (3.3 / 256)) * 2 ;\r double temp_mv = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256;\rfloat batval = (float)(temp_mv / 1000);\rSerial.println(\u0026#34; V=\u0026#34; + String(batval)); }\rvoid loopLCD( void ){\r/* */\rif( eventWriteLCD == true ){\reventWriteLCD = false;\rveiwSencerData();\r}\r}\r//---------------------------------------\r// Veiw sensor data\r// センサーデータを文字列に変換してLCDに表示する\r//---------------------------------------\rvoid veiwSencerData(){\rfloat value;\rchar temp[7], humid[7], light[7], tilt[7],battVolt[7];\rchar code[4];\rchar sendData[40];\r//-----------------------------------\r //センサーデータを文字列に変換\r //dtostrf(変換する数字,変換される文字数,小数点以下の桁数,変換した文字の格納先);\r //変換される文字数を-にすると変換される文字は左詰め、+なら右詰めとなる\r //-----------------------------------\r\r//-------------------------\r // Temperature (4Byte)\r //-------------------------\r value = dataTemp;\rif(value \u0026gt;= 100){\rvalue = 99.9;\r}\relse if(value \u0026lt;= -10){ value = -9.9;\r} dtostrf(value,4,1,temp);\r//-------------------------\r // Humidity (4Byte)\r //-------------------------\r value = dataHumid; dtostrf(value,4,1,humid);\r//-------------------------\r // Ambient Light (5Byte)\r //-------------------------\r value = dataLight;\rif(value \u0026gt;= 100000){\rvalue = 99999;\r} dtostrf(value,5,0,light);\r//-------------------------\r // Tilt (4Byte)\r //-------------------------\r value = dataTilt;\rif(value \u0026lt; 3){\rvalue = 0;\r}\rdtostrf(value,4,0,tilt);\r//-------------------------\r // Battery Voltage (4Byte)\r //-------------------------\r value = dataBatt;\rif (value \u0026gt;= 10){\rvalue = 9.99;\r}\rdtostrf(value, 4, 2, battVolt);\rtrim(temp);\rtrim(humid);\rtrim(light); trim(tilt);\rtrim(battVolt);\rlcd.clear();\rswitch (lcd_view_sts)\r{\rcase 0:\r// Tmp XX.X [degC]  lcd.print(\u0026#34;Temp\u0026#34;);\rlcd.setCursor(0, 1);\rlcd.print( String(temp) +\u0026#34; C\u0026#34;); break;\rcase 1:\r// Hum xx.x [%]\r lcd.print(\u0026#34;Humidity\u0026#34;);\rlcd.setCursor(0, 1);\rlcd.print( String(humid) +\u0026#34; %\u0026#34;); break;\rcase 2:\r// Lum XXXXX [lx]\r lcd.print(\u0026#34;Luminous\u0026#34;);\rlcd.setCursor(0, 1);\rlcd.print( String(light) +\u0026#34; lx\u0026#34;); break;\rcase 3:\r// Ang XXXX [arc deg]\r lcd.print(\u0026#34;Angle\u0026#34;);\rlcd.setCursor(0, 1);\rlcd.print( String(tilt) +\u0026#34; deg\u0026#34;);\rbreak;\rcase 4:\r// Bat X.XX [V]\r lcd.print(\u0026#34;Battery\u0026#34;);\rlcd.setCursor(0, 1);\rlcd.print( String(battVolt) +\u0026#34; V\u0026#34;);\rbreak;\rdefault:\rbreak;\r}\rif (lcd_view_sts \u0026lt; 4){\rlcd_view_sts++;\r}\relse{\rlcd_view_sts = 0;\r}\r//debug//\r#ifdef DEBUG  //getBattVal();\r#endif\r//debug//\r}\r//---------------------------------------\r// trim // 文字列配列からSPを削除する\r//---------------------------------------\rvoid trim(char * data)\r{\rint i = 0, j = 0;\rwhile (*(data + i) != \u0026#39;\\0\u0026#39;){\rif (*(data + i) != \u0026#39; \u0026#39;){\r*(data + j) = *(data + i);\rj++;\r}\ri++;\r}\r*(data + j) = \u0026#39;\\0\u0026#39;;\r}\r//--------------------------------------------------------------------\r// sleep\r//--------------------------------------------------------------------\r//-----------------------------------------\r// main loop\r// スリープ移行要求があった場合、センサーリーフをSLEEPさせて\r// WDTをセットしマイコンリーフをスリープさせる\r//-----------------------------------------\rvoid loopSleep(){\rif (bEventSleep == true){\r//bEventSleep = false;\r\r#ifdef DEBUG\r Serial.print(\u0026#34; \u0026gt;\u0026gt;\u0026gt; Go to sleep : \u0026#34;);\rSerial.flush();\r#endif\r //-----------------------\r // sleep\r //-----------------------\r sleepLCD();\rsleepSensor();\r//wdt_start();\r sleep();\r//-----------------------\r // wakeup\r //-----------------------\r wakeupSensor();\rwakeupLCD();\r#ifdef DEBUG\r Serial.println(\u0026#34; \u0026lt;\u0026lt;\u0026lt; Wake up \u0026lt;\u0026lt;\u0026lt;\u0026#34;);\r#endif  }\r}\r//-----------------------------------------\r// SLEEP\r//-----------------------------------------\rvoid sleep(){ ADCSRA \u0026amp;= ~(1 \u0026lt;\u0026lt; ADEN); //ADC停止\r set_sleep_mode(SLEEP_MODE_PWR_DOWN); //SET SLEEP MODE\r sleep_enable(); // SLEEP ENABLE\r\r// BOD停止\r MCUCR |= (1 \u0026lt;\u0026lt; BODSE) | (1 \u0026lt;\u0026lt; BODS); // MCUCRのBODSとBODSEに1をセット\r MCUCR = (MCUCR \u0026amp; ~(1 \u0026lt;\u0026lt; BODSE)) | (1 \u0026lt;\u0026lt; BODS); // すぐに（4クロック以内）BODSSEを0, BODSを1に設定\r asm(\u0026#34;sleep\u0026#34;); // 3クロック以内にスリープ  sleep_disable(); // SLEEP DISABLE\r}\r//-----------------------------------------\r// WDT\r//-----------------------------------------\rvoid wdt_start(){\r// watchdog timer reset\r wdt_reset();\r//disable interruput\r cli();\r//clear WatchDog system Reset Flag(WDRF)\r MCUSR \u0026amp;= ~(1 \u0026lt;\u0026lt; WDRF);\r// WDT変更許可\r // WDCEとWDE同時セットで変更許可\r WDTCSR |= 1 \u0026lt;\u0026lt; WDCE | 1 \u0026lt;\u0026lt; WDE;\r//WDT設定\r // WDE=0,WDIE=1 :WDT overflowで割り込み\r // WDP3=1,WDP2=0,WDP1=0,WDP0=1: 8s\r WDTCSR = 1 \u0026lt;\u0026lt; WDIE | 0 \u0026lt;\u0026lt; WDE | 1 \u0026lt;\u0026lt; WDP3 | 0 \u0026lt;\u0026lt; WDP2 | 0 \u0026lt;\u0026lt; WDP1 | 1 \u0026lt;\u0026lt; WDP0;\r//enable interruput\r sei();\r}\r//-----------------------------------------\r// sleep sensor\r// センサーリーフをスリープさせる\r//-----------------------------------------\rvoid sleepSensor(){\r//-----------------------\r // OPT3001 sleep\r //-----------------------\r OPT3001_Config newConfig;\rOPT3001_ErrorCode errorConfig;\rnewConfig.ModeOfConversionOperation = B00;\rerrorConfig = light.writeConfig(newConfig);\rif(errorConfig != NO_ERROR){\rerrorConfig = light.writeConfig(newConfig);\r}\r//-----------------------\r // LIS2DH sleep\r //-----------------------\r accel.setDataRate(LIS3DH_DATARATE_POWERDOWN);\r//-----------------------\r // HTS221 sleep\r //-----------------------\r smeHumidity.deactivate();\r}\r//-----------------------------------------\r// wakeup sensor\r// センサーリーフをスリープから復帰させる\r//-----------------------------------------\rvoid wakeupSensor(){\r//-----------------------\r // OPT3001 wakeup\r //-----------------------\r OPT3001_Config newConfig;\rOPT3001_ErrorCode errorConfig;\rnewConfig.RangeNumber = B1100; //automatic full scale\r newConfig.ConvertionTime = B1; //convertion time = 800ms\r newConfig.ModeOfConversionOperation = B11; //continous conversion\r newConfig.Latch = B1; //latch window style\r\rerrorConfig = light.writeConfig(newConfig);\rif(errorConfig != NO_ERROR){\rerrorConfig = light.writeConfig(newConfig); //retry\r }\r//-----------------------\r // LIS2DH wakeup\r //-----------------------\r accel.setDataRate(LIS3DH_DATARATE_1_HZ);\r//-----------------------\r // HTS221 wakeup\r //-----------------------\r smeHumidity.activate(); }\r//-----------------------------------------\r// sleep LCD\r// LCDリーフをスリープさせる\r//-----------------------------------------\rvoid sleepLCD()\r{\rlcd.noDisplay();\r}\r//-----------------------------------------\r// sleep LCD\r// LCDリーフをスリープさせる\r//-----------------------------------------\rvoid wakeupLCD(){\rlcd.display();\r}\r//-----------------------------------------\r// poweroff LCD\r// LCDの電源OFF\r//-----------------------------------------\rvoid powerOffLCD(){\r// LCD 電源 OFF\r i2c_write_byte(I2C_EXPANDER_ADDR_LCD, 0x01, 0x00); }\r//-----------------------------------------\r// wakeup LCD\r// LCDリーフをスリープさせる\r//-----------------------------------------\rvoid powerOnLCD(){\r// LCD 電源　ＯＮ\r i2c_write_byte(I2C_EXPANDER_ADDR_LCD, 0x01, 0x01);\r// LCDの電源が一度落ちたので、ＬＣＤを再設定\r lcd.begin(8, 2);\rlcd.setContrast(30);\rlcd.clear(); }\r//====================================================================\r// setup\r//====================================================================\rvoid setup() {\r//WDT disable\r wdt_disable();\rdelay(10);\rSerial.begin(115200); // UART 9600bps\r Wire.begin(); // I2C 100KHz\r\ri2c_write_byte(I2C_EXPANDER_ADDR_LCD, 0x03, 0xFE);\rpowerOnLCD();\r#ifdef DEBUG\rSerial.println(\u0026#34;=========================================\u0026#34;);\rSerial.println(\u0026#34;setup start\u0026#34;);\r#endif\rsetupPort();\rdelay(10);\rnoInterrupts();\rsetupExtInt();\rsetupTC2Int();\rinterrupts();\rsetupSensor();\rMsTimer2::start(); // Timer2 inverval start\r\r#ifdef DEBUG\r Serial.println(\u0026#34;\u0026#34;);\rSerial.println(\u0026#34;=========================================\u0026#34;);\rSerial.println(\u0026#34;loop start\u0026#34;);\rSerial.println(\u0026#34;\u0026#34;);\r#endif\r\r}\r//====================================================================\r// loop\r//====================================================================\rvoid loop() {\r//-----------------------------------------------------\r // Timer2 interval　125ms で1回ループ\r //-----------------------------------------------------\r if (bInterval == true){\rbInterval = false; //--------------------------------------------  //--------------------------------------------\r // loop counter\r //--------------------------------------------\r loopCounter();\r//--------------------------------------------\r // sensor read\r //--------------------------------------------\r loopSensor();\r//--------------------------------------------\r // LCD\r //--------------------------------------------\r loopLCD();\r//--------------------------------------------\r // sleep/resume\r //--------------------------------------------\r loopSleep();\r} }\r","excerpt":"概要 電源リーフには、電池電圧をモニタするためのADコンバータを実装。温度、湿度、照度、傾きだけでなく、電池電圧も測定し、LCDに表示させます。 温度（または、湿度）の補正の仕方 表示させたい温度（ま …","ref":"/docs/examples/lcd/","title":"LCD"},{"body":"  \n特徴 Seeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。Grove対応ピンの仕様は以下の通り。 低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\nブロック図 \nサンプルプロジェクト  LED点滅  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 Seeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに …","ref":"/docs/leaf/extension/ax06a/","title":"AX06A Grove\u00265V"},{"body":"概要 時刻がパソコンのシリアルモニタに表示されます。 必要なハードウェアの準備    Type Name Q\u0026rsquo;ty     AZ02A RTC\u0026amp;microSD 1   AP01A AVR MCU 1   AV01A CR2032 1   AZ01A USB 1   AZ62A Connector Cover 1    CR2032 3V Lithium coin cell battery 1    Screw M2×25mm 2    リーフの組立 スケッチの書き込み  書き込みには、RTC＆MicroSDライブラリが必要です。予め、ライブラリをインクルードしておいてください。詳しくは、[こちら]。 Arduino IDEで、「ファイル」→「スケッチ例」→「RTClib」→「pcf8523」で、マイコンボードに書き込んでください。 ここまででRTC自体は作動しますが、時刻の設定がされていません。  ソースコード  現在の時刻の自動設定と、低消費電力設定のため、以下のように青字の部分のスケッチを変更してください。  void setup () {\rwhile (!Serial) {\rdelay(1); // for Leonardo/Micro/Zero\r　}\rSerial.begin(57600);　if (! rtc.begin()) {\rSerial.println(“Couldn’t find RTC”);\rwhile (1);\r}\rif (! rtc.initialized()) {\rSerial.println(“RTC is NOT running!”);\r// following line sets the RTC to the date \u0026amp; time this sketch was compiled\r　rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));　//自動時刻合わせ\r　// This line sets the RTC with an explicit date \u0026amp; time, for example to set\r　// January 21, 2014 at 3am you would call:\r　//rtc.adjust(DateTime(2019, 8, 9, 13, 0, 0));　 }\rrtc.writeSqwPinMode(PCF8523_OFF);　//低消費電力化\r}\r時刻の設定 RTCの停止と起動を行って、時刻を設定してください。\n USBケーブルを抜き、CR2032リーフのPower switchをOFFにして、RTCを停止します。 USBケーブルを入れ、RTCを起動させます。 CR2032リーフのPower switchをONにします。  シリアルモニタの表示 シリアルモニターを起動させて、時刻が表示されていることを確認してください。\n","excerpt":"概要 時刻がパソコンのシリアルモニタに表示されます。 必要なハードウェアの準備    Type Name Q\u0026rsquo;ty     AZ02A RTC\u0026amp;microSD 1   AP01A …","ref":"/docs/examples/rtc/","title":"リアルタイムクロック"},{"body":"  \n特徴 全てのリーフI/F端子を接続したリーフを反転させて接続するためのリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 全てのリーフI/F端子を接続したリーフを反転させて接続するためのリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","ref":"/docs/leaf/extension/ax07a/","title":"AX07A Back to back"},{"body":"概要 microSD カードの情報が、パソコンのシリアルモニタに表示されます。 必要なハードウェアの準備    Type Name Q\u0026rsquo;ty     AP01A AVR MCU 1   AV01A CR2032 1   AZ01A USB 1   AZ02A RTC\u0026amp;microSD 1   AZ62A Connector Cover 1    CR2032 3V Lithium coin cell battery 1    microSD card 1    Screw M2×25mm 2    リーフの組立 スケッチの書き込み  Arduino IDEで、「ファイル」→「スケッチ例」→「SD」→「CardInfo」で、マイコンボードに書き込んでください。  ソースコード  安定してデータを取得するため、HALF→QUARTERにスピードを遅くしてください。  if (!card.init(SPI_HALF_SPEED, chipSelect)) {　→if (!card.init(SPI_QUARTER_SPEED, chipSelect)) {\r chipselectのデジタルピンを４→10に変更してください。  const int chipSelect = 4;\r→const int chipSelect = 10;　","excerpt":"概要 microSD カードの情報が、パソコンのシリアルモニタに表示されます。 必要なハードウェアの準備    Type Name Q\u0026rsquo;ty     AP01A AVR MCU 1 …","ref":"/docs/examples/microsd/","title":"Micro SD"},{"body":"  \n特徴 リーフI/Fの29ピン全てをピンヘッダに接続したリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 リーフI/Fの29ピン全てをピンヘッダに接続したリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","ref":"/docs/leaf/extension/ax08a/","title":"AX08A 29pin header"},{"body":"\n特徴 Leafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\nドキュメント  仕様書  ","excerpt":"\n特徴 Leafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材 …","ref":"/docs/leaf/others/az61a/","title":"AZ61A Connector"},{"body":"  \n特徴 AVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\n性能    項目 内容     USB USB 2.0 Full Speed    Data transfer rates 300 baud to 3 Mbaud   電源    出力電圧 3.3V±2%   制御方式　 PWM/PFM 自動切替制御   最大出力電流 500mA   Protection circuit 過電流制限/サーマルシャットダウン/短絡保護    ブロック図 \nピン配置 \nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"  \n特徴 AVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から …","ref":"/docs/leaf/others/az01a/","title":"AZ01A USB"},{"body":"その他 \rUSB\rAZ01A\rAVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\nBasic Kit\r\r\rRTC\u0026amp;microSD\rAZ02A\rNXPのReal-Time Clock PCF8523TKおよびMicro SDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。micro SDカードはSPIでアクセスします。\nESP32 Wi-Fi Kit\r \rConnector\rAZ61A\rLeafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\n\r \rConnector Cover\rAZ62A\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \rNut Plate\rAZ63A\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意\n\r \rUppercase\rAZ64A\rケース（上）\nBasic Kit\r \rLowercase\rAZ65A\rケース（下）\nBasic Kit\r ","excerpt":"その他 \rUSB\rAZ01A\rAVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USB …","ref":"/docs/leaf/others/","title":"その他"},{"body":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。超音波センサで測定した距離をLCDに表示させます。超音波センサは、通常、デジタルピンに入力するが、LCDのスイッチ1とGrove\u0026amp;5VのDin1が同じピンを使用しているため、UARTピンに接続しUARTピンをデジタルピンとして使用します。\n\r必要なハードウェアの準備    Type Name Q\u0026rsquo;ty     AI04A LCD 1   AP01A AVR MCU 1   AV01A CR2032 1   AX06A Grove\u0026amp;5V 1   AZ01A USB 1   AZ62A Connector Cover 1    Grove – Ultrasonic Distance Sensor 1    CR2032 3V Lithium coin cell battery 1    Screw M2×25mm 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード  書き込みには、LCDライブラリ、超音波制御 ライブラリ（ Ultrasonic.h ）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、[こちら]。 Arduino IDEで下記のプログラムを書きましょう。  //=====================================================================\r// Leafony Platform sample sketch\r// Platform : Grove + Ultrasonic\r// Processor : ATmega328P (3.3V /8MHz)\r// Application : Ultrasonic Ranger demo\r//\r// Leaf configuration\r// (1) AI04 LCD\r// (2) AP01 AVR MCU\r// (3) AX01 Grove\u0026amp;5V + Grove - Ultrasonic Ranger (UART pinに接続)\r// ※ Ultrasonic RangerはGrove\u0026amp;5VのUARTに接続する\r// (4) AZ01 USB\r//\r//\t(c) 2019 Trillion-Node Study Group\r//\tReleased under the MIT license\r//\thttps://opensource.org/licenses/MIT\r//\r// Rev.00 2019/08/01 First release\r//=====================================================================\r//Grove - Ultrasonic Rangerを使用したデモ\r//LCDに超音波センサーから取得した対象物からの距離を表示\r//=====================================================================\r//use libraries\r//ST7032 - Arduino LiquidCrystal compatible library\r//https://github.com/tomozh/arduino_ST7032\r//Grove_Ultrasonic_Ranger\r//https://github.com/Seeed-Studio/Grove_Ultrasonic_Ranger/\r//=====================================================================\r\r#include \u0026lt;Wire.h\u0026gt;\r#include \u0026lt;ST7032.h\u0026gt;\r\r// LCD\rST7032 lcd;\rchar strMessage[8];\r#include \u0026#34;Ultrasonic.h\u0026#34;\rUltrasonic ultrasonic(A1);\rvoid setup() {\rSerial.begin(115200);\r//LCD Initialize\r lcd.begin(8, 2);\rlcd.setContrast(30);\rlcd.clear();\rlcd.print(\u0026#34; Hello!\u0026#34;);\rlcd.setCursor(0, 1);\rdelay(1000);\rlcd.begin(8, 2);\rlcd.setContrast(30);\rlcd.clear();\rlcd.print(\u0026#34;12345678\u0026#34;);\rlcd.setCursor(0, 1);\rlcd.print(\u0026#34;87654321\u0026#34;);\rdelay(500);\rlcd.clear();\rlcd.blink();\rint i;\rfor (i=0 ; i\u0026lt;8 ;i++)\r{\rlcd.setCursor(i, 0);\rdelay(100);\r}\rfor (i=0 ; i\u0026lt;8 ;i++)\r{\rlcd.setCursor(i, 1);\rdelay(100);\r}\rlcd.noBlink();\r}\rvoid loop() {\rlong RangeInCentimeters;\rlcd.clear();\rlcd.print(\u0026#34;Distance\u0026#34;);\rRangeInCentimeters = ultrasonic.MeasureInCentimeters();\rsprintf(strMessage,\u0026#34;%5d cm\u0026#34;,RangeInCentimeters); lcd.setCursor(0, 1);\rlcd.print(strMessage);\rdelay(250);\r}\r","excerpt":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。超音波センサで測定した距離をLCDに表示させます。超音波センサは、通常、デジタルピンに入力するが、LCDのスイッチ1 …","ref":"/docs/examples/distance_sensor/","title":"超音波センサで距離測定"},{"body":"\n特徴 Connector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\nハードウェア  外形図\n  ","excerpt":"\n特徴 Connector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\nハードウェア  外形図\n  ","ref":"/docs/leaf/others/az62a/","title":"AZ62A Connector Cover"},{"body":"  \n特徴 NXPのReal-Time Clock PCF8523TKおよびMicro SDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。micro SDカードはSPIでアクセスします。\n性能　    項目 内容     RTC    Type Real-Time Clock (RTC) and calendar   Interrupt Alarm and timer   使用水晶振動子 FC-12M 32.768000kHz 7.0 +20.0-20.0   Interfaces I2C    ブロック図 \nピン配置 \nサンプルプロジェクト  時刻をパソコンに表示 ※リンク先要変更 microSD カードの情報をパソコンに表示 ※リンク先要変更 カメラを使って撮影した画像を microSD カードに保存 ※リンク先要変更  ライブラリ ・関数の概要は、仕様書に記載\n・RTCの制御　include file: RTClib.h\n以下は、Standard Libraries。\nIDEをインストールすると、C:\\Program Files (x86)\\Arduino\\libraries に保存されている。\n・SDカードの制御　include:SD.h\ninclude:spi.h\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"特徴 NXPのReal-Time Clock PCF8523TKおよびMicro SDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能で …","ref":"/docs/leaf/others/az02a/","title":"AZ02A RTC\u0026MicroSD"},{"body":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。定点観測用カメラ。1分に一回カメラで撮影した画像をmicroSDカードに保存してみよう。 \r必要なハードウェアの準備    Type Name Q\u0026rsquo;ty     AP01A AVR MCU 1   AV01A CR2032 1   AX06A Grove\u0026amp;5V 1   AZ01A USB 1   AZ02A RTC\u0026amp;MicroSD 1   AZ62A Connector Cover 1    CR2032 3V Lithium coin cell battery 1    Grove-Serial Camera Kit 1    microSD card  1    Screw M2×25mm 2    リーフの組み立て ソースコード  書き込みには、4-Sensors、AVR MCUライブラリ（タイマ割り込み）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、[こちら]。 Arduino IDEで下記のプログラムを書きましょう。  //=====================================================================\r// Leafony Platform sample sketch\r// Platform : Grove + Camera\r// Processor : ATmega328P (3.3V /8MHz)\r// Application : Camera\r//\r// Leaf configuration\r// (1) AP01 AVR MCU\r// (2) AX01 Grove\u0026amp;5V + Grove Serial Camera Kit\r// (3) AZ01 USB\r// (4) AZ02 RTC＆MicroSD\r//\r//\t(c) 2019 Trillion-Node Study Group\r//\tReleased under the MIT license\r//\thttps://opensource.org/licenses/MIT\r//\r// Rev.00 2019/08/01 First release\r//=====================================================================\r//use libraries\r//=====================================================================\r\r//=====================================================================\r// difinition\r//=====================================================================\r#include \u0026lt;MsTimer2.h\u0026gt;\r#include \u0026lt;SPI.h\u0026gt;\r#include \u0026lt;SD.h\u0026gt;\r#include \u0026lt;SoftwareSerial.h\u0026gt;\r#include \u0026lt;avr/wdt.h\u0026gt;\r#include \u0026lt;avr/sleep.h\u0026gt;\r#include \u0026lt;avr/power.h\u0026gt;\r//=====================================================================\r\r#define DEBUG \r//=====================================================================\r// SPI CLOCK // SDカードのSPI I/Fのクロック速度4Mでは動作しないので4M以下に設定すること\r//=====================================================================\r#define SD_CLCK 2500000 \r//=====================================================================\r// 撮影間隔（秒）\r// //=====================================================================\r#define SNAP_WAIT 60\r\r//=====================================================================\r// IOピンの名前定義\r// 接続するリーフに合わせて定義する\r//=====================================================================\r// --------------------------------------------\r// PD port\r// digital 0: PD0 = PCRX (HW UART)\r// digital 1: PD1 = PCTX (HW UART)\r// digital 2: PD2 = INT0#\r// digital 3: PD3 = INT1#\r// digital 4: PD4 = RSV\r// digital 5: PD5 = RSV\r// digital 6: PD6 = RSV\r// digital 7: PD7 = RSV\r// --------------------------------------------\r#define PCTX 0\r#define PCRX 1\r#define INT0 2\r#define INT1 3\r#define RSV_D4 4 #define RSV_D5 5\r#define SD_EN 6\r#define RSV_D7 7\r\r// --------------------------------------------\r// PB port\r// digital 8: PB0 = UART2_RX (software UART) /* not use */\r// digital 9: PB1 = UART2_TX (software UART) /* not use */\r// digital 10:PB2 = CS#\r// digital 11:PB3 = MOSI\r// digital 12:PB4 = MISO\r// digital 13:PB5 = SCK (AVR LED) // PB6 = XTAL1\r// PB7 = XTAL2\r//---------------------------------------------\r#define UART2_RX 8\r#define UART2_TX 9\r#define SD_CS 10\r#define MOSI 11\r#define MISO 12\r#define LED_PIN 13\r\r// --------------------------------------------\r// PC port\r// digital 14/ Analog0: PC0 = RSV\r// digital 15/ Analog1: PC1 = CAMERA TX (software UART)\r// digital 16/ Analog2: PC2 = CAMERA RX (software UART)\r// digital 17/ Analog3: PC3 = RSV\r// digital 18/ SDA : PC4 = SDA (I2C)\r// digital 19/ SCL : PC5 = SCL (I2C)\r// RESET : PC6 = RESET#\r//-----------------------------------------------\r#define RSV_D14 14\r#define UART3_TX 15 #define UART3_RX 16 #define RSV_D17 17\r#define SDA 18\r#define SCL 19\r//=====================================================================\r\r//=====================================================================\r// camera\r//=====================================================================\r//Color Setting #define COLOR_2BIT_GRAY 0x01 #define COLOR_4BIT_GRAY 0x02 #define COLOR_8BIT_GRAY 0x03 #define COLOR_2BIT_COLOR 0x05 #define COLOR_4BIT_COLOR 0x06 #define COLOR_JPEG 0x07\r//Preview Resolution #define PRE_RES_80_60 0x01\r#define PRE_RES_160_120 0x03\r//JPEG Resolution #define JPEG_RES_80_60 0x01\r#define JPEG_RES_QQVGA 0x03\r#define JPEG_RES_QVGA 0x05\r#define JPEG_RES_VGA 0x07\r//Get Setting\r#define GET_SNAPCHOT 0x01\r#define GET_PRE_PIC 0x02\r#define GET_PRE_JPEG 0x03\r//Snapshot Setting #define COMPRESSED 0x00\r#define UNCOMPRESSED 0x01\r//data length\r#define PIC_PKT_LEN 128\r\r//=====================================================================\r// SD\r//=====================================================================\rFile myFile;\rSoftwareSerial CameraSerial(UART3_RX, UART3_TX); //=====================================================================\r// 変数定義\r//=====================================================================\runsigned long picTotalLen = 0; // picture length\rint picNameNum = 0;\rchar fname[16];\r//---------------------------\r// interval Timer2 interrupt\r//---------------------------\rvolatile bool bInterval = false;\rvolatile int intcnt = 0;\r//=====================================================================\r// setup\r//=====================================================================\r//-----------------------------------------------\r// port\r//-----------------------------------------------\r//=====================================================================\r// IOピンの入出力設定\r// 接続するリーフに合わせて設定する\r//=====================================================================\rvoid setupPort(){\r//---------------------\r // PD port\r //---------------------\r // PD0 : digital 0 = RX\r // PD1 : digital 1 = TX\r\rpinMode(INT0, INPUT); // PD2 : digital 2 = INT0#\r pinMode(INT1, INPUT); // PD3 : digital 3 = INT1#\r\rpinMode(RSV_D4, OUTPUT); // PD4 : digital 4 = LED\r digitalWrite(RSV_D4, LOW);\rpinMode(RSV_D5, OUTPUT); // PD5 : digital 5 = not used\r digitalWrite(RSV_D5, LOW);\rpinMode(SD_EN, OUTPUT); // PD6 : digital 6 = BLE reset active-low\r digitalWrite(SD_EN, HIGH);\rpinMode(RSV_D7, OUTPUT); // PD7 : digital 7 = BLE sleep  digitalWrite(RSV_D7, HIGH);\r//---------------------\r // PB port\r //---------------------\r pinMode(UART2_RX, OUTPUT); // PB0 : digital 8 = software UART2\r digitalWrite(UART2_RX, LOW);\rpinMode(UART2_TX, OUTPUT); // PB1 : digital 9 = software UART2\r digitalWrite(UART2_TX, LOW);\r//---------------------\r // PC port\r //---------------------\r pinMode(RSV_D14, OUTPUT); // PC0 : digital 14 = not used\r digitalWrite(RSV_D14, LOW);\r// PC1 : digital 15 = Camera RX\r // PC2 : digital 16 = Camera TX\r\rpinMode(RSV_D17, OUTPUT); // PC3 : digital 17 = not used\r digitalWrite(RSV_D17, LOW);\r// PC4 : digital 18 = I2C SDA\r // PC5 : digital 19 = I2C SCL }\r//=====================================================================\r// 割り込み処理\r// //=====================================================================\r//-----------------------------------------------\r// timer2 interrupt (interval=1000ms, int=overflow)\r// メインループのタイマー割り込み設定\r//-----------------------------------------------\rvoid setupTC2Int(){\rMsTimer2::set(1000, intTimer2);}\r//----------------------------------------------\r// Timer2 INT\r// タイマー割り込み関数\r//----------------------------------------------\rvoid intTimer2(){\rintcnt++;\rif (intcnt \u0026gt; SNAP_WAIT)\r{\rintcnt = 0;\rbInterval = true;\r}\r}\r//====================================================================\r// camera\r//====================================================================\r//----------------------------------------------\r// clearReadBuf\r// カメラデータの受信バッファクリア\r//----------------------------------------------\rvoid clearReadBuf()\r{\rwhile (CameraSerial.available()) {\rCameraSerial.read(); }\r}\r//----------------------------------------------\r// sendCmd\r// カメラへのコマンド送信\r//----------------------------------------------\rvoid sendCmd(char cmd[], int cmd_len)\r{\rfor (char i = 0; i \u0026lt; cmd_len; i++) CameraSerial.write(cmd[i]); }\r//----------------------------------------------\r// readRespons\r// カメラからのデータ受信\r//----------------------------------------------\rint readRespons(char *dest, int len, unsigned int timeout)\r{\rint read_len = 0;\runsigned long t = millis();\rwhile (read_len \u0026lt; len)\r{\rwhile (CameraSerial.available()\u0026lt;1)\r{\rif ((millis() - t) \u0026gt; timeout)\r{\r//Serial.println(\u0026#34;timeout\u0026#34;);\r return read_len;\r}\r}\r*(dest+read_len) = CameraSerial.read();\r#ifdef DEBUG  //Serial.write(*(dest+read_len),); //debug #endif  read_len++;\r}\rreturn read_len;\r}\r//----------------------------------------------\r// initialize\r// カメラとの通信確立\r//----------------------------------------------\rvoid initialize()\r{ char cmd[] = {0xaa,0x0d,0x00,0x00,0x00,0x00} ; unsigned char resp[6];\rSerial.print(\u0026#34;initializing camera...\u0026#34;);\rwhile (1) {\rsendCmd(cmd,6);\rif (readRespons((char *)resp, 6,1000) != 6)\r{\rSerial.print(\u0026#34;.\u0026#34;);\rcontinue;\r}\rif (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x0d \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) {\rif (readRespons((char *)resp, 6, 500) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0d \u0026amp;\u0026amp; resp[2] == 0 \u0026amp;\u0026amp; resp[3] == 0 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; }\r} cmd[1] = 0x0e;\rcmd[2] = 0x0d;\rsendCmd(cmd, 6); Serial.println(\u0026#34; done.\\r\\n\u0026#34;);\r}\r//----------------------------------------------\r// preCapture\r// カメラの初期設定\r//----------------------------------------------\rvoid preCapture()\r{\rchar cmd[] = { 0xaa, 0x01, 0x00, COLOR_JPEG, PRE_RES_80_60, JPEG_RES_VGA }; unsigned char resp[6]; while (1)\r{\rclearReadBuf();\rsendCmd(cmd, 6);\rif (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x01 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; }\r}\r//----------------------------------------------\r// Capture\r// カメラの撮影実施\r//----------------------------------------------\rvoid Capture()\r{\rchar cmd[] = { 0xaa, 0x06 , 0x08, PIC_PKT_LEN \u0026amp; 0xff, (PIC_PKT_LEN\u0026gt;\u0026gt;8) \u0026amp; 0xff ,0}; unsigned char resp[6];\rwhile (1)\r{\rclearReadBuf();\rsendCmd(cmd, 6);\rif (readRespons((char *)resp, 6, 100) != 6) continue;\rif (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x06 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; }\rcmd[1] = 0x05;\rcmd[2] = 0;\rcmd[3] = 0;\rcmd[4] = 0;\rcmd[5] = 0; while (1)\r{\rclearReadBuf();\rsendCmd(cmd, 6);\rif (readRespons((char *)resp, 6, 100) != 6) continue;\rif (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x05 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break;\r}\rcmd[1] = 0x04;\rcmd[2] = GET_SNAPCHOT;\rwhile (1) {\rclearReadBuf();\rsendCmd(cmd, 6);\rif (readRespons((char *)resp, 6, 100) != 6) continue;\rif (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x04 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0)\r{\rif (readRespons((char *)resp, 6, 1000) != 6)\r{\rcontinue;\r}\rif (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0a \u0026amp;\u0026amp; resp[2] == 0x01)\r{\rpicTotalLen = (resp[3]) | (resp[4] \u0026lt;\u0026lt; 8) | (resp[5] \u0026lt;\u0026lt; 16); //Serial.print(\u0026#34;picTotalLen:\u0026#34;);\r //Serial.println(picTotalLen);\r break;\r}\r}\r}\r}\r//----------------------------------------------\r// GetData\r// カメラからデータを取得しSDに書き込む\r//----------------------------------------------\rvoid GetData()\r{\rchar cmd[] = { 0xaa, 0x0e , 0x00, 0x00, 0x00, 0x00 }; unsigned char pkt[PIC_PKT_LEN];\runsigned int pktCnt = (picTotalLen) / (PIC_PKT_LEN - 6); if ((picTotalLen % (PIC_PKT_LEN-6)) != 0) pktCnt += 1;\rset_filename();\rif (SD.exists(fname))\r{\rSD.remove(fname);\r}\rmyFile = SD.open(fname, FILE_WRITE); if(!myFile){\rSerial.println(\u0026#34;myFile open fail...\u0026#34;);\r}\relse{\rSerial.print(\u0026#34;Saving \u0026#34;);Serial.print(fname); Serial.print(\u0026#34;..... \u0026#34;);\rfor (unsigned int i = 0; i \u0026lt; pktCnt; i++)\r{\rcmd[4] = i \u0026amp; 0xff;\rcmd[5] = (i \u0026gt;\u0026gt; 8) \u0026amp; 0xff;\rint retry_cnt = 0;\rretry:\rdelay(10);\rclearReadBuf(); sendCmd(cmd, 6); uint16_t cnt = readRespons((char *)pkt, PIC_PKT_LEN, 200);\runsigned char sum = 0; for (int y = 0; y \u0026lt; cnt - 2; y++)\r{\rsum += pkt[y];\r}\rif (sum != pkt[cnt-2])\r{\rif (++retry_cnt \u0026lt; 100) goto retry;\relse break;\r}\rmyFile.write((const uint8_t *)\u0026amp;pkt[4], cnt-6); //if (cnt != PIC_PKT_LEN) break;\r }\rcmd[4] = 0xf0;\rcmd[5] = 0xf0; sendCmd(cmd, 6); }\rmyFile.close();\rSerial.println(\u0026#34;end!!\u0026#34;);\r}\r//----------------------------------------------\r// set_filename\r// SDに書き込みファイ名を作成IMGxxxx.JPG\r//----------------------------------------------\rvoid set_filename(){\rsprintf(fname, \u0026#34;IMG%04d.JPG\u0026#34;, picNameNum);\rpicNameNum ++;\rif( picNameNum \u0026gt; 100 ){\rpicNameNum = 0; // Overwrite\r }\r}\r//====================================================================\r// setup\r//====================================================================\rvoid setup() {\r//WDT disable\r wdt_disable();\r//内部の各モジュールの電源OFF\r //power_all_disable();\r //power_timer0_enable();\r //power_timer2_enable();\r //power_spi_enable();\r //power_usart0_enable();\r\rdelay(10);\rSerial.begin(115200);\rCameraSerial.begin(9600);\r#ifdef DEBUG\rSerial.println(\u0026#34;=========================================\u0026#34;);\rSerial.println(\u0026#34;setup start\u0026#34;);\r#endif\rsetupPort();\rdelay(10);\rsetupTC2Int();\rif (!SD.begin(SD_CLCK,SD_CS)) {\rSerial.print(\u0026#34;sd init failed\u0026#34;);\rreturn;\r}\rSerial.print(\u0026#34;sd init finish\\r\\n\u0026#34;);\rinitialize();\rdelay(1);\rpreCapture();\rdelay(1000);\rCapture();\rGetData();\rMsTimer2::start();\r}\r//====================================================================\r// loop\r//====================================================================\rvoid loop() {\rif (bInterval == true)\r{\rbInterval = false;\rCapture();\rGetData();\r}\r}\r","excerpt":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。定点観測用カメラ。1分に一回カメラで撮影した画像をmicroSDカードに保存してみよう。 \r必要なハー …","ref":"/docs/examples/camera/","title":"カメラの撮影"},{"body":"\n特徴 Nut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意\nハードウェア  外形図\n  ","excerpt":"\n特徴 Nut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意\nハードウェア  外形図\n  ","ref":"/docs/leaf/others/az63a/","title":"AZ63A Nut Plate"},{"body":"\n特徴 ケース（下）\n 外形図\n  ","excerpt":"\n特徴 ケース（下）\n 外形図\n  ","ref":"/docs/leaf/others/az65a/","title":"AZ64A Lowercase"},{"body":"\n特徴 ケース（上）\n 外形図\n  ","excerpt":"\n特徴 ケース（上）\n 外形図\n  ","ref":"/docs/leaf/others/az64a/","title":"AZ64A Uppercase"},{"body":"","excerpt":"","ref":"/index.json","title":""},{"body":"\r\r#td-cover-block-0 {\rbackground-image: url(/featured-background_hud28dbc58c7878fd3d577b2e424cb175f_644071_960x540_fill_q75_catmullrom_top.jpg); }\r@media only screen and (min-width: 1200px) {\r#td-cover-block-0 {\rbackground-image: url(/featured-background_hud28dbc58c7878fd3d577b2e424cb175f_644071_1920x1080_fill_q75_catmullrom_top.jpg); }\r}\r\rLeafony\rLearn More \r\rOnline Shop \r\rAn Open Source Hardware for the IoT World!\n\n\r\r\r\r\r\r\r\rLeafonyでIoTの世界を体験しましょう。\r\r\r\r\r\r\r積み重ねるだけの回路設計\rLeafony busを使えばリーフ積み重ねるだけで簡単にシステムの設計が可能です。 それぞれのリーフは2cm角と小型で、低消費電力性に優れた回路を使用おり、IoT/CPSシステムやアプリ、サービスの研究開発効率を断然アップさせます。\n\r\r\rオープンソースハードウェア\rLeafonyはオープンソースのハードウェアです。 個人・商用問わず無償で使える仕様・回路図・パターン図などのハードウェア情報がgithub上に公開されています。 ソフトウェアもすでに数万本あるフリーのArduinoソフトウェアが使えます。その他のソフトウェアでも使えます。\n続きを読む …\n\r\r\r最新情報\rLeafonyの最新情報はこちらから確認できます。\n続きを読む …\n\r\r\r\r","excerpt":"#td-cover-block-0 {\rbackground-image: …","ref":"/","title":"Leafony"},{"body":" はじめに クイックスタート 開発環境設定 サンプルデザイン リーフ技術資料 ライセンス  ","excerpt":" はじめに クイックスタート 開発環境設定 サンプルデザイン リーフ技術資料 ライセンス  ","ref":"/docs/","title":"Leafonyドキュメントページ"},{"body":"","excerpt":"","ref":"/search/","title":"検索結果"}]