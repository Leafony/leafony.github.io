[{"body":"Leafonyはプログラムを書き込んで初めて動作します。\nたとえば、クイックスタートでは、4つのセンサを読み取って、Bluetooth LEでデータを送信するプログラムが書き込まれています。\nこれからLeafonyを使い始める皆さんは、Leafonyにどんなことをしてもらいたいのかプログラムに記述して書き込むことで、思い通りの動作をさせることができます。\nNext\rLeafonyにプログラムを書き込むためにパソコンの設定をしていきましょう！\r\r用意するもの  Leafony Basic Kit PC (Windows または Mac OS X または Linux)  Arduino IDEのインストール Arduino IDEは、オープンソースの電子工作向けハードウェアプラットフォームであるArduinoの開発環境です。\nこの開発環境では、プログラムを記述したり、Arduino基板にプログラムを書き込んだり、基板から送られてくるデータを表示したりすることができます。\nLeafonyはArduino互換の基板なので、Arduino IDEを使って開発できます。\n早速Arduino IDEをダウンロードしてみましょう。\n Arduino ホームページから「SOFTWARE」 → 「DOWNLOADS」の順でページを開き、Arduino IDEのダウンロードページに飛ぶ 「Download the Arduino IDE」と書いてある場所で、使用しているOSにあったインストーラをダウンロード ダウンロードしたインストーラを実行して、画面の指示に従ってArduino IDEをインストール  ライブラリのインストール 一部のリーフを使用するには、追加のライブラリをインストールする必要があります。\n下記の手順を参考に、あらかじめ全てののライブラリをインストールしておきましょう。\n1. 使用するライブラリ Basic Kit、Extension Kitで使用するライブラリは以下の通りです。\n\r\rリーフ名\r必要なライブラリ名\r推奨バージョン\r説明\r\r\r\r\rBLE\rTBGLib\r\rBluetoothライブラリ\r\r\r4-Sensors\rHTS221.h\r\r温湿度センサライブラリ\r\r\rClosedCube_OPT3001.h\r\r照度センサライブラリ\r\r\rAdafruit_LSI3DH.h\r1.1.2\r加速度センサライブラリ\r\r\rAdafruit_Sensor.h\r\rユニファイドセンサドライバ\r\r\rLCD\rST7032.h\r\rLCDライブラリ\r\r\rAVR MCU\rMsTimer2.h\r\rタイマ割り込みライブラリ\r\r\rRTC\u0026MicroSD\rRTClib.h\r\rRTCライブラリ\r\r\r\r2. Githubからライブラリをダウンロード 上記表のリンクをクリックすると、ライブラリのGitHubリポジトリにアクセスします。 Clone or download → Download ZIPをクリックし、ライブラリをダウンロードしましょう。\n3. ライブラリのインクルード Arduinoを立ち上げ、スケッチ → ライブラリをインクルード → ZIP形式のライブラリをインストールの順に選択して、先程ダウンロードしたZIPファイルを読み込みましょう。\nLeafonyをPCと接続 図のようにLeafonyを組み立てて、USBでPCと接続しましょう。\nLeafonyにプログラムを書き込むためには最低限、AVR MCUリーフとUSBリーフが必要です。\nボード設定 Arduino IDEでLeafonyの開発を行うために、下記の手順でIDEの設定を行いましょう。\n ツール → ボードから、Arduino Pro or Pro Miniを選択、プロセッサでATmega328P (3.3V,8MHz)を選択  \nツール → シリアルポートから、Leafonyが接続されているシリアルポートを選択  Leafonyにプログラムを書き込む  Arduino IDEでファイル → スケッチ例 → 01.Basics → Blinkをクリックし、サンプルプロジェクトを開きましょう。 マイコンボードに書き込むボタンを押すをLeafonyにプログラムが書き込まれます。 ap01 AVR MCUに搭載されたLEDが点滅していることが確認できれば完了です。  次のステップ\rサンプルデザインにあるコードをLeafonyに書き込んでみましょう。\r\r困ったときは うまく動かないときはで解決方法を探してみましょう。\n","excerpt":"Leafonyはプログラムを書き込んで初めて動作します。\nたとえば、クイックスタートでは、4つのセンサを読み取って、Bluetooth LEでデータを送信するプログラムが書き込まれています。\nこれか …","ref":"/en/docs/environment/basic/","title":"Basic Kit 開発環境設定マニュアル"},{"body":"Leafony Basic Kitには、温湿度、照度、加速度センサを搭載した4-Sensorsリーフと、AVR MCUリーフ、Bluetooth LEリーフ、CR2032コイン電池リーフを組み合わせた、2cm立方のIoTデバイスが入っています。\nBluetoothを使ってスマートフォンやパソコンにセンサの情報を送信したり、Leafonyに搭載されたLEDをコントロールすることが簡単にできます。\nBasic Kitに含まれるLeafonyには、箱を開けたらすぐに使えるサンプルアプリが書き込まれています。\nNote\rWeb Bluetoothを使ったWebアプリで、Bluetooth接続もプラットフォームを問わずインストール不要で動作します。\r\r用意するもの  Leafony Basic Kit Windows1、 Mac2、 Linux3、 Chrome OSのPCまたは\nAndroid4、 iPhone5、 iPad5のスマートフォンまたはタブレット Google Chrome (バージョン70.0.3526.0以降)  デモ動画 \r使い方  Androidの場合 iPhoneまたはiPadの場合 WindowsまたはmacOSの場合 Linuxの場合 Chrome OSの場合 ピン配置 サンプルアプリのソースコード  Androidの場合  Basic Kitに電池を挿入し、電源スイッチをONにする  Google Chromeを開く サンプルWebアプリのページを開く WebアプリのConnectボタンを押して、Leaf_A_002」を選択し、ペア設定ボタンを押す 接続完了 サンプルアプリのソースコードはこちら  次のステップ\r開発環境設定を読んで、LeafonyにLED点滅スケッチを書き込んでみましょう。\r\riPhoneまたはiPadの場合  Basic Kitに電池を挿入し、電源スイッチをONにする  App StoreからWebBLE (有償)をダウンロード5 WebBLEを立ち上げ、下記のURLにアクセス\nhttps://docs.leafony.com/WebBluetooth_for_Leafony_app/ WebアプリのConnectボタンを押して、Leaf_A_002」を選択し、ペア設定ボタンを押す  注) 画面上に「Download CSV 」のボタンはありますが、iPhoneでは使用できません。\n次のステップ\r開発環境設定を読んで、LeafonyにLED点滅スケッチを書き込んでみましょう。\r\rWindowsまたはmacOSの場合  Basic Kitに電池を挿入し、電源スイッチをONにする  Google Chromeを開く サンプルWebアプリのページを開く WebアプリのConnectボタンを押して、Leaf_A_002」を選択し、ペア設定ボタンを押す 接続完了 サンプルアプリのソースコードはこちら  注) Chromeがバージョン79未満の場合、標準でWeb Bluetoothが有効になっていません。 Chromeのアドレスバーに次のURLを入力し、Experimental Web Platform featuresをEnableにしてください。\nchrome://flags/#enable-experimental-web-platform-features\n次のステップ\r開発環境設定を読んで、LeafonyにLED点滅スケッチを書き込んでみましょう。\r\rLinuxの場合   Linux上でWeb Bluetoothを有効にするために、下記の記事を参考に環境を設定してください。\nHow to get Chrome Web Bluetooth working on Linux\n  Basic Kitに電池を挿入し、電源スイッチをONにする\n  Google Chromeを開く サンプルWebアプリのページを開く WebアプリのConnectボタンを押して、Leaf_A_002」を選択し、ペア設定ボタンを押す 接続完了 サンプルアプリのソースコードはこちら  次のステップ\r開発環境設定を読んで、LeafonyにLED点滅スケッチを書き込んでみましょう。\r\rChrome OSの場合  Basic Kitに電池を挿入し、電源スイッチをONにする  Google Chromeを開く サンプルWebアプリのページを開く WebアプリのConnectボタンを押して、Leaf_A_002」を選択し、ペア設定ボタンを押す 接続完了 サンプルアプリのソースコードはこちら  次のステップ\r開発環境設定を読んで、LeafonyにLED点滅スケッチを書き込んでみましょう。\r\rピン配置 \nサンプルアプリのソースコード  Arduino スケッチ Web Bluetooth アプリ    Windows 10 version 1703以降 \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite以降 \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow以降 \u0026#x21a9;\u0026#xfe0e;\n iPhoneまたはiPadの場合は WebBLE(有料)が必要です。iPhone、iPad版のChromeではWeb Bluetoothが実装されていないためです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Leafony Basic Kitには、温湿度、照度、加速度センサを搭載した4-Sensorsリーフと、AVR MCUリーフ、Bluetooth LEリーフ、CR2032コイン電池リーフを組み合わせ …","ref":"/en/docs/getting-started/basic/","title":"Basic Kit スタートガイド"},{"body":"\n概要 コイン電池でも駆動可能な超小型・低消費電力システム向きの開発キットです。AVRマイコン(Atmega328P)、Bluetooth LE、温湿度センサ、照度センサ、加速度センサを搭載したリーフとマグネット付きプラスチックケースが含まれており、簡単にIoTセンサデバイスを作ることが出来ます。\n内容物    Type Item Q’ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AX02 29pin 1   AZ01 USB 1   AZ62 Connector Cover 1   AZ66 Basic Kit Case 1    Caution note 1    CR2032 coin cell battery 1    M2*15mm screw 2    Screw driver 1    リーフ一覧 \rAC02 BLE Sugar\r\rSilicon Labsの技的認証済みBluetooth LEモジュールBGM11S22F256GA-V2を搭載したリーフです。\n\r\r\rAI01 4-Sensors\r\r温湿度センサ、照度センサ、加速度センサを搭載したリーフです。省電力なセンサを搭載し長時間のセンシングに適しています。\n\r \rAP01 AVR MCU\r\rATmega328Pを使用したリーフです。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。\n\r \rAV01 CR2032\r\rCR2032コイン電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。2cm x 2cmのサイズで3.3Vの電源を供給可能です。\n\r \rAX02 29pin\r\rリーフI/Fの29ピン全てを2.54mmピッチのスルーホールに接続したリーフです。\n\r \rAZ01 USB\r\rAVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\n\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \rAZ66 Basic kit case\r\rBasic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\n\r \r変更履歴  Rev A1.0: 2019年8月初版  ","excerpt":"概要 コイン電池でも駆動可能な超小型・低消費電力システム向きの開発キットです。AVRマイコン(Atmega328P)、Bluetooth LE、温湿度センサ、照度センサ、加速度センサを搭載したリーフと …","ref":"/en/docs/products/basic/","title":"Basic Kit"},{"body":"Leafonyはプログラムを書き込んで初めて動作します。\nたとえば、クイックスタートでは、4つのセンサを読み取って、Bluetooth LEでデータを送信するプログラムが書き込まれています。\nこれからLeafonyを使い始める皆さんは、Leafonyにどんなことをしてもらいたいのかプログラムに記述して書き込むことで、思い通りの動作をさせることができます。\n次のステップ\rLeafonyにプログラムを書き込むために必要なソフトウェアをインストール\r\r用意するもの  Basic Kit PC (Windows、Mac OS X 、または Linux)  Arduino IDEのインストール Arduino IDEは、オープンソースの電子工作向けハードウェアプラットフォームであるArduinoの開発環境です。\nこの開発環境では、プログラムを記述したり、Arduino基板にプログラムを書き込んだり、基板から送られてくるデータを表示したりすることができます。\nLeafonyは、Arduino IDEを使って開発できます。\n早速Arduino IDEをダウンロードしてみましょう。\n Arduino ホームページから「SOFTWARE」 → 「DOWNLOADS」の順でページを開き、Arduino IDEのダウンロードページに飛ぶ。 「Download the Arduino IDE」と書いてある場所で、使用しているOSにあったインストーラをダウンロード。 ダウンロードしたインストーラを実行して、画面の指示に従ってArduino IDEをインストール。  次のステップ\rLeafonyにプログラムを書き込んで動かしてみましょう！\r\rPCと接続 USBケーブルでPCと接続しましょう。\nマイコンボードの設定 Arduino IDEでLeafonyの開発を行うために、下記の手順でIDEの設定を行いましょう。\n ツール → ボードから、Arduino Pro or Pro Miniを選択、プロセッサでATmega328P (3.3V,8MHz)を選択  \nツール → シリアルポートから、Leafonyが接続されているシリアルポートを選択  マイコンボードの動作確認  Arduino IDEでファイル → スケッチ例 → 01.Basics → Blinkをクリックし、サンプルアプリを開きましょう。 マイコンボードに書き込むボタンを押すをLeafonyにプログラムが書き込まれます。 AVR MCUリーフに搭載されたLEDが点滅していることが確認できれば完了です。  困ったときは 「うまく動かないときは」で解決方法を探してみましょう。\n次のステップ\rサンプルアプリには、幾つものプログラムを用意しています。\n開発を簡単にするため、ライブラリをインストールしてから、始めてください。\r\rライブラリのインストール 一部のリーフを使用するには、追加のライブラリをインストールする必要があります。\n下記の手順を参考に、あらかじめ全てののライブラリをインストールしておきましょう。\n1. 使用するライブラリ 各Kitで使用するライブラリは以下の通りです。\n\r\rリーフ名\r必要なライブラリ名\r推奨バージョン\r説明\r\r\r\r\rBLE\rTBGLib\r\rBluetoothライブラリ\r\r\r4-Sensors\rAdafruit_Sensor.h\r\rユニファイドセンサドライバ\r\r\rAdafruit_BusIO_Register.h\r\rBus IOライブラリ\r\r\rHTS221.h\r\r温湿度センサライブラリ\r\r\rClosedCube_OPT3001.h\r\r照度センサライブラリ\r\r\rAdafruit_LIS3DH.h\r1.1.2\r加速度センサライブラリ\r\r\rLCD\rST7032.h\r\rLCDライブラリ\r\r\rAVR MCU\rMsTimer2.h\r\rタイマ割り込みライブラリ\r\r\rRTC\u0026MicroSD\rRTClib.h\r\rRTCライブラリ\r\r\r\r2. ライブラリをダウンロード 上記表のリンクをクリックすると、ライブラリのGitHubリポジトリにアクセスします。 Code → Download ZIPをクリックし、ライブラリをダウンロードしましょう。\n3. ライブラリをインクルード Arduinoを立ち上げ、スケッチ → ライブラリをインクルード → ZIP形式のライブラリをインストールの順に選択して、先程ダウンロードしたZIPファイルを読み込みましょう。\n","excerpt":"Leafonyはプログラムを書き込んで初めて動作します。\nたとえば、クイックスタートでは、4つのセンサを読み取って、Bluetooth LEでデータを送信するプログラムが書き込まれています。\nこれか …","ref":"/docs/environment/basic/","title":"Basic Kit 開発環境設定マニュアル"},{"body":"Basic Kitは、温湿度、照度、加速度センサを搭載した4-Sensorsリーフ、AVR MCUリーフ、Bluetooth LEリーフを搭載した小型でコイン電池駆動可能な開発キットです。\nBluetoothを使ってスマートフォンやパソコンにセンサの情報を送信したり、Basic Kitに搭載されたLEDをコントロールすることが簡単にできます。\nBasic Kitには、箱を開けたらすぐに使えるこのプログラムが書き込まれています。\nスマートフォンやパソコン側には、「Web Bluetooth」と言うアプリを使って、プラットフォームを問わず、またインストール不要で、Basic Kitとの接続が出来ます。\n用意するもの  Basic Kit Windows1、 Mac2、 Linux3、 Chrome OSのPCまたは\nAndroid4、 iPhone5、 iPad5のスマートフォンまたはタブレット Google Chrome (バージョン70.0.3526.0以降)6  デモ動画 \r\rセットアップ  Basic KitにCR2032コイン電池を挿入し、電源スイッチをONにする。    使い方  Androidの場合 iPhoneまたはiPadの場合 WindowsまたはmacOSの場合 Linuxの場合  Androidの場合  Google Chromeを開く。 Webアプリを開く。 WebアプリのConnectボタンを押して、Leafony_AC02を選択し、Pairボタンを押す。\n   接続完了\n  今回使用したサンプルアプリは「Web Bluetoothを使ったIoTアプリ入門」です。ソースコードや動作の仕組みはこちらでご覧になれます。\n  次のステップ\r開発環境設定を読んで、Basic Kitにプログラムを書き込んでみましょう。\r\riPhoneまたはiPadの場合  App StoreからWebBLE (有償)をダウンロード5 以下のURLをコピーし、WebBLEを立ち上げてアドレスバーに貼り付けてください。   https://docs.leafony.com/WebBluetooth_for_Leafony_app/\r WebアプリのConnectボタンを押して、Leafony_AC02を選択し、Pairボタンを押す。\n  接続完了\n画面上に「Download CSV 」のボタンはありますが、iPhoneでは使用できません。\n  今回使用したサンプルアプリは「Web Bluetoothを使ったIoTアプリ入門」です。ソースコードや動作の仕組みはこちらでご覧になれます。\n  次のステップ\r開発環境設定を読んで、Basic Kitにプログラムを書き込んでみましょう。\r\rWindowsまたはmacOSの場合   Google Chromeを開く。\n  Webアプリを開く。\n  WebアプリのConnectボタンを押して、Leafony_AC02を選択し、Pairボタンを押す。\n  接続完了\n  今回使用したサンプルアプリは「Web Bluetoothを使ったIoTアプリ入門」です。ソースコードや動作の仕組みはこちらでご覧になれます。\n  次のステップ\r開発環境設定を読んで、Basic Kitにプログラムを書き込んでみましょう。\r\rLinuxの場合   Linux上でWeb Bluetoothを有効にするために、下記の記事を参考に環境を設定してください。\nHow to get Chrome Web Bluetooth working on Linux\n  Google Chromeを開く。\n  Webアプリを開く。\n  WebアプリのConnectボタンを押して、Leafony_AC02を選択し、Pairボタンを押す。\n  接続完了\n  今回使用したサンプルアプリは「Web Bluetoothを使ったIoTアプリ入門」です。ソースコードや動作の仕組みはこちらでご覧になれます。\n  次のステップ\r開発環境設定を読んで、Basic Kitにプログラムを書き込んでみましょう。\r\r  Windows 10 version 1703以降 \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite以降 \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow以降 \u0026#x21a9;\u0026#xfe0e;\n iPhoneまたはiPadの場合は WebBLE(有料)が必要です。iPhone、iPad版のChromeではWeb Bluetoothが実装されていないためです。 \u0026#x21a9;\u0026#xfe0e;\n Chromeがバージョン79未満の場合、標準でWeb Bluetoothが有効になっていません。\nChromeのアドレスバーに次のURLを入力し、Experimental Web Platform featuresをEnableにしてください。\nchrome://flags/#enable-experimental-web-platform-features \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Basic Kitは、温湿度、照度、加速度センサを搭載した4-Sensorsリーフ、AVR MCUリーフ、Bluetooth LEリーフを搭載した小型でコイン電池駆動可能な開発キットです。 …","ref":"/docs/getting-started/basic/","title":"Basic Kit スタートガイド"},{"body":"\n概要 コイン電池でも駆動可能な超小型・低消費電力システム向きの開発キットです。AVRマイコン(Atmega328P)、Bluetooth LE、温湿度センサ、照度センサ、加速度センサを搭載したリーフとマグネット付きプラスチックケースが含まれており、簡単にIoTセンサデバイスを作ることが出来ます。\n内容物    Type Item Q’ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AX02 29pin 1   AZ01 USB 1   AZ62 Connector Cover 1   AZ66 Basic Kit Case 1    Caution note 1    CR2032 coin cell battery 1    M2*15mm screw 2    Screw driver 1    リーフ一覧 \rAC02 BLE Sugar\r\rSilicon Labsの技的認証済みBluetooth LEモジュールBGM11S22F256GA-V2を搭載したリーフです。\n\r\r\rAI01 4-Sensors\r\r温湿度センサ、照度センサ、加速度センサを搭載したリーフです。省電力なセンサを搭載し長時間のセンシングに適しています。\n\r \rAP01 AVR MCU\r\rATmega328Pを使用したリーフです。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。\n\r \rAV01 CR2032\r\rCR2032コイン電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。2cm x 2cmのサイズで3.3Vの電源を供給可能です。\n\r \rAX02 29pin\r\rリーフI/Fの29ピン全てを2.54mmピッチのスルーホールに接続したリーフです。\n\r \rAZ01 USB\r\rAVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\n\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \rAZ66 Basic kit case\r\rBasic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\n\r \r変更履歴  Rev A1.0: 2019年8月初版  ","excerpt":"概要 コイン電池でも駆動可能な超小型・低消費電力システム向きの開発キットです。AVRマイコン(Atmega328P)、Bluetooth LE、温湿度センサ、照度センサ、加速度センサを搭載したリーフと …","ref":"/docs/products/basic/","title":"Basic Kit"},{"body":"概要 AVR MCUリーフに搭載されたLEDを1秒おきに点灯/消灯させます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*10mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // Blink // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //=====================================================================  void setup() { // LEDピンを出力ピンに設定  pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); // LEDを点灯  delay(1000); // 1秒待つ  digitalWrite(LED_BUILTIN, LOW); // LEDを消灯  delay(1000); // 1秒待つ } ","excerpt":"概要 AVR MCUリーフに搭載されたLEDを1秒おきに点灯/消灯させます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP01 AVR MCU …","ref":"/en/docs/examples/beginner/basic/blink/","title":"LED点滅"},{"body":"Leafonyとは トリリオンノード・エンジンには以下のような特徴があり、製品名はLeafony（リーフォニー）です。LeafonyはIoT/CPSシステムやアプリ、サービスの研究開発効率を断然アップさせます。ビデオも同時にご覧ください。\n  超小型で組立簡単: 1円玉大の電子基板モジュール（リーフ）ですが、新規研究開発されたコネクタによって、組立はブロック玩具のように簡単。\n  超低消費電力: 低消費電力性に優れています。すべてのリーフにはスタンバイモードやソフトウェアで制御できる電源スイッチ装備されていて、コイン電池でも動作します。\n  オープンソース・ハード／ソフト: 商用でも無償でフリーに使える仕様・回路図・パターン図などのハードウェア情報が公開されています。ソフトウェアもすでに数万本あるフリーのArduinoソフトウェアが使えます。その他のソフトウェアでも使えます。\n  リーフの製作が簡単: リーフを作るときには、特殊な技術やコネクタは不要。Leafonyコネクタを後で手で付けられるなど、あなた自身の独自リーフも短工期で簡単に作れ、研究開発効率が断然アップします。\n  \r\r詳細はこちらの資料をご覧ください。\n利用シーン  企業  IoTのProof of Concept R\u0026amp;D、実証実験、社会課題を解く IoTシステム試作サービス レファレンスモデルの作製 自社部品／技術の販売ツール 技術の再利用や伝承   個人  新しいアプリ サービスの探査 手軽なガジェット創り   教育・大学  IoT教育 研究／実験 研究成果をデモし実用化加速    はじめてみよう さっそくLeafonyを使ってみましょう。\n クイックスタート 開発環境設定 サンプルデザイン  ","excerpt":"Leafonyとは トリリオンノード・エンジンには以下のような特徴があり、製品名はLeafony（リーフォニー）です。LeafonyはIoT/CPSシステムやアプリ、サービスの研究開発効率を断然アップ …","ref":"/en/docs/overview/","title":"Overview"},{"body":"Leafonyとは Leafonyは、超小型、低消費電力、簡単に出来るオープンイノベーション・プラットフォームです。新しいITサービスやIoTのエッジノードなどの試作開発が、簡単に出来ます。トリリオンノード・エンジン・プロジェクト1が、このプラットフォームの研究開発を推進し、仕様などが確定したものを「Leafony」と呼びます。また、このLeafonyを製造・販売する会社をLEAFONY SYSTEMS社と言います。\nIoT/CPS2など将来非常に多くのITノードが社会で使われるようになると言われています。東京大学 桜井名誉教授は、そのような未来を議論し情報を共有するため、トリリオンノード研究会を立ち上げました。具体的に考えるベースとして、Leafonyを使っており、IoT/CPSの発展のため、Leafonyの普及に力を入れています。また、ニーズとシーズを持った関連企業をつなぐ場も提供しています。\nLeafonyは、LeafとSymphonyの造語で、個と全体の調和を目指しています。Symphonyは音色が調和して、素晴らしい楽曲を奏でるように、Leafが集まって、素晴らしい価値を創造して欲しいという願いが込められています。\n利用シーン 企業\r\r・IoTのProof of Concept (PoC)\n・R\u0026amp;D、実証実験\n・IoTシステム試作サービス\n・リファレンスモデルの作製\n・自社部品／技術の販売ツール\n・技術の再利用や伝承\n\r\r個人\r\r・新しいアプリ\n・サービスの探査\n・手軽なガジェット創り\n\r 教育・大学\r\r・IoT教育\n・研究／実験\n・研究成果をデモし実用化加速\n\r \r概要動画 \r\r詳しくは、こちらを参照して下さい。\rはじめてみよう さっそくLeafonyを使ってみましょう。\n クイックスタート 開発環境設定 サンプルアプリ    トリリオンノード・エンジン・プロジェクトは、国立研究開発法人新エネルギー・産業技術総合開発機構（ＮＥＤＯ）の委託・助成事業による研究開発プロジェクトです。 \u0026#x21a9;\u0026#xfe0e;\n IoTはInternet of Things、CPSはCyber-Physical Systemsの略です。特に、CPSはネットにつながらずとも、リアルな物理的空間とデジタル空間をつなぐような システムです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Leafonyとは Leafonyは、超小型、低消費電力、簡単に出来るオープンイノベーション・プラットフォームです。新しいITサービスやIoTのエッジノードなどの試作開発が、簡単に出来ます。トリリオン …","ref":"/docs/overview/","title":"はじめに"},{"body":"以下の手順で Leafony ESP32 Wi-Fi Kit 開発環境の設定を行いましょう。\nArduino IDEのインストール Arduino IDEは、オープンソースの電子工作向けハードウェアプラットフォームであるArduinoの開発環境です。\nこの開発環境では、プログラムを記述したり、Arduino基板にプログラムを書き込んだり、基板から送られてくるデータを表示したりすることができます。\nLeafonyはArduino互換の基板なので、Arduino IDEを使って開発できます。\n早速Arduino IDEをダウンロードしてみましょう。\n Arduino ホームページから「SOFTWARE」 → 「DOWNLOADS」の順でページを開き、Arduino IDEのダウンロードページに飛ぶ 「Download the Arduino IDE」と書いてある場所で、使用しているOSにあったインストーラをダウンロード ダウンロードしたインストーラを実行して、画面の指示に従ってArduino IDEをインストール  ボード設定 ESP32 MCUリーフをArduino IDEで使用するには、Arduino core for the ESP32 のインストールが必要です。\n Arduino IDEのファイル → 環境設定を開き、追加のボードマネージャのURL:に、下記URLを入力してください。  https://dl.espressif.com/dl/package_esp32_index.json\r\nツール→ボード→ボードマネージャを選択し、esp32 by Espressif Systemsを検索し、インストールのボタンを押しましょう。  \nツール → ボード → ESP32 Dev Moduleを選択すれば、ESP32 MCUが使えるようになります。  ライブラリのインストール 一部のリーフを使用するには、追加のライブラリのインストールが必要となる場合があります。 下記の手順を参考に、あらかじめ全てののライブラリをインストールしておきましょう。\n1. 使用するライブラリ Basic Kit、Extension Kitで使用するライブラリは以下の通りです。\n\r\rリーフ名\r必要なライブラリ名\r推奨バージョン\r説明\r\r\rBLE\rTBGLib\r\rBluetoothライブラリ\r\r\r4-Sensors\rAdafruit_Sensor.h\r\rユニファイドセンサドライバ\r\r\rHTS221.h\r\r温湿度センサライブラリ\r\r\rClosedCube_OPT3001.h\r\r照度センサライブラリ\r\r\rAdafruit_LSI3DH.h\r1.1.2\r加速度センサライブラリ\r\r\rLCD\rST7032.h\r\rLCDライブラリ\r\r\rAVR MCU\rMsTimer2.h\r\rタイマ割り込みライブラリ\r\r\rRTC\u0026MicroSD\rRTClib.h\r\rRTCライブラリ\r\r\r2. Githubからライブラリをダウンロード 上記表のリンクをクリックすると、ライブラリのGitHubリポジトリにアクセスします。 Clone or download → Download ZIPをクリックし、ライブラリをダウンロードしましょう。\n3. ライブラリのインクルード Arduinoを立ち上げ、スケッチ → ライブラリをインクルード → ZIP形式のライブラリをインストールの順に選択して、先程ダウンロードしたZIPファイルを読み込みましょう。\nサンプルスケッチで動作確認 サンプルスケッチを書き込んで、ESP32 Wi-Fi Kitを動かしてみましょう。\n Arduinoを起動する。 下記のサンプルコードをコードエディタに貼り付ける。  //***************************** // ボタン入力の状態をシリアルモニタに表示するサンプル //***************************** int pushButton = 0; void setup() { Serial.begin(115200); pinMode(pushButton, INPUT); } void loop() { int buttonState = digitalRead(pushButton); Serial.println(buttonState); delay(1); } ESP32リーフが接続されたCOMポートを選択する。 マイコンボードに書き込むボタンを押してスケッチを書き込む。 書き込み中に下記の表示が出たら、ESP32リーフのBootボタンを長押しする。  \nシリアルモニタを開いて、通信速度を115200bpsにする。 Bootボタン(IO0)を押してボタンの入力状態が変わるのを確認する。  次のステップ\rサンプルデザインにあるコードをLeafonyに書き込んでみましょう。\r\r","excerpt":"以下の手順で Leafony ESP32 Wi-Fi Kit 開発環境の設定を行いましょう。\nArduino IDEのインストール Arduino IDEは、オープンソースの電子工作向けハードウェアプ …","ref":"/en/docs/environment/esp32/","title":"ESP32 Wi-Fi Kit 開発環境設定マニュアル"},{"body":"ESP32 Wi-Fi Kit A1.0には、既に組み立てられたハードウェアが入っています。そのままで、スマートフォンやパソコンにWi-Fiを使ってタッチセンサの値を送信し、簡単に表示できます。\n用意するもの  ESP32 Wi-Fi Kit Wi-Fi機能を搭載したPCまたはスマートフォン・タブレット お好みのブラウザ  使い方  ESP32 Wi-Fi Kitに単4電池3本をセットし、電源スイッチを入れて下さい。 お使いのPCまたはスマートフォン・タブレット等で周辺のWi-Fiを検索し、下記のSSIDのWi-Fiに接続します。  SSID: Leafony_ESP32-AP Password: password   ブラウザを起動して、下記URLにアクセスしてください。 http://192.168.4.1 29pin headerの7、9、22、24、26、28ピンがタッチセンサに割り当てられています。\nピンに触れると静電容量が減るため、値が減少します。値が閾値20以下になると”Touch detected”と表示されます。\n(24ピンはRTC\u0026amp;microSDと干渉しているため、サンプルスケッチでは非表示にしています。検出閾値は、スケッチで変更可能です。以下の写真では、指先で26ピンに触れています。)  26ピンに触れていると、以下のようにブラウザの表示が変化します。　  ESP32 Wi-Fi KitのNut Plate部分にマグネットが付いています。金属の壁などに設置してみましょう。  今回つかったサンプルのソースコードはこちらです。  次のステップ\r開発環境設定を読んで、ESP32 Wi-Fi KitにLED点滅スケッチを書き込んでみましょう。\r\rピン配置 \nサンプルアプリのソースコード  Arduinoスケッチ  ","excerpt":"ESP32 Wi-Fi Kit A1.0には、既に組み立てられたハードウェアが入っています。そのままで、スマートフォンやパソコンにWi-Fiを使ってタッチセンサの値を送信し、簡単に表示できます。\n用意 …","ref":"/en/docs/getting-started/esp32/","title":"ESP32 Wi-Fi Kit スタートガイド"},{"body":"以下の手順で ESP32 Wi-Fi Kit 開発環境の設定を行いましょう。\n次のステップ\rLeafonyにプログラムを書き込むために必要なソフトウェアをインストール\r\r用意するもの  ESP32 Wi-Fi Kit PC (Windows、Mac OS X 、または Linux)  Arduino IDEのインストール Arduino IDEは、オープンソースの電子工作向けハードウェアプラットフォームであるArduinoの開発環境です。\nこの開発環境では、プログラムを記述したり、Arduino基板にプログラムを書き込んだり、基板から送られてくるデータを表示したりすることができます。\nLeafonyはArduino互換の基板なので、Arduino IDEを使って開発できます。\n早速Arduino IDEをダウンロードしてみましょう。\n Arduino ホームページから「SOFTWARE」 → 「DOWNLOADS」の順でページを開き、Arduino IDEのダウンロードページに飛ぶ。 「Download the Arduino IDE」と書いてある場所で、使用しているOSにあったインストーラをダウンロード。 ダウンロードしたインストーラを実行して、画面の指示に従ってArduino IDEをインストール。  次のステップ\rLeafonyにプログラムを書き込んで動かしてみましょう！\r\rPCと接続 USBケーブルでPCと接続しましょう。\nマイコンボードの設定 ESP32 MCUリーフをArduino IDEで使用するには、Arduino core for the ESP32 のインストールが必要です。\n Arduino IDEのファイル → 環境設定を開き、追加のボードマネージャのURL:に、下記URLを入力してください。  　https://dl.espressif.com/dl/package_esp32_index.json\n\nツール→ボード→ボードマネージャを選択し、esp32 by Espressif Systemsを検索し、インストールのボタンを押しましょう。  \nツール → ボード → ESP32 Dev Moduleを選択すれば、ESP32 MCUが使えるようになります。  マイコンボードの動作確認 サンプルスケッチを書き込んで、ESP32 Wi-Fi Kitを動かしてみましょう。\n Arduinoを起動する。 下記のサンプルコードをコードエディタに貼り付ける。  //***************************** // ボタン入力の状態をシリアルモニタに表示するサンプル //***************************** int pushButton = 0; void setup() { Serial.begin(115200); pinMode(pushButton, INPUT); } void loop() { int buttonState = digitalRead(pushButton); Serial.println(buttonState); delay(1); } ESP32リーフが接続されたCOMポートを選択する。 マイコンボードに書き込むボタンを押してスケッチを書き込む。 書き込み中に下記の表示が出たら、ESP32リーフのBootモードスイッチを長押しする。  \nシリアルモニタを開いて、通信速度を115200bpsにする。 Bootモードスイッチ(IO0)を押してスイッチの入力状態が変わるのを確認する。  \n困ったときは 「うまく動かないときは」で解決方法を探してみましょう。\n次のステップ\rサンプルアプリには、幾つものプログラムを用意しています。\n開発を簡単にするため、ライブラリをインストールしてから、始めてください。\r\rライブラリのインストール 一部のリーフを使用するには、追加のライブラリをインストールする必要があります。 下記の手順を参考に、あらかじめ全てののライブラリをインストールしておきましょう。\n1. 使用するライブラリ 各Kitで使用するライブラリは以下の通りです。\n\r\rリーフ名\r必要なライブラリ名\r推奨バージョン\r説明\r\r\rBLE\rTBGLib\r\rBluetoothライブラリ\r\r\r4-Sensors\rAdafruit_Sensor.h\r\rユニファイドセンサドライバ\r\r\rAdafruit_BusIO_Register.h\r\rBus IOライブラリ\r\r\rHTS221.h\r\r温湿度センサライブラリ\r\r\rClosedCube_OPT3001.h\r\r照度センサライブラリ\r\r\rAdafruit_LIS3DH.h\r1.1.2\r加速度センサライブラリ\r\r\rLCD\rST7032.h\r\rLCDライブラリ\r\r\rRTC\u0026MicroSD\rRTClib.h\r\rRTCライブラリ\r\r\r2. Githubからライブラリをダウンロード 上記表のリンクをクリックすると、ライブラリのGitHubリポジトリにアクセスします。 Code → Download ZIPをクリックし、ライブラリをダウンロードしましょう。\n3. ライブラリのインクルード Arduinoを立ち上げ、スケッチ → ライブラリをインクルード → ZIP形式のライブラリをインストールの順に選択して、先程ダウンロードしたZIPファイルを読み込みましょう。\n","excerpt":"以下の手順で ESP32 Wi-Fi Kit 開発環境の設定を行いましょう。\n次のステップ\rLeafonyにプログラムを書き込むために必要なソフトウェアをインストール\r\r用意するもの  ESP32 …","ref":"/docs/environment/esp32/","title":"ESP32 Wi-Fi Kit 開発環境設定マニュアル"},{"body":"ESP32 Wi-Fi Kit は、Wi-FiとBluetooth LE内蔵のESP32-WROOM-32を搭載した乾電池やリチウムバッテリーで駆動可能な開発キットです。\nWi-Fiを使ってスマートフォンやパソコンに、タッチセンサの値を送信することが簡単にできます。\nESP32 Wi-Fi Kitは、箱を開けたらすぐに使えるこのプログラムが書き込まれています。\n用意するもの  ESP32 Wi-Fi Kit Wi-Fi機能を搭載したPC、スマートフォン、またはタブレット お好みのWebブラウザ  使い方  ESP32 Wi-Fi Kitに単4電池3本をセットし、電源スイッチをONにして下さい。\n PC、スマートフォン、またはタブレット等で周辺のWi-Fiを検索し、以下のSSIDのWi-Fiに接続します。  SSID: Leafony_ESP32-AP Password: password   以下のURLをコピーし、WebBLEを立ち上げてアドレスバーに貼り付けてください。   http://192.168.4.1\r 29pin headerの7、9、22、24、26、28ピンがタッチセンサに割り当てられています。\nピンに触れると静電容量が増えるため、値が減少します。値が閾値20以下になると”Touch detected”と表示されます。\n(24ピンはRTC\u0026amp;microSDと干渉しているため、サンプルスケッチでは非表示にしています。検出閾値は、スケッチで変更可能です。以下の写真では、指先で26ピンに触れています。)\n   26ピンに触れていると、以下のようにWebブラウザの表示が変化します。　   ESP32 Wi-Fi KitのNut Plate部分にマグネットが付いています。金属の壁などに設置してみましょう。\n  今回使用したサンプルアプリは「Wi-Fi タッチセンサ」です。ソースコードや動作の仕組みはこちらでご覧になれます。  次のステップ\r開発環境設定を読んで、ESP32 Wi-Fi Kitにプログラムを書き込んでみましょう。\r\r","excerpt":"ESP32 Wi-Fi Kit は、Wi-FiとBluetooth LE内蔵のESP32-WROOM-32を搭載した乾電池やリチウムバッテリーで駆動可能な開発キットです。\nWi-Fiを使ってスマートフ …","ref":"/docs/getting-started/esp32/","title":"ESP32 Wi-Fi Kit スタートガイド"},{"body":"ピン配置 \nサンプルデザイン ","excerpt":"ピン配置 \nサンプルデザイン ","ref":"/en/docs/getting-started/extension/","title":"Extension Kit スタートガイド"},{"body":"\n概要 Basic KitやESP32 Wi-Fi Kitと組み合わせて使える、便利で使い勝手の良い色々なリーフが入っているキットで、より広範な応用を実現できます。Extension Kit には、マイコンリーフが含まれていませんので、ソフトウェアを動かすためにBasic Kitか、ESP32 Wi-Fi Kit が必要です。\n内容物    Type Item Q’ty     AI02 SP \u0026amp; PIR 1   AI03 MIC \u0026amp; VR \u0026amp; LED 1   AI04 LCD 1   AV03 AA BAT 1   AX01 Shield 1   AX03 Leafx2 1   AX04 Spacer 1   AX05 I Meas. 1   AX06 Grove \u0026amp; 5V 1    Caution note 1    リーフ一覧 \rAI02 SP\u0026amp;PIR\r\r圧電スピーカと人感センサを搭載したリーフです。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で物体の接近を検知することが可能です。\n\r \rAI03 MIC\u0026amp;VR\u0026amp;LED\r\rMEMSマイク、ボリューム、LEDを搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n\r \rAI04 LCD\r\rキャラクタLCDユニットとユーザスイッチ2個を搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n\r \rAV03 AA BAT\r\r単3電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。3つのLeafonyコネクタを搭載しより多くのリーフに電源供給が可能です。\n\r \rAX01 Shield\r\rArduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\n\r \rAX03 Leaf x2\r\rリーフを横並びに接続するためのコネクタリーフです。\n\r \rAX04 Spacer\r\r積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\n\r \rAX05 I Meas.\r\r3.3VおよびVBUSに流れる電流を測定するためのリーフです。通常Leafony busは両面とも電気的に接続されていますが、このリーフでは3.3VとVBUSのみ表裏で切断され、それぞれスルーホールに接続されています。\n\r \rAX06 Grove\u0026amp;5V\r\rSeeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\n\r \r変更履歴  Rev A1.0: 2019年8月初版  ","excerpt":"概要 Basic KitやESP32 Wi-Fi Kitと組み合わせて使える、便利で使い勝手の良い色々なリーフが入っているキットで、より広範な応用を実現できます。Extension Kit には、マイ …","ref":"/en/docs/products/extension/","title":"Extension Kit"},{"body":"Leafony（リーフォニー）または、Leafony platform（リーフォニー・プラットフォーム） 超小型、電池で動く、組み立て簡単なオープンイノベーション・プラットフォームです。特に、新しいITサービスやガジェット、マシンあるいはIoTのエッジノードなどを生み出すための試みが簡単になるエレクトロニクスおよびソフトウェアのプラットフォームとなっています。このようなプラットフォーム構築を目指して、トリリオンノード・エンジン・プロジェクト１）がその研究開発を進めています。このプロジェクトで研究開発が終了し、仕様などが確定したものをLeafonyと呼びます。LeafonyはLeafとSymphonyの造語ですが、個と全体の調和を目指した造語です。Symphonyでは、さまざまな楽器の出す音色が調和して素晴らしい楽曲を奏でるようにLeafが集まって素晴らしい価値を創造して欲しいという願いが込められています。「Leafony」は登録商標です。\nLeafonyは、現在Arduino Pro or Pro Mini (3.3V/8MHz) のソフトウェア環境で動作するようになっていますが、プロセッサリーフを変更することにより、どのようなプロセッサ環境／ソフトウェア環境でも使用できるようになっています。新規開発ソフトウェアは、MITライセンスで公開していますので、商用でも自由に無償で使用できます。\nトリリオンノード・エンジンプロジェクトでは、今後、Leafonyがより強力なプロセッサ環境にも対応できるように、また将来、AIなどの開発プラットフォームとしても使えることを目指して、引き続き各種の拡張を研究開発しています。\nLeaf（リーフ） Leafonyの基礎となる2cm角程度の電子基板／電子モジュールのことです。小さくて緑色なのでリーフ（木の葉）と呼んでいます。\nLeafony block（リーフォニー・ブロック）作成中 複数のリーフを組合わせて出来上がった電子機器のことです。Leafony blockは、単体で使用する場合や、機器の中に組み込まれる場合があります。\nLeafony bus（リーフォニー・バス） 複数のリーフ間を相互に接続する共通経路部をLeafonyバスと呼びます。電気信号および電源接続を行うための電気的および物理的な仕様が定義されています。典型的にはリーフの20mm x 5.5mmの領域となります。Leafonyバス準拠のリーフは他のリーフと交信可能になりますが、Leafonyプラットフォームと完全に問題なく繋がるかはソフトウェアなどにもよるため、Leafonyバス準拠というのはあくまでも物理レベルに近いところで接続可能といっているに過ぎません。\nLeafonyバスのアートワークには著作権があり、CC-BYライセンスで公開していますので、商用でもLeafony準拠と明記すれば自由に無償で使用できます。従って、自由に独自のリーフを開発や販売ができます。ただし、Leafonyは登録商標ですので、独自に作ったリーフそのものにはLeafonyとは表示しないでください。Leafonyと表示のあるリーフは製品品質が確かめられていることがわかり、混乱を避けられます。\nLEAFONY SYSTEMS Co.,Ltd.（リーフォニー・システムズ 株式会社） トリリオンノード・エンジン・プロジェクトが研究開発したLeafonyを製造、販売する唯一の会社です。LeafにLeafonyを表示しているのはLEAFONY SYSTEMS社のLeafだけです。Leafonyと表示されたLeafは、相互接続などがトリリオンノード・エンジン・プロジェクトによって確認されています。\nLeafonyバス準拠のリーフ、他の企業や個人などから多数販売されますし、そのような活動を推奨していますが、リーフ自体にLeafonyの表示はされません。\nトリリオンノード研究会 IoT/CPS２）など将来非常に多くのITノードが社会で使われるようになると言われています。そのような未来を議論し情報を共有するための研究会です。具体的に考えるベースとして、Leafonyを使っており、IoT/CPSの発展のため、Leafonyの普及に力を入れています。また、ニーズとシーズを持った関連企業をつなぐ場も提供しています。\n １）トリリオンノード・エンジン・プロジェクトは、国立研究開発法人新エネルギー・産業技術総合開発機構（ＮＥＤＯ）の委託・助成事業による研究開発プロジェクトです。\n２）IoTはInternet of Things、CPSはCyber-Physical Systemsの略です。特に、CPSはネットにつながらずとも、リアルな物理的空間とデジタル空間をつなぐような システムです。\n","excerpt":"Leafony（リーフォニー）または、Leafony platform（リーフォニー・プラットフォーム） 超小型、電池で動く、組み立て簡単なオープンイノベーション・プラットフォームです。特に、新し …","ref":"/en/docs/overview/terms/","title":"用語の説明"},{"body":"キット \rBasic Kit\r\rBluetooth LEと4つのセンサを搭載。小型でコイン電池駆動可能な開発キット。\n\r\r\rESP32 Wi-Fi Kit\r\rWi-FiとBluetooth LE内蔵のESP32-WROOM-32を搭載。乾電池やリチウムバッテリーで駆動可能な開発キット。\n\r \rExtension Kit\r\rBasic KitやESP32 Wi-Fi Kitと組み合わせて使える、人感センサや MEMS マイクなどを搭載したリーフが入っているキット。\n\r \rその他 \rConnector\r\rLeafonyプラットフォーム用のConnector10個セット。\n\r\r\rNut Plate \u0026amp; Connector Cover\r\rリーフをねじで固定する時に使用するNut Plate と ACR に付着するゴミを防御するコネクタカバー。\n\r \rサードパーティ 掲載予定\n","excerpt":"キット \rBasic Kit\r\rBluetooth LEと4つのセンサを搭載。小型でコイン電池駆動可能な開発キット。\n\r\r\rESP32 Wi-Fi Kit\r\rWi-FiとBluetooth LE内蔵 …","ref":"/docs/products/","title":"製品一覧"},{"body":"\n概要 人気のESP32マイコンをベースとしたWi-Fi無線通信、microSD、リアルタイムクロック機能が入ったキットです。Basic Kitより少しサイズが大きく、消費電力も大きくなっていますが、断然高性能です。コイン電池では動作しませんが、少し大きめの電池で動きます。そのままで、スマートフォンやパソコンにWi-Fiを使ってタッチセンサの値を送信し、簡単に表示できます。\n内容物    Type Item Q’ty     AP02 ESP32 MCU 1   AV04 2V～4.5V 1   AX07 Back to back 1   AX08 29 pin header 1   AZ02 RTC \u0026amp; micro SD 1   AZ62 Connector Cover 2   AZ63 Nut Plate 2    AAA battery holder 1    Caution note 1    M2*12mm screw 2    φ10x2mm magnet 1    リーフ一覧 \rAP02 ESP32 MCU\r\rEspressif Systemsの、技的認証済みWi-FiとBluetooth LEを内蔵したモジュールESP32-WROOM-32を搭載した32bit MCUリーフです。\n\r \rAV04 2V～4.5V\r\rリチウムイオンバッテリや電池ボックス接続用のJST製SHコネクタと電源スイッチ、電圧モニタ用のADコンバータ、3.3V昇降圧回路を搭載した電源リーフです。2V～4.5Vの電池電圧入力に対応しています。\n\r \rAX07 Back to back\r\rリーフを背中合わせに接続可能なコネクタリーフです。\n\r \rAX08 29pin header\r\rリーフI/Fの29ピン全てを2.54mmピッチのピンヘッダに接続したリーフです。\n\r \rAZ02 RTC\u0026amp;microSD\r\rNXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。microSDカードはSPIでアクセスします。\n\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \rAZ63 Nut Plate\r\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n\r \r変更履歴  Rev A1.0: 2020年1月初版  ","excerpt":"概要 人気のESP32マイコンをベースとしたWi-Fi無線通信、microSD、リアルタイムクロック機能が入ったキットです。Basic Kitより少しサイズが大きく、消費電力も大きくなっていますが、断 …","ref":"/en/docs/products/esp32/","title":"ESP32 Wi-Fi Kit"},{"body":"\n概要 人気のESP32マイコンをベースとしたWi-Fi無線通信、microSD、リアルタイムクロック機能が入ったキットです。Basic Kitより少しサイズが大きく、消費電力も大きくなっていますが、断然高性能です。コイン電池では動作しませんが、少し大きめの電池で動きます。そのままで、スマートフォンやパソコンにWi-Fiを使ってタッチセンサの値を送信し、簡単に表示できます。\n内容物    Type Item Q’ty     AP02 ESP32 MCU 1   AV04 2V～4.5V 1   AX07 Back to back 1   AX08 29 pin header 1   AZ02 RTC \u0026amp; microSD 1   AZ62 Connector Cover 2   AZ63 Nut Plate 2    AAA battery holder 1    Caution note 1    M2*12mm screw 2    φ10x2mm magnet 1    リーフ一覧 \rAP02 ESP32 MCU\r\rEspressif Systemsの、技的認証済みWi-FiとBluetooth LEを内蔵したモジュールESP32-WROOM-32を搭載した32bit MCUリーフです。\n\r \rAV04 2V～4.5V\r\rリチウムイオンバッテリや電池ボックス接続用のJST製SHコネクタと電源スイッチ、電圧モニタ用のADコンバータ、3.3V昇降圧回路を搭載した電源リーフです。2V～4.5Vの電池電圧入力に対応しています。\n\r \rAX07 Back to back\r\rリーフを背中合わせに接続可能なコネクタリーフです。\n\r \rAX08 29pin header\r\rリーフI/Fの29ピン全てを2.54mmピッチのピンヘッダに接続したリーフです。\n\r \rAZ02 RTC\u0026amp;microSD\r\rNXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。microSDカードはSPIでアクセスします。\n\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \rAZ63 Nut Plate\r\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n\r \r変更履歴  Rev A1.0: 2020年1月初版  ","excerpt":"概要 人気のESP32マイコンをベースとしたWi-Fi無線通信、microSD、リアルタイムクロック機能が入ったキットです。Basic Kitより少しサイズが大きく、消費電力も大きくなっていますが、断 …","ref":"/docs/products/esp32/","title":"ESP32 Wi-Fi Kit"},{"body":"\nExtenston Kitは、Basic KitやESP32 Wi-Fi Kitと組み合わせて使える、人感センサや MEMS マイクなどを搭載したリーフが入っている開発キットです。\nExtenston Kitを駆動させるには、Basic Kit かESP32 Wi-Fi KitのMCUリーフに、プログラムを書き込む必要があります。\n用意するもの  Extenston Kit Basic Kit 、またはESP32 Wi-Fi Kit PC (Windows、Mac OS X 、または Linux)　  プログラムの書き込み方 PCの環境整備がまだならば、「Basic Kit 開発環境設定マニュアル」や「ESP32 Wi-Fi Kit 開発環境設定マニュアル」を参照して準備をしてください。\n次のステップ\rサンプルアプリにあるプログラムを書き込んでみましょう。\r\r","excerpt":"\nExtenston Kitは、Basic KitやESP32 Wi-Fi Kitと組み合わせて使える、人感センサや MEMS マイクなどを搭載したリーフが入っている開発キットです。 …","ref":"/docs/getting-started/extension/","title":"Extension Kit スタートガイド"},{"body":"キット \rBasic Kit\r\rBluetooth LEと4つのセンサを搭載。小型でコイン電池駆動可能な開発キット。\n\r\r\rESP32 Wi-Fi Kit\r\rWi-FiとBluetooth LE内蔵のESP32-WROOM-32を搭載。乾電池やリチウムバッテリーで駆動可能な開発キット。\n\r \rExtension Kit\r\rBasic KitやESP32 Wi-Fi Kitと組み合わせて使える、人感センサや MEMS マイクなどを搭載したリーフが入っているキット。\n\r \rその他 \rConnector\r\rLeafonyプラットフォーム用のConnector10個セット。\n\r\r\rNut Plate \u0026amp; Connector Cover\r\rリーフをねじで固定する時に使用するNut Plate と ACR に付着するゴミを防御するコネクタカバー。\n\r \rサードパーティ \rThirparty leaf\r\r他社リーフ or キットのリンクが入る\n\r\r","excerpt":"キット \rBasic Kit\r\rBluetooth LEと4つのセンサを搭載。小型でコイン電池駆動可能な開発キット。\n\r\r\rESP32 Wi-Fi Kit\r\rWi-FiとBluetooth LE内蔵 …","ref":"/en/docs/products/","title":"Our Products"},{"body":"シリアルポートが見つからない Arduino IDEでLeafonyのシリアルポートが見つからない場合は、USBシリアル変換IC(FT232)のドライバをインストールしてみましょう。 FTDI VCP Driverからデバイスドライバをダウンロードしてインストールしましょう。\n電源が入らない Leafonyの電源が入らない場合は以下の項目を確かめてみましょう。\n ボタン電池の入れる向き 電源スイッチがONになっているか ネジの締まり具合 電池の残量が十分にあるか  接続不良時の対処 Connectorや基板の接点に汚れが付着すると、接続不良が生じることがあります。その場合、無水エタノールを含ませた紙製ウエスで払拭してください。それでも改善しない場合は、Connectorを交換してください。\n","excerpt":"シリアルポートが見つからない Arduino IDEでLeafonyのシリアルポートが見つからない場合は、USBシリアル変換IC(FT232)のドライバをインストールしてみましょう。 FTDI VCP …","ref":"/en/docs/environment/solution/","title":"うまく動かないときは"},{"body":"シリアルポートが見つからない Arduino IDEでLeafonyのシリアルポートが見つからない場合は、USBシリアル変換IC(FT232)のドライバをインストールしてみましょう。 FTDI VCP Driverからデバイスドライバをダウンロードしてインストールしましょう。\n電源が入らない Leafonyの電源が入らない場合は以下の項目を確かめてみましょう。\n ボタン電池の入れる向き 電源スイッチがONになっているか ネジの締まり具合 電池の残量が十分にあるか  ","excerpt":"シリアルポートが見つからない Arduino IDEでLeafonyのシリアルポートが見つからない場合は、USBシリアル変換IC(FT232)のドライバをインストールしてみましょう。 FTDI VCP …","ref":"/docs/environment/solution/","title":"うまく動かないときは"},{"body":"用語の説明（ABC順） IoT/CPS IoTはInternet of Things、CPSはCyber-Physical Systemsの略です。特に、CPSはネットにつながらずとも、リアルな物理的空間とデジタル空間をつなぐようなシステムです。\nLeaf（リーフ） Leafonyの基礎となる2cm角程度の電子基板／電子モジュールのことです。小さくて緑色なのでリーフ（木の葉）と呼んでいます。使用者独自のオリジナル・リーフも容易に作れます。\nLeafony（リーフォニー） または、Leafony platform（リーフォニー・プラットフォーム） リーフを組み合わせて作り上げるオープンなハードウェアとソフトウェアのプラットフォームです。超小型、低消費電力なので、IoT/CPSのシステムを簡単に作れますので、今後のデジタル・トランスフォーメーションのための開発効率アップに適しています。LeafonyはArduinoのソフトウェアでも動きますので、多くのソフトウェアがウェブからダウンロードでき、ソフトウェア開発も簡単です。もちろん、Arduinoの環境以外でも開発可能です。\nLeafonyはLeafとSymphonyの造語ですが、個と全体の調和を目指した造語です。Symphonyでは、さまざまな楽器の出す音色が調和して素晴らしい楽曲を奏でるようにLeafが集まって素晴らしい価値を創造して欲しいという願いが込められています。\nLeafonyの技術情報は、基本的に商用でも自由に無償で使用できます。ライセンスの詳しい情報は、ライセンスの項をご覧ください。使用者独自のリーフはLeafonyバス準拠ということをうたって、企業や個人などから多数販売されますし、そのような活動を推奨しています。しかしながら、Leafonyは登録商標ですので、市場の混乱を避けるため、リーフ自体にLeafonyの表示はお控えください。\nLeafony block（リーフォニー・ブロック） 複数のリーフを組み合わせてでき上がった電子機器のことです。通常、リーフをスタックするとブロック状になるので、リーフブロックと呼びます。平面的に広がった構造であっても、リーフを組み合わせて作った電子機器はリーフブロックと呼ばれます。\nLeafony bus（リーフォニー・バス） 複数のリーフ間を相互に接続する共通経路部をLeafonyバスと呼びます。電気信号および電源接続を行うための電気的および物理的な仕様が定義されています。典型的にはリーフの20mm x 5.5mmの領域となります。Leafonyバス準拠のリーフは他のリーフと交信可能になりますが、Leafonyプラットフォームと完全に問題なく繋がるかはソフトウェアなどにもよるため、Leafonyバス準拠というのはあくまでも物理レベルに近いところで接続可能といっているに過ぎません。\nLeafonyバスのアートワークには著作権があり、CC-BYライセンスで公開していますので、商用でもLeafony準拠と明記すれば自由に無償で使用できます。従って、自由に独自のリーフを開発や販売ができます。ただし、Leafonyは登録商標ですので、独自に作ったリーフそのものにはLeafonyとは表示しないでください。Leafonyと表示のあるリーフは製品品質が確かめられていることがわかり、混乱を避けられます。\nLeafony connector（リーフォニー・コネクタ） リーフを相互接続するために新規開発された、異方性導電ゴムを使用したコネクタです。オス・メスを兼ねています。リーフの接続は、ハンダを使った熱圧着技術などでも可能ですが、Leafonyコネクタを使うのが簡便です。\nLEAFONY SYSTEMS Co.,Ltd.（リーフォニー・システムズ 株式会社） トリリオンノード・エンジン・プロジェクトが研究開発したLeafonyを製造、販売する唯一の会社です。LeafにLeafonyを表示しているのはLEAFONY SYSTEMS社のLeafだけです。Leafonyと表示されたLeafは、相互接続などがトリリオンノード・エンジン・プロジェクトによって確認されています。\nLeafonyバス準拠のリーフ、他の企業や個人などから多数販売されますし、そのような活動を推奨していますが、リーフ自体にLeafonyの表示はされません。\nTrillion-node engine(トリリオンノード・エンジン) トリリオンノード・エンジン・プロジェクトで研究開発された、エレクトロニクス・プラットフォームのことです。研究開発が終了したハードウェアやソフトウェアに関して整理した上で、Leafonyという名称で一般公開しています。\nTrillion-node engine project(トリリオンノード・エンジン・プロジェクト) トリリオンノード・エンジン・プロジェクトは、国立研究開発法人新エネルギー・産業技術総合開発機構（ＮＥＤＯ）の委託・助成事業による研究開発プロジェクトです。\nTrillion-node study-group (トリリオンノード研究会) IoT/CPSなど将来非常に多くのITノードが社会で使われるようになると言われています。そのような未来を議論し情報を共有するための研究会です。具体的に考えるベースとして、Leafonyを使っており、IoT/CPSの発展のため、Leafonyの普及に力を入れています。また、ニーズとシーズを持った関連企業をつなぐ場も提供しています。\nハーネス Leafonyブロックと外部との電気的接続には配線が必要な場合があります。そのような配線をハーネスと呼びます。\n","excerpt":"用語の説明（ABC順） IoT/CPS IoTはInternet of Things、CPSはCyber-Physical Systemsの略です。特に、CPSはネットにつながらずとも、リアルな物理的 …","ref":"/docs/terms/","title":"用語の説明"},{"body":"ソフトウェア トリリオンノード・エンジン・プロジェクト、あるいはトリリオンノード研究会が独自に開発し公開したソフトウェアはMITライセンスですので、自由に使用可能です。その他、Leafonyを使用するときに一緒に使う場合のあるライブラリーなどのソフトウェアは、それぞれのコードのライセンス条件になります。ライセンス条件などは、通常それぞれのプログラムコードに記載されています。\nハードウェア Leafony バスの基板レイアウト（アートワーク）には著作権があり、CC-BYライセンスで公開していますので、商用でも「Leafony準拠」と明記すれば、自由に無償で使用できます。従って、自作リーフの開発や販売が自由にできます。その他の部分のアートワークの著作権は主張致しません。\n一方、「Leafony」は、LEAFONY SYSTEMS社の登録商標です。自作リーフには、「Leafony」 の名前を商品名称に付けることは、LEAFONY SYSTEMS社の製品ラインナップと混同する可能性があり、市場が混乱しますので、お控え下さい。\nその他 「Leafony」は、LEAFONY SYSTEMS社の登録商標です。\n","excerpt":"ソフトウェア トリリオンノード・エンジン・プロジェクト、あるいはトリリオンノード研究会が独自に開発し公開したソフトウェアはMITライセンスですので、自由に使用可能です。その他、Leafonyを使用する …","ref":"/docs/license/","title":"ライセンス"},{"body":"\n概要 Basic KitやESP32 Wi-Fi Kitと組み合わせて使える、便利で使い勝手の良い色々なリーフが入っているキットで、より広範な応用を実現できます。Extension Kit には、マイコンリーフが含まれていませんので、ソフトウェアを動かすためにBasic Kitか、ESP32 Wi-Fi Kit が必要です。\n内容物    Type Item Q’ty     AI02 SP \u0026amp; PIR 1   AI03 MIC \u0026amp; VR \u0026amp; LED 1   AI04 LCD 1   AV03 AA BAT 1   AX01 Shield 1   AX03 Leafx2 1   AX04 Spacer 1   AX05 I Meas. 1   AX06 Grove \u0026amp; 5V 1    Caution note 1    リーフ一覧 \rAI02 SP\u0026amp;PIR\r\r圧電スピーカと人感センサを搭載したリーフです。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で物体の接近を検知することが可能です。\n\r \rAI03 MIC\u0026amp;VR\u0026amp;LED\r\rMEMSマイク、ボリューム、LEDを搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n\r \rAI04 LCD\r\rキャラクタLCDユニットとユーザスイッチ2個を搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n\r \rAV03 AA BAT\r\r単3電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。3つのLeafonyコネクタを搭載しより多くのリーフに電源供給が可能です。\n\r \rAX01 Shield\r\rArduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\n\r \rAX03 Leaf x2\r\rリーフを横並びに接続するためのコネクタリーフです。\n\r \rAX04 Spacer\r\r積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\n\r \rAX05 I Meas.\r\r3.3VおよびVBUSに流れる電流を測定するためのリーフです。通常Leafony busは両面とも電気的に接続されていますが、このリーフでは3.3VとVBUSのみ表裏で切断され、それぞれスルーホールに接続されています。\n\r \rAX06 Grove\u0026amp;5V\r\rSeeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\n\r \r変更履歴  Rev A1.0: 2019年8月初版  ","excerpt":"概要 Basic KitやESP32 Wi-Fi Kitと組み合わせて使える、便利で使い勝手の良い色々なリーフが入っているキットで、より広範な応用を実現できます。Extension Kit には、マイ …","ref":"/docs/products/extension/","title":"Extension Kit"},{"body":"Leafonyが届いたらさっそく使ってみましょう！ キットには電源を入れればすぐ使えるアプリがインストールされています。 こちらのページを参考にIoTの世界を体験してみましょう。\n","excerpt":"Leafonyが届いたらさっそく使ってみましょう！ キットには電源を入れればすぐ使えるアプリがインストールされています。 こちらのページを参考にIoTの世界を体験してみましょう。","ref":"/en/docs/getting-started/","title":"Getting Started"},{"body":"製品の技術や応用に関するお問合せは、フォーラムをご利用ください。\n フォーラム  ","excerpt":"製品の技術や応用に関するお問合せは、フォーラムをご利用ください。\n フォーラム  ","ref":"/docs/contacts/","title":"お問い合わせ"},{"body":" 基板の仕組み 基板の設計手順 設計ツール 部品選び 回路設計 レイアウト設計 面付け 製造発注 部品実装 テスト  ","excerpt":" 基板の仕組み 基板の設計手順 設計ツール 部品選び 回路設計 レイアウト設計 面付け 製造発注 部品実装 テスト  ","ref":"/docs/pcb/pcb-tutorial/","title":"基板開発チュートリアル"},{"body":"概要 電源リーフには、電池電圧をモニタするためのADコンバータを実装。温度、湿度、照度、傾きだけでなく、電池電圧も測定し、LCDに表示させます。 温度（または、湿度）の補正の仕方 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。詳しくは、こちら。\n\n使用するリーフ    Type Name Q\u0026rsquo;ty     AI04 LCD 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AZ01 USB 1   AX03 Leaf×2 1   AV01 CR2032 1   AZ62 Connector Cover 2   AZ63 Nut Plate 1    CR2032 coin cell battery 1    M2*15mm screw 4    リーフの組立 ソースコード  書き込みには、4-Sensors、LCD、AVR MCUライブラリ（タイマ割り込み）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、[こちら]。 Arduino IDEで、以下のスケッチをマイコンボードに書き込んでください。  //===================================================================== // Leafony Platform sample sketch // Application : 4-Sensors with LCD // Processor : ATmega328P (3.3V /8MHz) // Arduino IDE : 1.8.13 // // Leaf configuration // (1) AI01 4-Sensors // (2) AI04 LCD // (3) AP01 AVR MCU // (4) AZ01 USB // //\t(c)2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/20 First release // Rev.01 2020/07/29 不要部分削除等体裁修正 //===================================================================== // use libraries // Adafruit Unified Sensor Driver // https://github.com/adafruit/Adafruit_Sensor // Adafruit Bus IO Library // https://github.com/adafruit/Adafruit_BusIO // Adafruit LIS3DH // https://github.com/adafruit/Adafruit_LIS3DH // SmartEverything ST HTS221 Humidity Sensor // https://github.com/ameltech/sme-hts221-library // ClosedCube Arduino Library for ClosedCube OPT3001 // https://github.com/closedcube/ClosedCube_OPT3001_Arduino // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;MsTimer2.h\u0026gt; // Timer#include \u0026lt;Wire.h\u0026gt; // I2C #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; // 3-axis accelerometer#include \u0026lt;HTS221.h\u0026gt; // humidity and temperature sensor#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; // Ambient Light Sensor#include \u0026lt;ST7032.h\u0026gt; // LCD //=====================================================================  //=============================================== // シリアルモニタへの出力 // #define SERIAL_MONITOR = 出力あり //\t//#define SERIAL_MONITOR = 出力なし（コメントアウトする） //=============================================== #define SERIAL_MONITOR  //----------------------------------------------- // IOピン一覧 //----------------------------------------------- // D0 0 // PD0 (RXD) // D1 1 // PD1 (TXD) // D2 2 // PD2 (INT0) // D3 3 // PD3 (INT1) // D4 4 // PD4 // D5 5 // PD5 // D6 6 // PD6 // D7 7 // PD7 // D8 8 // PB0 (S-UART2_RX) // D9 9 // PB1 (S-UART2_TX) // D10 10 // PB2 (SS) // D11 11 // PB3 (MOSI) // D12 12 // PB4 (MISO) // D13 13 // PB5 (SCK/LED)  // D14 14 // [A0] PC0 // D15 15 // [A1] PC1 // D16 16 // [A2] PC2 // D17 17 // [A3] PC3  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- //------------------------------ // I2Cアドレス //------------------------------ #define LIS2DH_ADDRESS 0x19 // Accelerometer (SD0/SA0 pin = VCC) #define OPT3001_ADDRESS 0x45 // Ambient Light Sensor (ADDR pin = VCC) #define LCD_I2C_EXPANDER_ADDR 0x1A // LCD I2C Expander #define BATT_ADC_ADDR 0x50 // Battery ADC  //----------------------------------------------- // loop interval // MsTimer2のタイマー割り込み発生間隔(ms) //----------------------------------------------- #define LOOP_INTERVAL 125 // 125ms interval  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------  ST7032 lcd; //------------------------------ // Sensor //------------------------------ Adafruit_LIS3DH accel = Adafruit_LIS3DH(); ClosedCube_OPT3001 light; //--------------------------------------------------------------------- // プログラムで使用する変数定義 //--------------------------------------------------------------------- //--------------------------- // LCD //--------------------------- int8_t lcdSendCount = 0; //------------------------------ // Loop counter //------------------------------ uint8_t iLoop1s = 0; //------------------------------ // Event //------------------------------ bool event1s = false; //------------------------------ // interval Timer interrupt //------------------------------ volatile bool bInterval = false; //------------------------------ // LIS2DH : Accelerometer //------------------------------ float dataX_g, dataY_g, dataZ_g; float dataTilt; //------------------------------ // HTS221 : Humidity and Temperature sensor //------------------------------ float dataTemp; float dataHumid; //-------------------- // 2点補正用データ //-------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  //------------------------------ // OPT3001 : Ambient Light Sensor //------------------------------ float dataLight; //--------------------------- // Battery //--------------------------- float dataBatt = 0; //===================================================================== // setup //===================================================================== void setup(){ Wire.begin(); // I2C 100kHz #ifdef SERIAL_MONITOR  Serial.begin(115200); // UART 115200bps  Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;setup start\u0026#34;); #endif  i2c_write_byte(LCD_I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(LCD_I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD 電源ON  // LCD設定  lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;NOW\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;BOOTING!\u0026#34;); setupPort(); delay(10); noInterrupts(); setupTCInt(); interrupts(); setupSensor(); MsTimer2::start(); // Timer inverval start  #ifdef SERIAL_MONITOR  Serial.println(\u0026#34;\u0026#34;); Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;loop start\u0026#34;); Serial.println(\u0026#34;\u0026#34;); #endif } //----------------------------------------------- // IOピンの入出力設定 // 接続するリーフに合わせて設定する //----------------------------------------------- void setupPort(){ } //--------------------------------------------------------------------- // 各デバイスの初期設定 //--------------------------------------------------------------------- //------------------------------ // Sensor //------------------------------ void setupSensor(){ //-------------------------------------  // LIS2DH (accelerometer)  //-------------------------------------  accel.begin(LIS2DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  //-------------------------------------  // HTS221 (Humidity and Temperature sensor)  //-------------------------------------  smeHumidity.begin(); //-------------------------------------  // OPT3001 (Ambient Light Sensor)  //-------------------------------------  OPT3001_Config newConfig; OPT3001_ErrorCode errorConfig; light.begin(OPT3001_ADDRESS); // I2C address  newConfig.RangeNumber = B1100; // automatic full scale  newConfig.ConvertionTime = B1; // convertion time = 800ms  newConfig.ModeOfConversionOperation = B11; // continous conversion  newConfig.Latch = B0; // hysteresis-style  errorConfig = light.writeConfig(newConfig); if(errorConfig != NO_ERROR){ errorConfig = light.writeConfig(newConfig); //retry  } } //===================================================================== // 割り込み処理 //===================================================================== //----------------------------------------------- // 割り込み処理初期設定 // Timer interrupt (interval=125ms, int=overflow) // メインループのタイマー割り込み設定 //----------------------------------------------- void setupTCInt(){ MsTimer2::set(LOOP_INTERVAL, intTimer); } //---------------------------------------------- // Timer INT // タイマー割り込み関数 //---------------------------------------------- void intTimer(){ bInterval = true; } //==================================================================== // loop //==================================================================== //--------------------------------------------------------------------- // Main loop //--------------------------------------------------------------------- void loop(){ //-----------------------------------------------------  // Timer interval　125ms で1回ループ  //-----------------------------------------------------  if (bInterval == true){ bInterval = false; //--------------------------------------------  loopCounter(); // loop counter  //--------------------------------------------  // 1sに1回実行する  //--------------------------------------------  if (event1s == true){ event1s = false; // initialize parameter  loopSensor(); // sensor read  dispSencerData(); // LCD  } } } //--------------------------------------------------------------------- // Counter // メインループのループ回数をカウントし // 1秒間隔でセンサーデータの取得をONにする //--------------------------------------------------------------------- void loopCounter(){ iLoop1s += 1; //--------------------  // 1s period  //--------------------  if (iLoop1s \u0026gt;= 8){ // 125ms x 8 = 1s  iLoop1s = 0; event1s = true; } } //--------------------------------------------------------------------- // Sensor // センサーデータ取得がONのとき、各センサーからデータを取得 // コンソール出力がONのときシリアルに測定値と計算結果を出力する //--------------------------------------------------------------------- void loopSensor(){ double temp_mv; //-------------------------  // LIS2DH  // 3軸センサーのデータ取得  //-------------------------  accel.read(); dataX_g = accel.x_g; //X軸  dataY_g = accel.y_g; //Y軸  dataZ_g = accel.z_g; //Z軸  if(dataZ_g \u0026gt;= 1.0){ dataZ_g = 1.00; } else if (dataZ_g \u0026lt;= -1.0){ dataZ_g = -1.00; } dataTilt = acos(dataZ_g)/PI*180; //-------------------------  // HTS221  // 温湿度センサーデータ取得  //-------------------------  dataTemp = (float)smeHumidity.readTemperature(); //温度  dataHumid = (float)smeHumidity.readHumidity(); //湿度  //-------------------------  // 温度と湿度の2点補正  //-------------------------  dataTemp=TM0+(TM1-TM0)*(dataTemp-TL0)/(TL1-TL0); // 温度補正  dataHumid=HM0+(HM1-HM0)*(dataHumid-HL0)/(HL1-HL0); // 湿度補正  //-------------------------  // OPT3001  // 照度センサーデータ取得  //-------------------------  OPT3001 result = light.readResult(); if(result.error == NO_ERROR){ dataLight = result.lux; } //-------------------------  // ADC081C027（ADC)  // 電池リーフ電池電圧取得  //-------------------------  uint8_t adcVal1 = 0; uint8_t adcVal2 = 0; Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); adcVal1 = Wire.read(); adcVal2 = Wire.read(); if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { //測定値がFFならバッテリリーフはつながっていない  adcVal1 = adcVal2 = 0; } //電圧計算　ADC　* （(リファレンス電圧(3.3V)/ ADCの分解能(256)) * 分圧比（２倍））  temp_mv = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; dataBatt = (float)(temp_mv / 1000); //-------------------------  // シリアルモニタ表示  //------------------------- #ifdef SERIAL_MONITOR  Serial.println(\u0026#34;--- sensor data ---\u0026#34;); Serial.println(\u0026#34; Tmp[degC] = \u0026#34; + String(dataTemp)); Serial.println(\u0026#34; Hum[%] = \u0026#34; + String(dataHumid)); Serial.println(\u0026#34; Lum[lx] = \u0026#34; + String(dataLight)); Serial.println(\u0026#34; Ang[arc deg] = \u0026#34; + String(dataTilt)); Serial.println(\u0026#34; Bat[V] = \u0026#34; + String(dataBatt)); #endif } //--------------------------------------- // Disp sensor data // センサーデータを文字列に変換してLCDに表示する //--------------------------------------- void dispSencerData(){ float value; char temp[7], humid[7], light[7], tilt[7], battVolt[7]; char sendData[40]; //-----------------------------------  //センサーデータを文字列に変換  //dtostrf(変換する数字,変換される文字数,小数点以下の桁数,変換した文字の格納先);  //変換される文字数を-にすると変換される文字は左詰め、+なら右詰めとなる  //-----------------------------------  //-------------------------  // Temperature (4Byte)  //-------------------------  value = dataTemp; if(value \u0026gt;= 100){ value = 99.9; } else if(value \u0026lt;= -10){ value = -9.9; } dtostrf(value,4,1,temp); //-------------------------  // Humidity (4Byte)  //-------------------------  value = dataHumid; dtostrf(value,4,1,humid); //-------------------------  // Ambient Light (5Byte)  //-------------------------  value = dataLight; if(value \u0026gt;= 100000){ value = 99999; } dtostrf(value,5,0,light); //-------------------------  // Tilt (4Byte)  //-------------------------  value = dataTilt; if(value \u0026lt; 3){ value = 0; } dtostrf(value,4,0,tilt); //-------------------------  // Battery Voltage (4Byte)  //-------------------------  value = dataBatt; if (value \u0026gt;= 10){ value = 9.99; } dtostrf(value, 4, 2, battVolt); //-------------------------  trim(temp); trim(humid); trim(light); trim(tilt); trim(battVolt); lcd.clear(); switch (lcdSendCount){ case 0: // Tmp XX.X [degC]  lcd.print(\u0026#34;Temp\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(temp) +\u0026#34; C\u0026#34;); break; case 1: // Hum xx.x [%]  lcd.print(\u0026#34;Humidity\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(humid) +\u0026#34; %\u0026#34;); break; case 2: // Lum XXXXX [lx]  lcd.print(\u0026#34;Luminous\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(light) +\u0026#34; lx\u0026#34;); break; case 3: // Ang XXXX [arc deg]  lcd.print(\u0026#34;Angle\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(tilt) +\u0026#34; deg\u0026#34;); break; case 4: // Bat X.XX [V]  lcd.print(\u0026#34;Battery\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(battVolt) +\u0026#34; V\u0026#34;); break; default: break; } if (lcdSendCount \u0026lt; 4){ lcdSendCount++; } else{ lcdSendCount = 0; } } //--------------------------------------- // trim // 文字列配列からSPを削除する //--------------------------------------- void trim(char * data){ int i = 0, j = 0; while (*(data + i) != \u0026#39;\\0\u0026#39;){ if (*(data + i) != \u0026#39; \u0026#39;){ *(data + j) = *(data + i); j++; } i++; } *(data + j) = \u0026#39;\\0\u0026#39;; } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- //I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } 4-Sensors_LCD.ino\n実行結果 温度 → 湿度 → 照度 → 角度 → バッテリ残量の順に液晶の表示が変わります。\n","excerpt":"概要 電源リーフには、電池電圧をモニタするためのADコンバータを実装。温度、湿度、照度、傾きだけでなく、電池電圧も測定し、LCDに表示させます。 温度（または、湿度）の補正の仕方 表示させたい温度（ま …","ref":"/docs/examples/advanced/1_p/exten/4-sensors_lcd/","title":"センサの値をLCDに表示"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/1_p/basic/","title":"Basic Kit"},{"body":"  \n特徴 温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\n性能 温湿度センサ    Item Description     Part number HTS221TR   Relative Temperature range -40～120℃   Temperature accuracy ±0.5°C (15 to +40°C)   Relative humidity range 0 to 100%   Humidity accuracy 3.5% rH (20 to +80% rH)   Interfaces I2C(Address: 0x5F)    照度センサ    Item Description     Part number OPT3001   Measurement range 0.01 lux to 83 k lux   IR Rejects \u0026gt; 99% (typ)   Interfaces I2C(Address: 0x44 or 0x45)    加速度センサ    Item Description     Part number LIS2DHTR   Measurement range ±2g/±4g/±8g/±16g (selectable)   Function 6D/4D orientation detection   Freefall detection    Motion detection    Interfaces I2C(Address: 0x49)    ブロック図 \nピン配置 \nTips ２点間補正 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。詳しくは、こちら。\nサンプルデザイン  温湿度センサ読み取り 照度センサ読み取り 加速度センサ読み取り  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\n性能 温湿度センサ    Item Description     Part number …","ref":"/en/docs/leaf/io/ai01/","title":"AI01 4-Sensors"},{"body":"  \n特徴 温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\n性能 温湿度センサ    Item Description     Part number HTS221TR   Relative Temperature range -40～120℃   Temperature accuracy ±0.5°C (15 to +40°C)   Relative humidity range 0 to 100%   Humidity accuracy 3.5% rH (20 to +80% rH)   Interfaces I2C(Address: 0x5F)    照度センサ    Item Description     Part number OPT3001   Measurement range 0.01 lux to 83 k lux   IR Rejects \u0026gt; 99% (typ)   Interfaces I2C(Address: 0x44 or 0x45)    加速度センサ    Item Description     Part number LIS2DHTR   Measurement range ±2g/±4g/±8g/±16g (selectable)   Function 6D/4D orientation detection   Freefall detection    Motion detection    Interfaces I2C(Address: 0x49)    ブロック図 \nピン配置 \nサンプルアプリ  温湿度センサ読み取り(AVR MCU使用) 照度センサ読み取り(AVR MCU使用) 加速度センサ読み取り(AVR MCU使用) 温湿度センサ読み取り(ESP32 MCU使用) 照度センサ読み取り(ESP32 MCU使用) 加速度センサ読み取り(ESP32 MCU使用) Web Bluetoothを使ったIoTアプリ入門 Google sheetsを使ったIoTサービス入門 センサの値をLCDに表示  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールして利用して下さい\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\n性能 温湿度センサ    Item Description     Part number …","ref":"/docs/leaf/io/ai01/","title":"AI01 4-Sensors"},{"body":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。\n使用するリーフ 以下のリーフを使用します\n送信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV03 CR2032 1   AZ01 USB 1   AZ61 Connector Cover 2   AZ62 Connector Cover 3   [AZ6]3(/docs/leaf/others/az63) Connector Cover 2    AA battery 2    M2*25mm screw 6    #　受信側リーフ\nリーフの組み立て 下図を参考にリーフを組み立ててみましょう。\n","excerpt":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。\n使用するリーフ 以下のリーフを使用します\n送信側リー …","ref":"/en/docs/examples/advanced/extension_kit/4-sensors_lcd/","title":"センサの値をLCDに表示"},{"body":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。　※要変更\n使用するリーフ　※要変更 以下のリーフを使用します\n送信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV03 CR2032 1   AZ01 USB 1   AZ61 Connector Cover 2   AZ62 Connector Cover 3   [AZ6]3(/docs/leaf/others/az63) Connector Cover 2    AA battery 2    M2*25mm screw 6    #　受信側リーフ\nリーフの組み立て　※要変更 下図を参考にリーフを組み立ててみましょう。\n","excerpt":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。　※要変更\n使用するリーフ　※要変更 以下のリー …","ref":"/en/docs/examples/advanced/basic_kit/4-sensors_serial_monitor/","title":"センサの値をシリアルモニタに表示"},{"body":"  \n特徴 ATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。 USB接続する場合はUSB を接続、ICSPを使用する場合はShield を接続します。 Arduino IDE使用時は、ボードをArduino Pro or Pro Mini、プロセッサをATmega328P(3.3V,8MHz)選択。\n性能    Item Description     Part number ATmega328P   Operating voltage 3.3V   Input voltage 1.5-5V   Digital I/O 14   Analog input 6   Flash memory 32 KB   SRAM 2KB   EEPROM 1KB   Clock speed 8MHz    ブロック図 \nピン配置 \nTips  Reset switch\nマイコン、および他のデバイスをリセットする。 LED DS100 pin13によりLED制御する(Arduino UNOと同じ)。\n抵抗R150(1kΩ)を外すことにより、点灯しないように出来る。  サンプルデザイン  LED点滅  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) ブートローダ  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 ATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。 USB接続する場 …","ref":"/en/docs/leaf/processor/ap01/","title":"AP01 AVR MCU"},{"body":"  \n特徴 ATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。 USB接続する場合はUSB を接続、ICSPを使用する場合はShield を接続します。 Arduino IDE使用時は、ボードをArduino Pro or Pro Mini、プロセッサをATmega328P(3.3V,8MHz)選択。\n性能    Item Description     Part number ATmega328P   Operating voltage 3.3V   Input voltage 1.5-5V   Digital I/O 14   Analog input 6   Flash memory 32 KB   SRAM 2KB   EEPROM 1KB   Clock speed 8MHz    ブロック図 \nピン配置 \nTips LED、スイッチについて \n   Item Description     Reset switch Reset microcontroller or other devices   LED Control LED by using pin 13 (Same as Arduino UNO)    サンプルアプリ  LED点滅  Arduinoでの使用方法 本リーフをArduinoで使用するためには、Arduino IDE上でボードの設定が必要です。\n開発環境設定のページで設定方法をご確認下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) ブートローダ  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 ATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。 USB接続する場 …","ref":"/docs/leaf/processor/ap01/","title":"AP01 AVR MCU"},{"body":"","excerpt":"","ref":"/en/docs/examples/advanced/basic_kit/","title":"Basic Kit Examples"},{"body":"Basic Kitを使ったサンプルデザインです。\n","excerpt":"Basic Kitを使ったサンプルデザインです。","ref":"/en/docs/examples/beginner/basic/","title":"Basic Kit Examples"},{"body":"簡単なサンプルの一覧です\n","excerpt":"簡単なサンプルの一覧です","ref":"/en/docs/examples/beginner/","title":"Beginner Examples"},{"body":"簡単なサンプルアプリの一覧です。\n","excerpt":"簡単なサンプルアプリの一覧です。","ref":"/docs/examples/beginner/","title":"Beginner Examples"},{"body":"  \n特徴 Silicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証は、CE、FCC、ISED Canada、TELEC、KC South-Korea、NCC Taiwanを取得（SLICON LABS Module Data Sheet　Revision 1.2)。\n性能    Item Description     Part number BGM11S22F256GA-V2   SoC EFR32BG1 (ARM Cortex-M4)   Bluetooth version 4.2   Frequency range 2400M ~ 2483.5MHz   RX sensitivity -90 dBm @ 1 Mbit/s GFSK   TX power +8dBm以下   RF certification CE, full FCC, ISED Canada, Japan and South-Korea   Flash 256KB   RAM 32KB   Interfaces UART    ブロック図 \nピン配置 \nサンプルアプリ  Simple BLE Characteristic (公開予定) Simple BLE Advertisement (公開予定） Web Bluetooth を使ってセンサの値を表示  Google Sheetsを使ったIoTサービス入門  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールしてご利用下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 Silicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証は、CE、FCC、ISED …","ref":"/docs/leaf/communication/ac02/","title":"AC02 BLE Sugar"},{"body":"\n概要 Leafonyプラットフォーム用のコネクタ10個セットです。\n内容物    Type Item Q’ty     AZ61 Connector 10    一覧 \rAZ61 Connector\r\rLeafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\n\r\r\r変更履歴  Rev A1.0: 2019年8月初版  ","excerpt":"\n概要 Leafonyプラットフォーム用のコネクタ10個セットです。\n内容物    Type Item Q’ty     AZ61 Connector 10    一覧 \rAZ61 Connector …","ref":"/en/docs/products/conn/","title":"Connector"},{"body":"\n概要 Leafonyプラットフォーム用のコネクタ10個セットです。\n内容物    Type Item Q’ty     AZ61 Connector 10    一覧 \rAZ61 Connector\r\rLeafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\n\r\r\r変更履歴  Rev A1.0: 2019年8月初版  ","excerpt":"\n概要 Leafonyプラットフォーム用のコネクタ10個セットです。\n内容物    Type Item Q’ty     AZ61 Connector 10    一覧 \rAZ61 Connector …","ref":"/docs/products/conn/","title":"Connector"},{"body":"これからLeafonyを使った開発を行うために、PCの環境を整えましょう。\n必要なツールやライブラリのインストール方法、Leafonyの組み立て方などはここから学べます。\n","excerpt":"これからLeafonyを使った開発を行うために、PCの環境を整えましょう。\n必要なツールやライブラリのインストール方法、Leafonyの組み立て方などはここから学べます。","ref":"/en/docs/environment/","title":"Exvironment Settings"},{"body":"概要 KiCad向けLeafonyテンプレートプロジェクトを使うとリーフ基板の設計を簡単に行えます。\nテンプレートプロジェクトには下記の項目が設定がされています。\n 2cm x 2cm リーフの外形 Leafony bus フットプリント デザインルール  \nダウンロード 下記のリンクからテンプレートプロジェクトをダウンロードできます。\nGitHub - Leafony/cad-template\n開発環境  KiCad 5.0.0 or later  使い方 新規プロジェクトを作成  KiCadを起動 ファイル -\u0026gt; 新規 -\u0026gt; プロジェクト -\u0026gt; テンプレートからプロジェクトを作成 ユーザーテンプレートタブを選択 テンプレートのパスでダウンロードしたテンプレートプロジェクトから下記パスを参照  \\cad-template-master\\KiCad\\Leafony_Template\rLeafony Leafを選択しOKをクリック  \nプロジェクト名を入力し、任意の場所にプロジェクトを保存  ","excerpt":"概要 KiCad向けLeafonyテンプレートプロジェクトを使うとリーフ基板の設計を簡単に行えます。\nテンプレートプロジェクトには下記の項目が設定がされています。\n 2cm x 2cm リー …","ref":"/en/docs/pcb/kicad/","title":"KiCad テンプレートプロジェクト"},{"body":"概要 KiCad向けLeafonyテンプレートプロジェクトを使うとリーフ基板の設計を簡単に行えます。\nテンプレートプロジェクトには下記の項目が設定がされています。\n 2cm x 2cm リーフの外形 Leafony bus フットプリント デザインルール  \nダウンロード 下記のリンクからテンプレートプロジェクトをダウンロードできます。\nGitHub - Leafony/cad-template\n開発環境  KiCad 5.0.0 or later  使い方 新規プロジェクトを作成  KiCadを起動 ファイル -\u0026gt; 新規 -\u0026gt; プロジェクト -\u0026gt; テンプレートからプロジェクトを作成 ユーザーテンプレートタブを選択 テンプレートのパスでダウンロードしたテンプレートプロジェクトから下記パスを参照  \\cad-template-master\\KiCad\\Leafony_Template\rLeafony Leafを選択しOKをクリック  \nプロジェクト名を入力し、任意の場所にプロジェクトを保存  ","excerpt":"概要 KiCad向けLeafonyテンプレートプロジェクトを使うとリーフ基板の設計を簡単に行えます。\nテンプレートプロジェクトには下記の項目が設定がされています。\n 2cm x 2cm リー …","ref":"/docs/pcb/kicad/","title":"KiCad テンプレートプロジェクト"},{"body":"  \n特徴 EASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。MCUリーフとはUARTで接続されます。\n性能    Item Description     Part Number ES920LRA1   SoC MKL16Z128 (ARM Cortex-M0+)   RF Transceiver SX1276 (SEMTECH)   Frequency range 920.6～928.0MHz   Transmission speed 146bps～22kbps   RX sensitivity -118～-142dBm   TX power Max 13dBm（20mW)   RF certification TELEC   Approximate communication distance (wire antenna) Prospect 5km   Flash 128KB   RAM 32KB   Interfaces UART    ブロック図 \nピン配置 \nサンプルデザイン  作成中  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"特徴 EASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。MCUリーフとはUARTで接続されます。\n性能    Item Description     Part …","ref":"/en/docs/leaf/communication/ac03/","title":"AC03 LoRa Easy"},{"body":"  \n特徴 EASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。MCUリーフとはUARTで接続されます。\n性能    Item Description     Part Number ES920LRA1   SoC MKL16Z128 (ARM Cortex-M0+)   RF Transceiver SX1276 (SEMTECH)   Frequency range 920.6～928.0MHz   Transmission speed 146bps～22kbps   RX sensitivity -118～-142dBm   TX power Max 13dBm（20mW)   RF certification TELEC   Approximate communication distance (wire antenna) Prospect 5km   Flash 128KB   RAM 32KB   Interfaces UART    ブロック図 \nピン配置 \nサンプルアプリ  LoRaを使ってセンサの値を表示(公開予定)  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールしてご利用下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"特徴 EASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。MCUリーフとはUARTで接続されます。\n性能    Item Description     Part …","ref":"/docs/leaf/communication/ac03/","title":"AC03 LoRa Easy"},{"body":"  \n特徴 圧電スピーカと人感センサを搭載したリーフです。圧電スピーカはPWM、人感センサはI2CでMCUリーフと接続されます。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で接近を検知することが出来、接近検知時に割り込み信号を出力することが可能です。\n性能 圧電スピーカ    Item Description     Part number CMT-1203-SMT   dimensions 12 x 12 x 3mm   rated frequency 4kHz(typ)   sound pressure level 81dB(min) at 10 cm, 5 Vp-p, 4,000 Hz square wave   Current consumption 5mA(max) at 5 Vp-p, 4,000 Hz square wave    人感センサ    Item Description     Part number AK9754   Sensor Quantum-type IR Sensor   Interfaces I2C(Address: 0x65 or 0x64)    ブロック図 \nピン配置 \nサンプルデザイン  スピーカ  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 SP\u0026amp;PIR 回路図 PIR 部品配置図 レイアウト図 SP＆PIR (Zuken) レイアウト図 PIR (Zuken) レイアウト図 SP＆PIR (dxf) レイアウト図 PIR (dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 圧電スピーカと人感センサを搭載したリーフです。圧電スピーカはPWM、人感センサはI2CでMCUリーフと接続されます。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で接近を検知すること …","ref":"/en/docs/leaf/io/ai02/","title":"AI02 SP\u0026PIR"},{"body":"  \n特徴 圧電スピーカと人感センサを搭載したリーフです。圧電スピーカはPWM、人感センサはI2CでMCUリーフと接続されます。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で接近を検知することが出来、接近検知時に割り込み信号を出力することが可能です。\n性能 圧電スピーカ    Item Description     Part number CMT-1203-SMT   dimensions 12 x 12 x 3mm   rated frequency 4kHz(typ)   sound pressure level 81dB(min) at 10 cm, 5 Vp-p, 4,000 Hz square wave   Current consumption 5mA(max) at 5 Vp-p, 4,000 Hz square wave    人感センサ    Item Description     Part number AK9754   Sensor Quantum-type IR Sensor   Interfaces I2C(Address: 0x65 or 0x64)    ブロック図 \nピン配置 \nサンプルアプリ  スピーカ(AVR MCU使用) 人感センサ(AVR MCU使用) 人感センサ(ESP32 MCU使用) 人感センサ(ESP32 MCU使用) 人の接近を検知しメロディを鳴らす  ドキュメント  仕様書 回路図 SP\u0026amp;PIR 回路図 PIR 部品配置図 レイアウト図 SP＆PIR (Zuken) レイアウト図 PIR (Zuken) レイアウト図 SP＆PIR (dxf) レイアウト図 PIR (dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 圧電スピーカと人感センサを搭載したリーフです。圧電スピーカはPWM、人感センサはI2CでMCUリーフと接続されます。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で接近を検知すること …","ref":"/docs/leaf/io/ai02/","title":"AI02 SP\u0026PIR"},{"body":"Leafonyが届いたらさっそく使ってみましょう！ キットには電源を入れればすぐ使えるアプリがインストールされています。 こちらのページを参考にIoTの世界を体験してみましょう。\n","excerpt":"Leafonyが届いたらさっそく使ってみましょう！ キットには電源を入れればすぐ使えるアプリがインストールされています。 こちらのページを参考にIoTの世界を体験してみましょう。","ref":"/docs/getting-started/","title":"クイックスタート"},{"body":"概要 CR2032コイン電池リーフに搭載されたADコンバータを使って電池の電圧を読み取りましょう。\nこのサンプルはav03 AA BATリーフや、av04 2V～4.5Vリーフなどの電池リーフでも動作します。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*10mm screw 2    リーフの組み立て0 ソースコード Arduino IDEで下記のプログラムを作成しましょう。\n//===================================================================== // Battery Voltage // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //=====================================================================  #include \u0026lt;Wire.h\u0026gt; const int BATT_ADC_ADDR = 0x50; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize I2C communication at 100kHz:  Wire.begin(); delay(10); } void loop(){ // read ADC registers:  Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); uint8_t adcVal1 = Wire.read(); uint8_t adcVal2 = Wire.read(); // when ADC is not connected, read values are 0xFF:  if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { adcVal1 = adcVal2 = 0; } // voltage mV = adcVal * Vref(3.3V) / resolution(8bit) * Vdiv(2)  double tempMillivolt = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; float dataBatt = (float)(tempMillivolt / 1000); Serial.println(\u0026#34;Batt[V] = \u0026#34; + String(dataBatt)); delay(1000); } Battery_Voltage.ino\n動作 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsすると、電池の電圧が表示されます。\n","excerpt":"概要 CR2032コイン電池リーフに搭載されたADコンバータを使って電池の電圧を読み取りましょう。\nこのサンプルはav03 AA BATリーフや、av04 2V～4.5Vリーフなどの電池リーフでも動作 …","ref":"/en/docs/examples/beginner/basic/read_battery/","title":"バッテリ残量"},{"body":"プロセッサリーフ一覧\n","excerpt":"プロセッサリーフ一覧","ref":"/en/docs/leaf/processor/","title":"プロセッサリーフ"},{"body":"プロセッサリーフ一覧\n","excerpt":"プロセッサリーフ一覧","ref":"/docs/leaf/processor/","title":"プロセッサリーフ"},{"body":"概要 AVR MCUリーフに搭載されたLEDを1秒おきに点灯/消灯させます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // Blink // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //=====================================================================  void setup() { // LEDピンを出力ピンに設定  pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); // LEDを点灯  delay(1000); // 1秒待つ  digitalWrite(LED_BUILTIN, LOW); // LEDを消灯  delay(1000); // 1秒待つ } Blink.ino\n実行結果 AVR MCUリーフに搭載されたLEDが1秒おきに点灯/消灯します。\n","excerpt":"概要 AVR MCUリーフに搭載されたLEDを1秒おきに点灯/消灯させます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 …","ref":"/docs/examples/beginner/1_p/basic/blink/","title":"LED点滅"},{"body":"  \n特徴 Espressif SystemsのXtensa Dual-Core 32-bit LX6 マイクロプロセッサ、技的認証済みWi-FiとBLEを内蔵したESP32-WROOM-32を搭載した32bit MCUリーフである。無線の認証は、 FCC、CE-RED、IC、TELEC、KCC、SRRC、NCCを取得（Espressif Systems Data Sheet V2.9）。 USB電源を供給して、VBUS(5V)電源として使用可能。\n性能    Item Description     Part number ESP32-WROOM-32    SoC ESP32-D0WDQ6 (CPU:Xtensa LX6)   Operating voltage 3.3V   Input voltage 2.2-3.6V   Digital I/O 14   Analog input 6   TouchSensor I/F 6   Flash Memory 4 MB   SRAM 520 KB   Clock frequency 80M-240MHz   Wi-Fi protocols IEEE 802.11b/g/n   Bluetooth protocols Bluetooth v4.2 BR/EDR and BLE specification   RF certification FCC/CE-RED/IC/TELEC/KCC/SRRC/NCC    ブロック図 \nピン配置 \nTips  LED DS700 FT232RQが制御するLEDである。 UART TX通信によるプログラム書き込み時に点滅する。 LED DS701 FT232RQが制御するLEDである。 UART RX通信によるプログラム書き込み時に点滅する。 Reset switch ESP32、および他のデバイスをリセットする。 Boot mode switch ブートモードを変更するためのスイッチである。 スケッチの書き込み方 書き込み中にBoot mode switchを長押しする  サンプルデザイン  Wi-Fi タッチセンサ  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2020年1月初版  ","excerpt":"特徴 Espressif SystemsのXtensa Dual-Core 32-bit LX6 マイクロプロセッサ、技的認証済みWi-FiとBLEを内蔵したESP32-WROOM-32を搭載し …","ref":"/en/docs/leaf/processor/ap02/","title":"AP02 ESP32 MCU"},{"body":"  \n特徴 Espressif SystemsのXtensa Dual-Core 32-bit LX6 マイクロプロセッサ、技的認証済みWi-FiとBLEを内蔵したESP32-WROOM-32を搭載した32bit MCUリーフである。無線の認証は、 FCC、CE-RED、IC、TELEC、KCC、SRRC、NCCを取得（Espressif Systems Data Sheet V2.9）。 USB電源を供給して、VBUS(5V)電源として使用可能。\n性能    Item Description     Part number ESP32-WROOM-32   SoC ESP32-D0WDQ6 (CPU:Xtensa LX6)   Operating voltage 3.3V   Input voltage 2.2-3.6V   Digital I/O 14   Analog input 6   TouchSensor I/F 6   Flash Memory 4 MB   SRAM 520 KB   Clock frequency 80M-240MHz   Wi-Fi protocols IEEE 802.11b/g/n   Bluetooth protocols Bluetooth v4.2 BR/EDR and BLE specification   RF certification FCC/CE-RED/IC/TELEC/KCC/SRRC/NCC    ブロック図 \nピン配置 \nTips LED、スイッチについて \n   Item Description     LED RX FT232RQ controlled LED / Flashes on UART TX data transmission.   LED TX FT232RQ controlled LED / Flashes on UART RX data transmission.   Reset switch Resets the ESP32 and other devices.   Boot mode switch Switch to change to boot mode.Press and hold the boot mode switch while writing a sketch.   micro USB It is used for writing a sketch to the MCU and serial monitoring by connecting a PC.This also converts USB’s VBUS(5V) to 3.3V by using step-down power circuit and provide VBUS and 3.3V to each leaf.   Antenna This is a shared antenna for Bluetooth LE and Wi-Fi.    サンプルアプリ  ボタン入力 Wi-Fi タッチセンサ データ転送 To Google Sheets  Arduinoでの使用方法 本リーフをArduinoで使用するためには、Arduino IDE上でボードの設定が必要です。\n開発環境設定のページで設定方法をご確認下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2020年1月初版  ","excerpt":"特徴 Espressif SystemsのXtensa Dual-Core 32-bit LX6 マイクロプロセッサ、技的認証済みWi-FiとBLEを内蔵したESP32-WROOM-32を搭載し …","ref":"/docs/leaf/processor/ap02/","title":"AP02 ESP32 MCU"},{"body":"\n概要 リーフをねじで固定する時に使用するNut Plate と ACR に付着するゴミを防御するコネクタカバーです。\n内容物    Type Item Q’ty     AZ63 Nut Plate 10   AZ62 Connector Cover 10    一覧 \rAZ63 Nut Plate\r\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n\r\r\rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \r変更履歴  Rev A1.0: 2019年8月初版  ","excerpt":"\n概要 リーフをねじで固定する時に使用するNut Plate と ACR に付着するゴミを防御するコネクタカバーです。\n内容物    Type Item Q’ty     AZ63 Nut Plate …","ref":"/en/docs/products/nut/","title":"Nut Plate \u0026 Connector Cover"},{"body":"\n概要 リーフをねじで固定する時に使用するNut Plate と ACR に付着するゴミを防御するコネクタカバーです。\n内容物    Type Item Q’ty     AZ63 Nut Plate 10   AZ62 Connector Cover 10    一覧 \rAZ63 Nut Plate\r\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n\r\r\rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \r変更履歴  Rev A1.0: 2019年8月初版  ","excerpt":"\n概要 リーフをねじで固定する時に使用するNut Plate と ACR に付着するゴミを防御するコネクタカバーです。\n内容物    Type Item Q’ty     AZ63 Nut Plate …","ref":"/docs/products/nut/","title":"Nut Plate \u0026 Connector Cover"},{"body":"概要 CR2032コイン電池リーフに搭載されたADコンバータを使って電池の電圧を読み取りましょう。\nこのサンプルはAA BATリーフや、2V～4.5Vリーフなどの電池リーフでも動作します。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    リーフの組み立て ソースコード Arduino IDEで下記のプログラムを作成しましょう。\n//===================================================================== // Battery Voltage // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //=====================================================================  #include \u0026lt;Wire.h\u0026gt; const int BATT_ADC_ADDR = 0x50; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize I2C communication at 100kHz:  Wire.begin(); delay(10); } void loop(){ // read ADC registers:  Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); uint8_t adcVal1 = Wire.read(); uint8_t adcVal2 = Wire.read(); // when ADC is not connected, read values are 0xFF:  if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { adcVal1 = adcVal2 = 0; } // voltage mV = adcVal * Vref(3.3V) / resolution(8bit) * Vdiv(2)  double tempMillivolt = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; float dataBatt = (float)(tempMillivolt / 1000); Serial.println(\u0026#34;Batt[V] = \u0026#34; + String(dataBatt)); delay(1000); } Battery_Voltage.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、電池の電圧が表示されます。\n","excerpt":"概要 CR2032コイン電池リーフに搭載されたADコンバータを使って電池の電圧を読み取りましょう。\nこのサンプルはAA BATリーフや、2V～4.5Vリーフなどの電池リーフでも動作します。\n使用する …","ref":"/docs/examples/beginner/1_p/basic/read_battery/","title":"バッテリ電圧読み取り"},{"body":"","excerpt":"","ref":"/en/docs/examples/advanced/","title":"Advanced Examples"},{"body":"上級者向けサンプルアプリの一覧です。\n","excerpt":"上級者向けサンプルアプリの一覧です。","ref":"/docs/examples/advanced/","title":"Advanced Examples"},{"body":"各種Leafを使ったサンプルアプリケーションを紹介します。\n実際に動かして使い方を学んでいきましょう。\nBeginner Examples Basic Kit  LED点滅 バッテリ電圧読み取り 温湿度センサ読み取り 照度センサ読み取り 加速度センサ読み取り  Extension Kit  スピーカ 人感センサ サウンドレベルメータ LCD ディスプレイ リアルタイムクロック microSDカード  Advanced Examples　 Basic Kit  センサの値をシリアルモニタに表示 センサの値をBLEで送信 Web Bluetoothを使ったIoTアプリ入門 Google sheetsを使ったIoTサービス入門  Extension Kit  センサの値をLCDに表示 センサの値をLCDに表示しBLEで送信 人の接近を検知しメロディをならす  ESP32 Wi-Fi  Wi-Fi タッチセンサ  Grove Extention KitのGroveリーフとGroveモジュールで遊べるサンプル\n 超音波センサで距離測定 カメラの撮影  LoRa  LoRaを使ってセンサの値を表示  ","excerpt":"各種Leafを使ったサンプルアプリケーションを紹介します。\n実際に動かして使い方を学んでいきましょう。\nBeginner Examples Basic Kit  LED点滅 バッテリ電圧読み取り 温湿 …","ref":"/en/docs/examples/","title":"Examples"},{"body":"","excerpt":"","ref":"/en/docs/examples/advanced/extension_kit/","title":"Extension Kit Examples"},{"body":"","excerpt":"","ref":"/docs/examples/advanced/1_p/exten/4-sensors_lcd_ble/","title":"センサの値をLCDに表示しBLEで送信(公開予定)"},{"body":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Thermo-hygrometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // 2点補正用データ //--------------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // 温度補正  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // 湿度補正  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } Thermo-Hygrometer.ino\n2点間補正 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。以下は、温度を例に、補正方法を記します。\nまず、４-Sensorsと、基準となる計測器で、２点の温度を測定してください。次に、測定した値を、サンプルスケッチに書き込んで、実行して頂ければ、４-Sensorsの温度が、表示させたい温度に近づきます。　実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、温度と湿度が表示されます。\n","excerpt":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/1_p/basic/temp_humid_sensors/","title":"温湿度センサ読み取り"},{"body":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。※要変更\n使用するリーフ　※要変更 以下のリーフを使用します\n送信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV03 CR2032 1   AZ01 USB 1   AZ61 Connector Cover 2   AZ62 Connector Cover 3   [AZ6]3(/docs/leaf/others/az63) Connector Cover 2    AA battery 2    M2*25mm screw 6    #　受信側リーフ\nリーフの組み立て　※要変更 下図を参考にリーフを組み立ててみましょう。\n","excerpt":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。※要変更\n使用するリーフ　※要変更 以下のリーフを使用します\n …","ref":"/en/docs/examples/advanced/basic_kit/4-sensors_ble/","title":"センサの値をBLEで送信"},{"body":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。※要変更\n使用するリーフ※要変更 以下のリーフを使用します\n送信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV03 CR2032 1   AZ01 USB 1   AZ61 Connector Cover 2   AZ62 Connector Cover 3   [AZ6]3(/docs/leaf/others/az63) Connector Cover 2    AA battery 2    M2*25mm screw 6    #　受信側リーフ\nリーフの組み立て※要変更 下図を参考にリーフを組み立ててみましょう。\n","excerpt":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。※要変更\n使用するリーフ※要変更 以下のリーフを使用します\n送 …","ref":"/en/docs/examples/advanced/extension_kit/4-sensors_lcd_ble/","title":"センサの値をLCDに表示しBLEで送信"},{"body":"  \n特徴 Silicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証は、CE、FCC、ISED Canada、TELEC、KC South-Korea、NCC Taiwanを取得（SLICON LABS Module Data Sheet　Revision 1.2)。\n性能    Item　 Description     Part number BGM11S22F256GA-V2   SoC EFR32BG1 (ARM Cortex-M4)   Bluetooth version 4.2   Frequency range 2400M ~ 2483.5MHz   RX sensitivity -90 dBm @ 1 Mbit/s GFSK   TX power +8dBm以下   RF certification CE, full FCC, ISED Canada, Japan and South-Korea   Flash 256KB   RAM 32KB   Interfaces UART    ブロック図 \nピン配置 \nサンプルデザイン  Web Bluetooth を使ってセンサの値を表示   ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 Silicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証は、CE、FCC、ISED …","ref":"/en/docs/leaf/communication/ac02/","title":"AC02 BLE Sugar"},{"body":"","excerpt":"","ref":"/en/docs/examples/beginner/extension/","title":"Extension Kit Examples"},{"body":"プロセッサ \rAP01 AVR MCU\r\rATmega328Pを使用したリーフです。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。\nBasic Kit\r\r\r\rAP02 ESP32 MCU\r\rEspressif Systemsの、技的認証済みWi-FiとBluetooth LEを内蔵したモジュールESP32-WROOM-32を搭載した32bit MCUリーフです。USB-UART変換ICを搭載し、スケッチの書き込みができます。USBのVBUS(5V)から降圧電源回路により、VBUSと3.3Vを供給します。また、リセットボタンを備えています。\nESP32 Wi-Fi Kit\r\r \r通信 \rAC02 BLE Sugar\r\rSilicon Labsの技的認証済みBluetooth LEモジュールBGM11S22F256GA-V2を搭載したリーフです。\nBasic Kit\r\r\r\rAC03 LoRa Easy\r\rEASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。\n\r \rIO \rAI01 4-Sensors\r\r温湿度センサ、照度センサ、加速度センサを搭載したリーフです。省電力なセンサを搭載し長時間のセンシングに適しています。\nBasic Kit\r\r\r\rAI02 SP\u0026amp;PIR\r\r圧電スピーカと人感センサを搭載したリーフです。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で物体の接近を検知することが可能です。\nExtension Kit\r\r \rAI03 MIC\u0026amp;VR\u0026amp;LED\r\rMEMSマイク、ボリューム、LEDを搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\nExtension Kit\r\r \rAI04 LCD\r\rキャラクタLCDユニットとユーザスイッチ2個を搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\nExtension Kit\r\r \r電源 \rAV01 CR2032\r\rCR2032コイン電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。2cm x 2cmのサイズで3.3Vの電源を供給可能です。\nBasic Kit\r\r\r\rAV02 CR2450\r\rCR2450コイン電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。\n\r \rAV03 AA BAT\r\r単3電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。3つのLeafonyコネクタを搭載しより多くのリーフに電源供給が可能です。\nExtension Kit\r\r \rAV04 2V～4.5V\r\rリチウムイオンバッテリや電池ボックス接続用のJST製SHコネクタと電源スイッチ、電圧モニタ用のADコンバータ、3.3V昇降圧回路を搭載した電源リーフです。2V～4.5Vの電池電圧入力に対応しています。\nESP32 Wi-Fi Kit\r\r \r拡張 \rAX01 Shield\r\rArduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\nExtension Kit\r\r\r\rAX02 29pin\r\rリーフI/Fの29ピン全てを2.54mmピッチのスルーホールに接続したリーフです。\nBasic Kit\r\r \rAX03 Leaf x2\r\rリーフを横並びに接続するためのコネクタリーフです。\nExtension Kit\r\r \rAX04 Spacer\r\r積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\nExtension Kit\r\r \rAX05 I Meas.\r\r3.3VおよびVBUSに流れる電流を測定するためのリーフです。通常Leafony busは両面とも電気的に接続されていますが、このリーフでは3.3VとVBUSのみ表裏で切断され、それぞれスルーホールに接続されています。\nExtension Kit\r\r \rAX06 Grove\u0026amp;5V\r\rSeeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\nExtension Kit\r\r \rAX07 Back to back\r\rリーフを背中合わせに接続可能なコネクタリーフです。\nESP32 Wi-Fi Kit\r\r \rAX08 29pin header\r\rリーフI/Fの29ピン全てを2.54mmピッチのピンヘッダに接続したリーフです。\nESP32 Wi-Fi Kit\r\r \rその他 \rAZ01 USB\r\rAVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\nBasic Kit\r\r\r\rAZ02 RTC\u0026amp;microSD\r\rNXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。microSDカードはSPIでアクセスします。\nESP32 Wi-Fi Kit\r\r \rAZ61 Connector\r\rLeafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\nConnector\r\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\nNut \u0026 Conn. Cover\r\r \rAZ63 Nut Plate\r\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\nNut \u0026 Conn. Cover\r\r \rAZ66 Basic kit case\r\rBasic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\nBasic Kit\r\r ","excerpt":"プロセッサ \rAP01 AVR MCU\r\rATmega328Pを使用したリーフです。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセット …","ref":"/en/docs/leaf/","title":"Leaf Technical Sheets"},{"body":"Beginner Examples 各種リーフを使った初心者向けのサンプルアプリを紹介します。実際に動かして使い方を学んでいきましょう。\nAVR MCU Examples Basic Kit  LED点滅 バッテリ電圧読み取り 温湿度センサ読み取り 照度センサ読み取り 加速度センサ読み取り  Basic Kit＋Extension Kit  スピーカ 人感センサ サウンドレベルメータ LCD  ESP32 MCU Examples ESP32 Wi-Fi Kit  ボタン入力 リアルタイムクロック microSDカード  ESP32 Wi-Fi Kit＋Basic Kit  温湿度センサ読み取り 照度センサ読み取り 加速度センサ読み取り  ESP32 Wi-Fi Kit＋Extension Kit  スピーカ 人感センサ サウンドレベルメータ LCD  Advanced Examples　 各種リーフを使った上級者向けサンプルアプリを紹介します。サンプルアプリを参考に、身近なものをIoT化しましょう。\nAVR MCU Examples Basic Kit  Simple BLE Characteristic (公開予定) Simple BLE Advertising (公開予定) Web Bluetoothを使ったIoTアプリ入門 Google sheetsを使ったIoTサービス入門  Basic Kit＋Extension Kit  センサの値をLCDに表示 センサの値をLCDに表示しBLEで送信(公開予定) 人の接近を検知しメロディをならす 超音波センサで距離測定 カメラの撮影  Basic Kit＋LoRa  LoRaを使ってセンサの値を表示(公開予定)  ESP32 MCU Examples ESP32 Wi-Fi Kit  Wi-Fi タッチセンサ データ転送 To Google Sheets Google SheetsをつかったIoTサービス その1 仕掛中 Google SheetsをつかったIoTサービス その2 仕掛中  ","excerpt":"Beginner Examples 各種リーフを使った初心者向けのサンプルアプリを紹介します。実際に動かして使い方を学んでいきましょう。\nAVR MCU Examples Basic Kit  LED …","ref":"/docs/examples/","title":"サンプルアプリ・応用例"},{"body":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI01 4-Sensors 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n4-Sensors リーフを使うためにはライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Thermo-hygrometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // 2点補正用データ //--------------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // 温度補正  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // 湿度補正  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } Thermo-Hygrometer.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、温度と湿度が表示されます。\n","excerpt":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/en/docs/examples/beginner/basic/temp_humid_sensors/","title":"温湿度センサ読み取り"},{"body":"無線通信リーフ一覧\n","excerpt":"無線通信リーフ一覧","ref":"/en/docs/leaf/communication/","title":"通信"},{"body":"無線通信リーフ一覧\n","excerpt":"無線通信リーフ一覧","ref":"/docs/leaf/communication/","title":"通信"},{"body":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Illuminance meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、照度が表示されます。\n","excerpt":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/1_p/basic/illum_sensor/","title":"照度センサ読み取り"},{"body":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI01 4-Sensors 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n4-Sensors リーフを使うためにはライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください\n//===================================================================== // Illuminance meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、照度が表示されます。\n","excerpt":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/en/docs/examples/beginner/basic/illum_sensor/","title":"照度センサ読み取り"},{"body":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。\n使用するリーフ 以下のリーフを使用します\n送信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AX04 Spacer 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV03 CR2032 1   AZ01 USB 1   AZ61 Connector 2   AZ62 Connector Cover 3   AZ63 Nut Plate 2    AA battery 1    M2*25mm screw 6    受信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AP01 AVR MCU 1   AX03 Leaf x2 1   AZ01 USB 1   AZ62 Connector Cover 2   AZ63 Nut Plate 2    M2*15mm screw 4    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\n送信側 受信側 ","excerpt":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。\n使用するリーフ 以下のリーフを使用します\n送信側リー …","ref":"/docs/examples/advanced/1_p/lora/lora/","title":"LoRaを使ってセンサの値を表示(公開予定)"},{"body":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Accelerometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、加速度と傾きが表示されます。\n","excerpt":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/1_p/basic/accelerometer/","title":"加速度センサ読み取り"},{"body":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。\n使用するリーフ 以下のリーフを使用します\n送信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AX04 Spacer 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV03 CR2032 1   AZ01 USB 1   AZ61 Connector 2   AZ62 Connector Cover 3   AZ63 Nut Plate 2    AA battery 2    M2*25mm screw 6    受信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AP01 AVR MCU 1   AX03 Leaf x2 1   AZ01 USB 1   AZ62 Connector Cover 2   AZ63 Nut Plate 2    M2*15mm screw 4    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nSender Receiver ","excerpt":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。\n使用するリーフ 以下のリーフを使用します\n送信側リー …","ref":"/en/docs/examples/advanced/lora/lora/","title":"LoRaを使ってセンサの値を表示"},{"body":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI01 4-Sensors 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n4-Sensors リーフを使うためにはライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Accelerometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、加速度と傾きが表示されます。\n","excerpt":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/en/docs/examples/beginner/basic/accelerometer/","title":"加速度センサ読み取り"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたらメロディが鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // Leafony Platform sample sketch // Platform : PIR\u0026amp;SP // Processor : ATmega328P (3.3V /8MHz) // Application : PIR with SP Beep // // Leaf configuration // (1) AI02 SP\u0026amp;PIR // (2) AP01 AVR MCU // (3) AZ01 USB // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //===================================================================== // difinition //===================================================================== #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;Arduino.h\u0026gt;#include \u0026lt;Wire.h\u0026gt;#include \u0026#34;pitches.h\u0026#34; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; #define I2C_RECEIVE_BUF_LENGTH 10 unsigned char i2c_receiveBuf[I2C_RECEIVE_BUF_LENGTH]; unsigned char i2c_receiveLenght; //------------------------------ // buzzer output = 5pin //------------------------------ #define BUZZER_OUT 5  byte readReg; double irData; double tempData; char buf[120]; volatile int state = 0; //===================================================================== // setup //===================================================================== void setup() { //pinMode(2, INPUT);  attachInterrupt(0,catchHuman , FALLING ); //人接近検知割り込み  Wire.begin(); Serial.begin( 115200 ); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); } //===================================================================== // Main loop //===================================================================== void loop() { clearI2CReadbuf(); i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_receiveBuf); sprintf(buf, \u0026#34;REG = %02X , %02X , %02X , %02X , %02X , %02X\u0026#34;, i2c_receiveBuf[0], i2c_receiveBuf[1], i2c_receiveBuf[2], i2c_receiveBuf[3], i2c_receiveBuf[4], i2c_receiveBuf[5]); Serial.println(buf); sprintf(buf, \u0026#34;Human detection = %d\u0026#34;, (i2c_receiveBuf[0] \u0026amp; 0x10) \u0026gt;\u0026gt; 4 ); Serial.println(buf); //IRセンサ測定データ  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); //センサ温度  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); if (state == 1){ //------------------------------  // notes in the melody:  //------------------------------  int melody[] = { NOTE_C5, NOTE_C5, NOTE_G5, NOTE_G5, NOTE_A5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_F5, NOTE_E5, NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5 }; //------------------------------  // note durations: 4 = quarter note, 8 = eighth note, etc.:  //------------------------------  int noteDurations[] = { 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 2 }; //----------------------------------------  // iterate over the notes of the melody:  //----------------------------------------  for (int thisNote = 0; thisNote \u0026lt; 14; thisNote++) { //----------------------------------------  // to calculate the note duration, take one second  // divided by the note type.  //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.  //----------------------------------------  int noteDuration = 1000 / noteDurations[thisNote]; tone(BUZZER_OUT, melody[thisNote], noteDuration); //----------------------------------------  // to distinguish the notes, set a minimum time between them.  // the note\u0026#39;s duration + 30% seems to work well:  //----------------------------------------  float pauseBetweenNotes = noteDuration * 1.30; delay(pauseBetweenNotes); //-----------------------  // stop the tone playing:  //-----------------------  noTone(BUZZER_OUT); } state = 0; } delay(1000); } //===================================================================== void catchHuman(){ state = 1; Serial.println(\u0026#34;!! Interrupt !!\u0026#34;); //人の接近を検知 } //===================================================================== double clacTemp(){ double ret; unsigned short val = (unsigned short)((i2c_receiveBuf[4] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } //===================================================================== double clacIR(){ double ret; unsigned short val = (unsigned short)((i2c_receiveBuf[2] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C スレーブデバイスに1バイト書き込む **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから1バイト読み込む **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C スレーブデバイスに複数バイト書き込む **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから複数バイト読み込む **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C 受信バッファクリア **********************************************/ void clearI2CReadbuf(){ memcpy(i2c_receiveBuf, 0x00, I2C_RECEIVE_BUF_LENGTH); } PIR_Melody_test.ino\n実行結果 人が近づくとメロディが鳴ります。\n","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたらメロディが鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使 …","ref":"/docs/examples/advanced/1_p/exten/pir_melody_test/","title":"人の接近を検知しメロディを鳴らす"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/1_p/exten/","title":"Basic Kit + Extension Kit"},{"body":"","excerpt":"","ref":"/en/docs/examples/advanced/esp32/","title":"ESP32 Wi-Fi Kit Examples"},{"body":"IOリーフ一覧\n","excerpt":"IOリーフ一覧","ref":"/en/docs/leaf/io/","title":"IO"},{"body":"IOリーフ一覧\n","excerpt":"IOリーフ一覧","ref":"/docs/leaf/io/","title":"IO"},{"body":"基板CAD用テンプレートプロジェクト Leafonyの基板設計には各種回路CAD向けのテンプレートプロジェクトを用いると便利です。\n KiCad  I2Cアドレスマップ Leafonyキットには、I2C通信を使用しているリーフがいくつか存在します。\n同じI2Cピンを使用して複数のICと通信する場合、原則として同じI2Cアドレスを使用することはできません。\n自作基板でI2C通信を使用する場合は、アドレスが重複しないように設計して下さい。\nすでに使用されているアドレスは下表のとおりです。\n\r\r\rType\rLeaf\rDescription\rChip\rI2Cアドレス\r\r\r\r\rAI01\r4-Sensors\r温湿度センサ\rHTS221TR\r0x5F\r-\r-\r\r照度センサ\rOPT3001\r0x45\r0x44\r-\r\r\r加速度センサ\rLIS3DHTR\r0x19\r-\r-\r\r\rAI02\rSP\u0026PIR\rPIR\rAK9754\r0x65\r0x66\r-\r\r\rAI03\rMIC\u0026VR\u0026LED\rIOエキスパンダ\rPCA9557RGVR\r0x1B\r-\r-\r\r\rAI04\rLCD\rLCD\rAQM0802A-RN-GBW\r0x3E\r-\r-\r\rIOエキスパンダ\rPCA9557RGVR\r0x1A\r0x1E\r-\r\r\rAV01-AV04\rBAT\rADC\rADC081C027CIMK\r0x50\r0x51\r0x52\r\r\rAV05\rSolar\rADC\rADC081C027CIMK\r0x52\r0x50\r0x51\r\r\rAV06\rGrove\rIOエキスパンダ\rPCA9557RGVR\r0x18\r-\r-\r\r\rAZ02\rSD\u0026RTC\rリアルタイムクロック\rChip\r0x68\r-\r-\r\r\r\rLeafony bus ピンレイアウト \n基板製造チュートリアル ","excerpt":"基板CAD用テンプレートプロジェクト Leafonyの基板設計には各種回路CAD向けのテンプレートプロジェクトを用いると便利です。\n KiCad  I2Cアドレスマップ Leafonyキットに …","ref":"/en/docs/pcb/","title":"PCB"},{"body":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。※要変更\n使用するリーフ 以下のリーフを使用します※要変更\n送信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV03 CR2032 1   AZ01 USB 1   AZ61 Connector Cover 2   AZ62 Connector Cover 3   [AZ6]3(/docs/leaf/others/az63) Connector Cover 2    AA battery 2    M2*25mm screw 6    #　受信側リーフ\nリーフの組み立て※要変更 下図を参考にリーフを組み立ててみましょう。\n","excerpt":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。※要変更\n使用するリーフ 以下のリーフを使用します※要変更\n送 …","ref":"/en/docs/examples/advanced/extension_kit/pir_melody_test/","title":"人の接近を検知しメロディを鳴らす"},{"body":"このサンプルはBasic Kit スタートガイドで紹介したものと同様です。ソースコードを読みながら、動作を理解していきましょう。\nはじめに Leafonyは省電力で小型なIoTデバイスの開発を簡単に行えるように、それぞれのリーフが省電力な設計になっています。 バッテリで長時間動作するため、様々な場所に設置してセンサで定点観測を行うことも可能です。\nでは、センサで測定した温度や湿度、照度のようなデータはどのようにして集められるのでしょうか。 一般的にWi-FiやBluetooth、LoRaといった無線通信が用いられるでしょう。 Leafonyでは無線通信規格の中でも省電力なBluetoothを搭載したリーフが存在します。\nBasic Kitは省電力なセンサを複数搭載した4-Sensorリーフと、省電力なBluetooth規格であるBluetooth LE (以下、BLE)を搭載したBLEリーフを使った長時間バッテリ駆動のIoTセンサの開発を簡単に行えるキットです。\nそれでは、Leafonyが送るBLEを受信するためにはどうすれば良いでしょうか。 PCやスマホ・タブレットには色々な環境があります。Windowsが動くPC、MacOSが動くPC、Android、iPhoneなど、身近なものでも非常に沢山の環境が存在します。 これらの環境でBluetoothを使うためには、それぞれの環境に合わせたプログラミング言語で開発するのが普通です。PCであればC言語やPythonなどの言語を使って開発できますが、AndroidやiPhoneであれば、Android StudioやXcode等を使ってまた別のプログラミング言語でソフトを作る必要があります。\n多くの人が様々な環境で使うものを簡単に開発するにはどうすれば良いでしょうか。 今回のサンプルアプリでは一つの方法として、Bluetoothの通信を行いデータを画面に表示するためにWebブラウザを使うことにしました。\n使用する言語はHTMLとJava Scriptです。この2つの言語で記述したプログラムが、Webブラウザ上であればどの環境においても同様に動作します。\nポイント\r Web Bluetoothライブラリを使うと、Bluetooth接続するソフトをWebアプリで記述できる。 Webアプリであればブラウザが動く機器であれば同じソースコードが動く。 表やグラフ等のGUIはHTMLとCSSでラクラク開発  \r用意するもの  Leafony Basic Kit Windows1、 Mac2、 Linux3のどれかのPC (開発用) Android4、 iPhone5、 iPad5のスマートフォンまたはタブレット (テスト用 なくても良い) Google Chrome (バージョン70.0.3526.0以降) Arduino IDE  サンプルアプリのソースコード あらかじめどちらもダウンロードしてください。\n Arduino スケッチ Web Bluetooth アプリ  Leafonyの構成 このサンプルでは下記のリーフ構成で試せます。\n   Type Name Q\u0026rsquo;ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    実行方法  Arduino IDEで4-Sensors_BLE.inoを書き込む ダウンロードしたWeb Bluetooth アプリのindex.htmlをGoogle Chromeで開く\nWebアプリの使い方の詳細はBasic Kit クイックスタートガイドを参考  データの送信 BLEでデータを送受信する方法を見てみましょう。\nLeafony側 4-Sensors_BLE.inoの1020行目付近でBluetoothで送信するテキストデータを生成しています。 このテキストを変えることで任意のデータを送信可能です。\nsendLen = sprintf(sendData, \u0026#34;%04s,%04s,%04s,%04s,%04s,%01s\\n\u0026#34;, temp, humid, light, tilt, battVolt, pips) 上記では\u0026lt;温度\u0026gt;,\u0026lt;湿度\u0026gt;,\u0026lt;照度\u0026gt;,\u0026lt;傾き\u0026gt;,\u0026lt;電池電圧\u0026gt;,\u0026lt;サイコロ\u0026gt;のようにカンマ区切りのデータを送信しています。\n実際にこのテキストデータを送信しているのは下記の部分です。(1085行目付近)\nble112.ble_cmd_gatt_server_send_characteristic_notification( 1, 0x000C, sendLen, (const uint8 *)sendData ); Webアプリ側 Webアプリ側ではleafony.jsにデータ受信時の処理が書かれています。\nleafony.jsの75行目の記述で、データを受信した時に呼び出される関数を指定します。 ここではhandleData()という関数が呼び出されます。\nchar.read.addEventListener( \u0026#39;characteristicvaluechanged\u0026#39;, handleData ); handleData()関数もleafony.jsに記述されています。\nBLEで受信したデータはevent.target.valueに含まれています。\n一旦dataという変数に値をコピーした後に、受信データをutf-8でデコードし、改行コード(\\r\\n)を取り除いてから、カンマ,で区切って配列にしています。\nこれらのデータはstateという変数に任意の名前をつけて保存しています。(state.tempやstate.humidなど)\nLeafony側で送るデータを変更した際は、handleData()関数を修正することでデコードすることが可能です。\n/** * Characteristicの値が変化した時に呼び出される関数 * @param {*} event */ function handleData( event ) { // 受信したデータの文字コードを変換して、カンマでデータを分けている  // このサンプルではLeafonyは  // 温度,湿度,傾き,電池の電圧  // のようにカンマ区切りのテキストを送信している。  let data = event.target.value; let decoder = new TextDecoder( \u0026#39;utf-8\u0026#39; ); data = decoder.decode( data ); data = data.replace( /\\r?\\n/g, \u0026#39;\u0026#39; ); data = data.split( \u0026#39;,\u0026#39; ); state.devn = deviceName; state.unin = uniqueName; state.temp = data[0]; state.humd = data[1]; state.illm = data[2]; state.tilt = data[3]; state.batt = data[4]; state.dice = data[5]; // ここで updateTable() が実行されている  onStateChangeCallback( state ); // 省略  } データの受信 Webアプリ側 Webアプリの画面で「LED+」「LED-」ボタンを押すと、LeafonyのLEDの点滅スピードを変えることができます。\nボタン押された時の処理はapp.jsの下記の部分に記述されています。\nbuttonLedPls.addEventListener ( \u0026#39;click\u0026#39;, function () { console.log( \u0026#39;LED Plus Button Clicked\u0026#39; ); leafony.sendCommand( \u0026#39;PLS\u0026#39; ); }); leafony.sendCommand( '文字列' );で任意の文字列をLeafonyに送信しています。\nLeafony側 Webアプリ側から送信された文字列をLeafonyが受信したとき、4-Sensors.inoのmy_evt_gatt_server_attribute_value()関数が呼び出されます。\nデコードされた文字列はrcv_dataという変数にコピーされ、その文字列の内容に応じた処理をしています。\nvoid my_evt_gatt_server_attribute_value( const struct ble_msg_gatt_server_attribute_value_evt_t *msg ) { uint16 attribute = (uint16)msg -\u0026gt; attribute; uint16 offset = 0; uint8 value_len = msg -\u0026gt; value.len; uint8 value_data[20]; String rcv_data; rcv_data = \u0026#34;\u0026#34;; for (uint8_t i = 0; i \u0026lt; value_len; i++) { rcv_data += (char)(msg -\u0026gt; value.data[i]); } // 中略  if( rcv_data.indexOf(\u0026#34;SND\u0026#34;) == 0 ){ bBLEsendData = true; iToggle = 8; } else if( rcv_data.indexOf(\u0026#34;STP\u0026#34;) == 0 ){ bBLEsendData = false; bLCDchange = true; lcd_view_sts = 1; } else if(rcv_data.indexOf(\u0026#34;PLS\u0026#34;) == 0){ if(iToggle \u0026lt; 16){ iToggle += 2; } } else if(rcv_data.indexOf(\u0026#34;MNS\u0026#34;) == 0){ if(iToggle \u0026gt; 2){ iToggle -= 2; } } } 上記の部分を修正することで簡単にデータの送受信を行うことができます。\n仕組み  PeripheralとCentral アドバタイズ GATT Characteristic  Webアプリ側 index.htmlとapp.jsとleafony.jsの3つのファイルで構成されています。\nindex.htmlはボタンや表の配置を行ったり、他2つのjavascriptのファイルを読み込むだけの単純なものです。\napp.jsはボタンが押されたときの処理などメインの処理が記述されています。\nleafony.jsはWeb Bluetoothを使ってLeafonyと接続するための具体的な処理がかかれています。\nWeb Bluetoothの注意点 2020年6月時点ではWeb Bluetoothは以下の点に注意しなければいけません。\n iPhoneのChromeでは動作しません。WebBLEという有料のアプリを使えば利用可能です。 Web Bluetoothの開発状況と対応ブラウザについてはimplementation-status.mdで確認できます。  参考 https://qiita.com/s_nkg/items/bdb235388eaeb567b54d\n  Windows 10 version 1703以降 \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite以降 \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow以降 \u0026#x21a9;\u0026#xfe0e;\n iPhoneまたはiPadの場合は WebBLE(有料)が必要です。iPhone、iPad版のChromeではWeb Bluetoothが実装されていないためです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"このサンプルはBasic Kit スタートガイドで紹介したものと同様です。ソースコードを読みながら、動作を理解していきましょう。\nはじめに Leafonyは省電力で小型なIoTデバイスの開発を簡単に行 …","ref":"/en/docs/examples/advanced/basic_kit/webbluetooth_iot/","title":"Web BluetoothをつかったIoTアプリ入門"},{"body":"これからLeafonyを使った開発を行うために、PCの環境を整えましょう。\n必要なツールやライブラリのインストール方法、Leafonyの組み立て方などはここから学べます。\n","excerpt":"これからLeafonyを使った開発を行うために、PCの環境を整えましょう。\n必要なツールやライブラリのインストール方法、Leafonyの組み立て方などはここから学べます。","ref":"/docs/environment/","title":"開発環境設定"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AI02 SP\u0026amp;PIR 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduinoを開き、ファイル → スケッチ例 → 02.Digital → toneMelodyを開いてください。\nこのサンプルコードでは、スピーカが8番ピンに接続されている事になっています。\nしかし、Leafonyではスピーカが5番ピンに接続されているので、下記の部分を修正して正しいピン接続になるようにしましょう。\n 37行目の8を5に変更  tone(5, melody[thisNote], noteDuration);\r 44行目の8を5に変更  noTone(5);\r実行結果 スピーカーから一度だけメロディが鳴ります。\n","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/1_p/exten/speaker/","title":"スピーカ"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // Human Sensing // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/16 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; // 人を検出したら呼び出される関数 void onHumanDetected() { Serial.println(\u0026#34;Detect!\u0026#34;); tone(5, 262, 300); // ビープ音を鳴らす } void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with AK9754AE:  Wire.begin(); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); //人接近検知割り込み  attachInterrupt(0, onHumanDetected, FALLING ); } void loop() { // バッファをクリア  clearI2CReadbuf(); // レジスタ読み出し  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); //IRセンサ  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); //センサ温度  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); delay(1000); } double clacTemp() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } double clacIR() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C スレーブデバイスに1バイト書き込む **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから1バイト読み込む **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C スレーブデバイスに複数バイト書き込む **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから複数バイト読み込む **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C 受信バッファクリア **********************************************/ void clearI2CReadbuf(){ memcpy(i2c_recvBuf, 0x00, I2C_RECV_BUF_LENGTH); } Human_Sensing.ino\n実行結果 人が近づくと音が鳴ります。\n","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用しま …","ref":"/docs/examples/beginner/1_p/exten/ir_sensor/","title":"人感センサ"},{"body":"  \n特徴 MEMSマイク、ボリューム、LEDを搭載したリーフです。MEMSマイクとボリュームはアナログ入力ピン、LEDはデジタル出力ピンでMCUリーフと接続されます。低消費電力を実現するのためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n性能 マイク    Item Description     Part number SPW2430HR5H-B   Type MEMS   Direction Omnidirectional   Frequency range 100Hz ～ 10kHz   Gain 0dB   Interfaces Analog    ボリューム    Item Description     Part number ST-4ETA10kΩ   Nominal resistance 10kΩ   Resistance law Linear law (B)   Effective electrical angle 210° (1 turn)    LED    Item Description     Part number SML-A12Y8TT86   Package type Side-view   Emitting color Yellow    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1B)    ブロック図 \nピン配置 \nTips  Microphone MK500 Volume VR500 LED DS500-505  サンプルデザイン  サウンドレベルメータ  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 MEMSマイク、ボリューム、LEDを搭載したリーフです。MEMSマイクとボリュームはアナログ入力ピン、LEDはデジタル出力ピンでMCUリーフと接続されます。低消費電力を実現するのためI2C …","ref":"/en/docs/leaf/io/ai03/","title":"AI03 MIC\u0026VR\u0026LED"},{"body":"  \n特徴 MEMSマイク、ボリューム、LEDを搭載したリーフです。MEMSマイクとボリュームはアナログ入力ピン、LEDはデジタル出力ピンでMCUリーフと接続されます。低消費電力を実現するのためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n性能 マイク    Item Description     Part number SPW2430HR5H-B   Type MEMS   Direction Omnidirectional   Frequency range 100Hz ～ 10kHz   Gain 0dB   Interfaces Analog    ボリューム    Item Description     Part number ST-4ETA10kΩ   Nominal resistance 10kΩ   Resistance law Linear law (B)   Effective electrical angle 210° (1 turn)    LED    Item Description     Part number SML-A12Y8TT86   Package type Side-view   Emitting color Yellow    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1B)    ブロック図 \nピン配置 \nTips マイクロフォン、ボリューム、LEDについて \n   Item     Microphone MK500   Volume VR500   LED    サンプルアプリ  サウンドレベルメータ(AVR MCU使用) サウンドレベルメータ(ESP32 MCU使用)  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 MEMSマイク、ボリューム、LEDを搭載したリーフです。MEMSマイクとボリュームはアナログ入力ピン、LEDはデジタル出力ピンでMCUリーフと接続されます。低消費電力を実現するのためI2C …","ref":"/docs/leaf/io/ai03/","title":"AI03 MIC\u0026VR\u0026LED"},{"body":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI03 MIC\u0026amp;VR\u0026amp;LED 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nMIC\u0026amp;VR\u0026amp;LEDリーフを使うためにはライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください\n//===================================================================== // Sound level meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/17 First release //===================================================================== #define AVR_LED 13 #define LED1 6 #define LED2 7 #define LED3 8 #define LED4 9 #define LED5 10 #define LED6 11  #define MIC 16 #define VR 17  unsigned int dataVR; unsigned int dataMic; //----------------------------------------------- // VRとMICデータを取得する //----------------------------------------------- void getSensorData() { dataVR = analogRead(A3); dataMic = analogRead(A2); Serial.println(\u0026#34;---------------------\u0026#34;); Serial.print(\u0026#34;MIC = \u0026#34;); Serial.println(dataMic,DEC); Serial.print(\u0026#34;VR = \u0026#34;); Serial.println(dataVR,DEC); } //----------------------------------------------- // VRとMICの値にあわせてLEDを点灯、消灯させる //----------------------------------------------- void dispSensorData() { if (dataVR \u0026lt; 400) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 400 \u0026amp;\u0026amp; dataVR \u0026lt; 800) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 800 \u0026amp;\u0026amp; dataVR \u0026lt; 900) { digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else { digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; 700) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= 700 \u0026amp;\u0026amp; dataMic \u0026lt; 800) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= 800 \u0026amp;\u0026amp; dataMic \u0026lt; 850) { digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else { digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup() { Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(AVR_LED, OUTPUT); digitalWrite(AVR_LED, LOW); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); //起動テスト(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); } void loop() { getSensorData(); dispSensorData(); delay(100); } Sound_Level_Meter.ino\n実行結果 ボリュームを回転させると回転量に応じた数のLEDが点灯します。マイクにより周囲の音量に応じた数のLEDが点灯します。\n","excerpt":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type …","ref":"/docs/examples/beginner/1_p/exten/sound_level/","title":"サウンドレベルメータ"},{"body":"  \n特徴 キャラクタLCDユニットとスイッチ2個を搭載したリーフです。LCDユニットはI2CでMCUリーフと接続されます。スイッチはMCUのデジタル入力ピンとI2C ExpanderのP1ピンに接続されています。 低消費電力化を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n性能 LCD    Item Description     Part number AQM0802A-RN-GBW   Display format 8x2 Character   Viewing area (WxH) 27x10.5mm   Dot size (WxH) 0.45x0.5mm   Dot pitch (WxH) 0.5x0.55mm   Character size (WxH) 2.45x4.35mm   Character pitch (WxH) 2.95x4.9mm   Viewing direction 6:00 O\u0026rsquo;Clock   Driving method 1/16Duty,1/5Bias   Controller IC ST7032I-0D(Sitronix) or compatible   Display mode STN (Gray)/Positive/Reflective   Interfaces I2C (Address: 0x3E)    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1A or 0x1E)    ブロック図 \nピン配置 \nTips  Switch1 S440\npin2に接続されている。 Switch2 S441\nI2C ExpanderのP1に接続されている。  サンプルデザイン  LCD ディスプレイ  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 キャラクタLCDユニットとスイッチ2個を搭載したリーフです。LCDユニットはI2CでMCUリーフと接続されます。スイッチはMCUのデジタル入力ピンとI2C ExpanderのP1ピンに接続されて …","ref":"/en/docs/leaf/io/ai04/","title":"AI04 LCD"},{"body":"  \n特徴 キャラクタLCDユニットとスイッチ2個を搭載したリーフです。LCDユニットはI2CでMCUリーフと接続されます。スイッチはMCUのデジタル入力ピンとI2C ExpanderのP1ピンに接続されています。 低消費電力化を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n性能 LCD    Item Description     Part number AQM0802A-RN-GBW   Display format 8x2 Character   Viewing area (WxH) 27x10.5mm   Dot size (WxH) 0.45x0.5mm   Dot pitch (WxH) 0.5x0.55mm   Character size (WxH) 2.45x4.35mm   Character pitch (WxH) 2.95x4.9mm   Viewing direction 6:00 O\u0026rsquo;Clock   Driving method 1/16Duty,1/5Bias   Controller IC ST7032I-0D(Sitronix) or compatible   Display mode STN (Gray)/Positive/Reflective   Interfaces I2C (Address: 0x3E)    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1A or 0x1E)    ブロック図 \nピン配置 \nTips スイッチについて \n   Item Description     Switch1 Connected to pin 2   Switch2 Connected to I2C Expander P1 pin    サンプルアプリ  LCD(AVR MCU使用) LCD(ESP32 MCU使用) センサの値をLCDに表示 超音波センサで距離測定  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールしてご利用下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 キャラクタLCDユニットとスイッチ2個を搭載したリーフです。LCDユニットはI2CでMCUリーフと接続されます。スイッチはMCUのデジタル入力ピンとI2C ExpanderのP1ピンに接続されて …","ref":"/docs/leaf/io/ai04/","title":"AI04 LCD"},{"body":"概要 LCD(液晶ディスプレイ)リーフを使用すると、文字列を簡単に画面に表示することができます。\nまた、ボタンスイッチが2個搭載されていて、コントローラとして使うこともできます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI04 LCD 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : ATmega328P (3.3V /8MHz) // // Leaf configuration // (1) AI04 LCD // (2) AP01 AVR MCU // (3) AZ01 USB // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== // use libraries // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IOピンの名前定義 // 接続するリーフに合わせて定義する //----------------------------------------------- #define SW1 2 // PD2 (INT0)  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8文字, 2行  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8文字, 2行  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop(){ char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- //I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } LED-SW_test.ino\n実行結果 LCDに下記の順で画面が表示されます。\n 「Hello」の文字列 カーソルの移動 ボタンの入力状態表示  ","excerpt":"概要 LCD(液晶ディスプレイ)リーフを使用すると、文字列を簡単に画面に表示することができます。\nまた、ボタンスイッチが2個搭載されていて、コントローラとして使うこともできます。\n使用するリー …","ref":"/docs/examples/beginner/1_p/exten/lcd/","title":"LCD"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/2_p/esp32/","title":"ESP32 Wi-Fi Kit"},{"body":"  \n特徴 CR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能 電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips  Switch\n3.3vの電源をOn,Offするスイッチ。  サンプルデザイン  バッテリ電圧読み取り  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 CR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電 …","ref":"/en/docs/leaf/power/av01/","title":"AV01 CR2032"},{"body":"  \n特徴 CR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能 電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips スイッチについて \n   Item Description     Switch Switch for turning on and off the 3.3v power    サンプルアプリ  バッテリ電圧読み取り  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 CR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電 …","ref":"/docs/leaf/power/av01/","title":"AV01 CR2032"},{"body":"概要 Leafony Beacon1)とRaspberry Piとを使ってIoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\n Beaconとは、地上にある電波を特定の機器で受信することで、位置をはじめとした各種情報を取得するための設備です。BluetoothのBeacon機器の場合、温度や気圧などのセンサを搭載したモジュールを任意の場所に設置して、その場所の環境を観測します。  用意するもの  Leafony Basic Kit Raspberry Pi (3, 4, zero等) ブラウザが閲覧できるPCやスマホ Arduino IDE  サンプルアプリのコード  Github - Leafony/leafony-beacon  Raspberry Piの準備  Raspberry Pi 初めての方は、Raspberry Pi 3 B＋ スターターキット（ https://www.switch-science.com/catalog/3880/ ）が便利です。Raspbian OSイメージを書き込んだmicroSDが入っていますが、ディスプレイ、キーボード、マウスは有りません。別途　ご用意してください。 Raspberry Pi は、無線LANでインターネットに接続します。こちらも事前にご用意してください。  Leafonyの構成    Type Name Q\u0026rsquo;ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Leafonyの組み立て スケッチの書き込み  書き込みには、BLE、4-Sensorsライブラリが必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで、以下のスケッチをマイコンボードに書き込んでください。 ・leafony_beacon.ino Arduino IDE 1.8.9で動作を確認しています。書き込みエラーが発生したら、IDEのバージョンを確認してください。  Raspberry Piの環境構築 BLE Beaconの受信機にはRaspberry Piを使います。今回使用するサンプルコードでは、Node.jsでnobleを使ってBLE Beaconを受信します。受信したデータはGoogle API経由でGoogle スプレッドシートに書き込んでいます。\n下記のスクリプト(6項目)を実行して環境構築をします。https://github.com/Leafony/leafony-beacon/tree/master/spreadsheet-logger\nsudo apt update sudo apt upgrade sudo apt install -y bluetooth libbluetooth-dev libudev-dev git git clone https://github.com/Leafony/leafony-beacon cd leafony-beacon/spreadsheet-logger npm install 注意:WARNINGと表示されますが、このまま進んでください。\nGoogle Sheets APIの取得 Google スプレットシートをNode.jsで操作するためにはAPIを取得する必要があります。まず、下記 Node.js Quick Start のStep.1で、 Enable the Google Sheets API をクリックし、credentials.jsonをダウンロードします。次に、credentials.jsonをleafony-beacon/spreadsheet-loggerディレクトリにコピーしてください。\nNode.js Quickstart | Sheets API | Google Developers : https://developers.google.com/sheets/api/quickstart/nodejs\nindex.js へGoogle SheetsのIDとシート名の設定 Google スプレッドシート を開いて、URLの赤線部分の「シートID」と「シート名」を確認します。\nleafony-beacon/spreadsheet-loggerディレクトリ「index.js」があります。「index.js」の18, 19行目にある「spreadsheetId」と「sheetName」に、上記の「シートID」と「シート名」を貼り付けることで、データが書き込まれます。\nアプリの実行 Raspberry piのターミナルに「sudo node .」と入力してEnterをクリックしてください。\n上記URLにブラウザでアクセスすると、Googleアカウントに移動し、ご自身のアカウントを選択します。\n「詳細」をクリックしてください。\n「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。\n「詳細」をクリックしてください。\n「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。\n「許可」をクリックしてください。以下のコードをコピーしてください。ターミナル内に貼り付けると、「token.json」というファイルが生成されたあとに、beaconのスキャンが始まります。\nBeaconが見つかるとログが表示されると同時に、スプレッドシートに同じ内容が追記されるので、スプレッドシートを開いてデータを確認してください。\n","excerpt":"概要 Leafony Beacon1)とRaspberry Piとを使ってIoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\n Beaconとは、地上にある電 …","ref":"/en/docs/examples/advanced/basic_kit/google_sheets_iot/","title":"Google SheetsをつかったIoTサービス入門"},{"body":"","excerpt":"","ref":"/en/docs/examples/advanced/grove/","title":"Grove Examples"},{"body":"Leafonyブロックを組み立てるときの注意点について、まとめています。\nネジのしめ方 導通不良を避けるため、ネジを交互に、きちんとしめて下さい。\n\nコネクタの取り付け・取り外し リーフ基板にコネクタを取り付ける、または、外す場合は下図のように行ってください。\n\u0026ndash; 取り付け\n\u0026ndash; 取り外し\nコネクタが汚れたとき コネクタや基板の接点に汚れが付着すると、接続不良が生じることがあります。その場合、無水エタノールを含ませた紙製ウエスで軽く拭いてください。それでも改善しない場合は、コネクタを交換してください。\n\n","excerpt":"Leafonyブロックを組み立てるときの注意点について、まとめています。\nネジのしめ方 導通不良を避けるため、ネジを交互に、きちんとしめて下さい。\n\nコネクタの取り付け・取り外し リーフ基板にコネクタ …","ref":"/docs/assembly/","title":"Leafonyブロック組立"},{"body":"電源リーフ一覧\n","excerpt":"電源リーフ一覧","ref":"/en/docs/leaf/power/","title":"電源リーフ"},{"body":"電源リーフ一覧\n","excerpt":"電源リーフ一覧","ref":"/docs/leaf/power/","title":"電源リーフ"},{"body":"概要 ESP32 MCUリーフに搭載されたBoot mode スイッチの状態をシリアルモニタに表示させます。\n\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1    ソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // Button // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/07/02 First release //=====================================================================  int pushButton = 0; void setup() { Serial.begin(115200); pinMode(pushButton, INPUT); } void loop() { int buttonState = digitalRead(pushButton); Serial.println(buttonState); delay(1000); } ESP32_Button.ino\n実行結果 Boot mode スイッチを押すと、シリアルモニタの表示が、１から０に変わります。\n\n","excerpt":"概要 ESP32 MCUリーフに搭載されたBoot mode スイッチの状態をシリアルモニタに表示させます。\n\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/2_p/esp32/button/","title":"ボタン入力"},{"body":"  \n特徴 CR2450コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能　 電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips  Switch\n3.3vの電源をOn,Offするスイッチ。  サンプルデザイン  バッテリ電圧読み取り  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"特徴 CR2450コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電 …","ref":"/en/docs/leaf/power/av02/","title":"AV02 CR2450"},{"body":"  \n特徴 CR2450コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能　 電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips スイッチについて \n   Item Description     Switch Switch for turning on and off the 3.3v power    サンプルアプリ  バッテリ電圧読み取り  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ","excerpt":"特徴 CR2450コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電 …","ref":"/docs/leaf/power/av02/","title":"AV02 CR2450"},{"body":"基板CAD用テンプレートプロジェクト Leafonyの基板設計には各種回路CAD向けのテンプレートプロジェクトを用いると便利です。\n KiCad  I2Cアドレスマップ Leafonyキットには、I2C通信を使用しているリーフがいくつか存在します。\n同じI2Cピンを使用して複数のICと通信する場合、原則として同じI2Cアドレスを使用することはできません。\n自作基板でI2C通信を使用する場合は、アドレスが重複しないように設計して下さい。\nすでに使用されているアドレスは下表のとおりです。\n\r\r\rType\rLeaf\rDescription\rChip\rI2Cアドレス\r変更可能アドレス\r\r\r\r\rAI01\r4-Sensors\r温湿度センサ\rHTS221TR\r0x5F\r-\r-\r\r照度センサ\rOPT3001\r0x45\r0x44\r-\r\r\r加速度センサ\rLIS3DHTR\r0x19\r-\r-\r\r\rAI02\rSP\u0026PIR\rPIR\rAK9754\r0x65\r0x66\r-\r\r\rAI03\rMIC\u0026VR\u0026LED\rIOエキスパンダ\rPCA9557RGVR\r0x1B\r-\r-\r\r\rAI04\rLCD\rLCD\rAQM0802A-RN-GBW\r0x3E\r-\r-\r\rIOエキスパンダ\rPCA9557RGVR\r0x1A\r0x1E\r-\r\r\rAV01-AV04\rBAT\rADC\rADC081C027CIMK\r0x50\r0x51\r0x52\r\r\rAV05\rSolar\rADC\rADC081C027CIMK\r0x52\r0x50\r0x51\r\r\rAV06\rGrove\rIOエキスパンダ\rPCA9557RGVR\r0x18\r-\r-\r\r\rAZ02\rSD\u0026RTC\rリアルタイムクロック\rPCF8523TK\r0x68\r-\r-\r\r\r\rLeafony bus ピンレイアウト \n基板製造チュートリアル ","excerpt":"基板CAD用テンプレートプロジェクト Leafonyの基板設計には各種回路CAD向けのテンプレートプロジェクトを用いると便利です。\n KiCad  I2Cアドレスマップ Leafonyキットに …","ref":"/docs/pcb/","title":"自作リーフ開発"},{"body":"概要 時刻がパソコンのシリアルモニタに表示されます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AP02 ESP32 MCU 1   AZ02 RTC\u0026amp;microSD 1   AZ63 Nut Plate 1    M2*15mm screw 2    リーフの組立 ソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n  Arduino IDEで、「ファイル」→「スケッチ例」→「RTClib」→「pcf8523」で、マイコンボードに書き込んでください。\n  低消費電力設定のため、87行を追加してください。\n  // Date and time functions using a PCF8523 RTC connected via I2C and Wire lib #include \u0026#34;RTClib.h\u0026#34; RTC_PCF8523 rtc; char daysOfTheWeek[7][12] = {\u0026#34;Sunday\u0026#34;, \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34;}; void setup () { Serial.begin(115200); #ifndef ESP8266  while (!Serial); // wait for serial port to connect. Needed for native USB #endif  if (! rtc.begin()) { Serial.println(\u0026#34;Couldn\u0026#39;t find RTC\u0026#34;); Serial.flush(); abort(); } if (! rtc.initialized() || rtc.lostPower()) { Serial.println(\u0026#34;RTC is NOT initialized, let\u0026#39;s set the time!\u0026#34;); // When time needs to be set on a new device, or after a power loss, the  // following line sets the RTC to the date \u0026amp; time this sketch was compiled  rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); // This line sets the RTC with an explicit date \u0026amp; time, for example to set  // January 21, 2014 at 3am you would call:  // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));  //  // Note: allow 2 seconds after inserting battery or applying external power  // without battery before calling adjust(). This gives the PCF8523\u0026#39;s  // crystal oscillator time to stabilize. If you call adjust() very quickly  // after the RTC is powered, lostPower() may still return true.  } // When time needs to be re-set on a previously configured device, the  // following line sets the RTC to the date \u0026amp; time this sketch was compiled  // rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));  // This line sets the RTC with an explicit date \u0026amp; time, for example to set  // January 21, 2014 at 3am you would call:  // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));  // When the RTC was stopped and stays connected to the battery, it has  // to be restarted by clearing the STOP bit. Let\u0026#39;s do this to ensure  // the RTC is running.  rtc.start(); rtc.writeSqwPinMode(PCF8523_OFF); // 低消費電力化  } void loop () { DateTime now = rtc.now(); Serial.print(now.year(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(now.month(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(now.day(), DEC); Serial.print(\u0026#34; (\u0026#34;); Serial.print(daysOfTheWeek[now.dayOfTheWeek()]); Serial.print(\u0026#34;) \u0026#34;); Serial.print(now.hour(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(now.minute(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(now.second(), DEC); Serial.println(); Serial.print(\u0026#34; since midnight 1/1/1970 = \u0026#34;); Serial.print(now.unixtime()); Serial.print(\u0026#34;s = \u0026#34;); Serial.print(now.unixtime() / 86400L); Serial.println(\u0026#34;d\u0026#34;); // calculate a date which is 7 days, 12 hours and 30 seconds into the future  DateTime future (now + TimeSpan(7,12,30,6)); Serial.print(\u0026#34; now + 7d + 12h + 30m + 6s: \u0026#34;); Serial.print(future.year(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(future.month(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(future.day(), DEC); Serial.print(\u0026#39; \u0026#39;); Serial.print(future.hour(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(future.minute(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(future.second(), DEC); Serial.println(); Serial.println(); delay(3000); } 時刻の設定 コンパイルした時間が書き込まれます。 電源がなくなる等でRTCが初期化されると、コンパイルした時間に初期化されます。\n実行結果 シリアルモニタを起動すると、時刻が表示されます。 ","excerpt":"概要 時刻がパソコンのシリアルモニタに表示されます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AP02 ESP32 …","ref":"/docs/examples/beginner/2_p/esp32/rtc/","title":"リアルタイムクロック"},{"body":"  \n特徴 単3電池ホルダを実装し、1.5Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能 電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips  Switch\n3.3vの電源をOn,Offするスイッチ。  サンプルデザイン  バッテリ電圧読み取り  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 単3電池ホルダを実装し、1.5Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモ …","ref":"/en/docs/leaf/power/av03/","title":"AV03 AA BAT"},{"body":"  \n特徴 単3電池ホルダを実装し、1.5Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能 電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips スイッチについて \n   Item Description     Switch Switch for turning on and off the 3.3v power    サンプルデザイン  バッテリ電圧読み取り  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 単3電池ホルダを実装し、1.5Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモ …","ref":"/docs/leaf/power/av03/","title":"AV03 AA BAT"},{"body":"Leafony バスとは、複数のリーフ間を相互に接続する共通経路部の名称です。電気信号および電源接続を行うための電気的および物理的な仕様（20mm x 5.5mm）が定義されています。\n20mmx5.5mmの基板外形寸法 基板は、厚さt=0.8で、パッド部分は、金めっきです。基板レイアウトのデータは、AX02 29pin を参照して下さい。\n","excerpt":"Leafony バスとは、複数のリーフ間を相互に接続する共通経路部の名称です。電気信号および電源接続を行うための電気的および物理的な仕様（20mm x 5.5mm）が定義されています。 …","ref":"/docs/leafony-bus/","title":"Leafony バス"},{"body":"概要 microSD カードの情報が、パソコンのシリアルモニタに表示されます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AP02 ESP32 MCU 1   AZ02 RTC\u0026amp;microSD 1   AZ63 Nut Plate 1    M2*15mm screw 2    リーフの組立 ソースコード  Arduino IDEで、「ファイル」→「スケッチ例」→「SD(esp32)」→「SD_Test」で、マイコンボードに書き込んでください。  /* * Connect the SD card to the following pins: * * SD Card | ESP32 * D2 - * D3 SS * CMD MOSI * VSS GND * VDD 3.3V * CLK SCK * VSS GND * D0 MISO * D1 - */ #include \u0026#34;FS.h\u0026#34;#include \u0026#34;SD.h\u0026#34;#include \u0026#34;SPI.h\u0026#34; void listDir(fs::FS \u0026amp;fs, const char * dirname, uint8_t levels){ Serial.printf(\u0026#34;Listing directory: %s\\n\u0026#34;, dirname); File root = fs.open(dirname); if(!root){ Serial.println(\u0026#34;Failed to open directory\u0026#34;); return; } if(!root.isDirectory()){ Serial.println(\u0026#34;Not a directory\u0026#34;); return; } File file = root.openNextFile(); while(file){ if(file.isDirectory()){ Serial.print(\u0026#34; DIR : \u0026#34;); Serial.println(file.name()); if(levels){ listDir(fs, file.name(), levels -1); } } else { Serial.print(\u0026#34; FILE: \u0026#34;); Serial.print(file.name()); Serial.print(\u0026#34; SIZE: \u0026#34;); Serial.println(file.size()); } file = root.openNextFile(); } } void createDir(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Creating Dir: %s\\n\u0026#34;, path); if(fs.mkdir(path)){ Serial.println(\u0026#34;Dir created\u0026#34;); } else { Serial.println(\u0026#34;mkdir failed\u0026#34;); } } void removeDir(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Removing Dir: %s\\n\u0026#34;, path); if(fs.rmdir(path)){ Serial.println(\u0026#34;Dir removed\u0026#34;); } else { Serial.println(\u0026#34;rmdir failed\u0026#34;); } } void readFile(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Reading file: %s\\n\u0026#34;, path); File file = fs.open(path); if(!file){ Serial.println(\u0026#34;Failed to open file for reading\u0026#34;); return; } Serial.print(\u0026#34;Read from file: \u0026#34;); while(file.available()){ Serial.write(file.read()); } file.close(); } void writeFile(fs::FS \u0026amp;fs, const char * path, const char * message){ Serial.printf(\u0026#34;Writing file: %s\\n\u0026#34;, path); File file = fs.open(path, FILE_WRITE); if(!file){ Serial.println(\u0026#34;Failed to open file for writing\u0026#34;); return; } if(file.print(message)){ Serial.println(\u0026#34;File written\u0026#34;); } else { Serial.println(\u0026#34;Write failed\u0026#34;); } file.close(); } void appendFile(fs::FS \u0026amp;fs, const char * path, const char * message){ Serial.printf(\u0026#34;Appending to file: %s\\n\u0026#34;, path); File file = fs.open(path, FILE_APPEND); if(!file){ Serial.println(\u0026#34;Failed to open file for appending\u0026#34;); return; } if(file.print(message)){ Serial.println(\u0026#34;Message appended\u0026#34;); } else { Serial.println(\u0026#34;Append failed\u0026#34;); } file.close(); } void renameFile(fs::FS \u0026amp;fs, const char * path1, const char * path2){ Serial.printf(\u0026#34;Renaming file %s to %s\\n\u0026#34;, path1, path2); if (fs.rename(path1, path2)) { Serial.println(\u0026#34;File renamed\u0026#34;); } else { Serial.println(\u0026#34;Rename failed\u0026#34;); } } void deleteFile(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Deleting file: %s\\n\u0026#34;, path); if(fs.remove(path)){ Serial.println(\u0026#34;File deleted\u0026#34;); } else { Serial.println(\u0026#34;Delete failed\u0026#34;); } } void testFileIO(fs::FS \u0026amp;fs, const char * path){ File file = fs.open(path); static uint8_t buf[512]; size_t len = 0; uint32_t start = millis(); uint32_t end = start; if(file){ len = file.size(); size_t flen = len; start = millis(); while(len){ size_t toRead = len; if(toRead \u0026gt; 512){ toRead = 512; } file.read(buf, toRead); len -= toRead; } end = millis() - start; Serial.printf(\u0026#34;%u bytes read for %u ms\\n\u0026#34;, flen, end); file.close(); } else { Serial.println(\u0026#34;Failed to open file for reading\u0026#34;); } file = fs.open(path, FILE_WRITE); if(!file){ Serial.println(\u0026#34;Failed to open file for writing\u0026#34;); return; } size_t i; start = millis(); for(i=0; i\u0026lt;2048; i++){ file.write(buf, 512); } end = millis() - start; Serial.printf(\u0026#34;%u bytes written for %u ms\\n\u0026#34;, 2048 * 512, end); file.close(); } void setup(){ Serial.begin(115200); if(!SD.begin()){ Serial.println(\u0026#34;Card Mount Failed\u0026#34;); return; } uint8_t cardType = SD.cardType(); if(cardType == CARD_NONE){ Serial.println(\u0026#34;No SD card attached\u0026#34;); return; } Serial.print(\u0026#34;SD Card Type: \u0026#34;); if(cardType == CARD_MMC){ Serial.println(\u0026#34;MMC\u0026#34;); } else if(cardType == CARD_SD){ Serial.println(\u0026#34;SDSC\u0026#34;); } else if(cardType == CARD_SDHC){ Serial.println(\u0026#34;SDHC\u0026#34;); } else { Serial.println(\u0026#34;UNKNOWN\u0026#34;); } uint64_t cardSize = SD.cardSize() / (1024 * 1024); Serial.printf(\u0026#34;SD Card Size: %lluMB\\n\u0026#34;, cardSize); listDir(SD, \u0026#34;/\u0026#34;, 0); createDir(SD, \u0026#34;/mydir\u0026#34;); listDir(SD, \u0026#34;/\u0026#34;, 0); removeDir(SD, \u0026#34;/mydir\u0026#34;); listDir(SD, \u0026#34;/\u0026#34;, 2); writeFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;Hello \u0026#34;); appendFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;World!\\n\u0026#34;); readFile(SD, \u0026#34;/hello.txt\u0026#34;); deleteFile(SD, \u0026#34;/foo.txt\u0026#34;); renameFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;/foo.txt\u0026#34;); readFile(SD, \u0026#34;/foo.txt\u0026#34;); testFileIO(SD, \u0026#34;/test.txt\u0026#34;); Serial.printf(\u0026#34;Total space: %lluMB\\n\u0026#34;, SD.totalBytes() / (1024 * 1024)); Serial.printf(\u0026#34;Used space: %lluMB\\n\u0026#34;, SD.usedBytes() / (1024 * 1024)); } void loop(){ } 実行結果 microSD カードの情報が、パソコンのシリアルモニタに表示されます。\n","excerpt":"概要 microSD カードの情報が、パソコンのシリアルモニタに表示されます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1 …","ref":"/docs/examples/beginner/2_p/esp32/microsd/","title":"micro SD"},{"body":"  \n特徴 JST製SHコネクタを実装し、2～4.5Vの電池電圧を昇降圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニターするためのADコンバータを実装しています。 SHコネクタに接続可能な電池は乾電池2～3本またはLi-Po、Li-ION電池を想定しています。\n性能　 電源    Item Description     Part number RP604K331B-TR   Battery voltage 1.8～5.5V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA (when step down)   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips  Switch\n3.3vの電源をOn,Offするスイッチ。  サンプルデザイン  バッテリ電圧読み取り  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図(表面) 部品配置図(裏面) レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2020年1月初版  ","excerpt":"特徴 JST製SHコネクタを実装し、2～4.5Vの電池電圧を昇降圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、 …","ref":"/en/docs/leaf/power/av04/","title":"AV04A 2V～4.5V"},{"body":"  \n特徴 JST製SHコネクタを実装し、2～4.5Vの電池電圧を昇降圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニターするためのADコンバータを実装しています。 SHコネクタに接続可能な電池は乾電池2～3本またはLi-Po、Li-ION電池を想定しています。\n性能　 電源    Item Description     Part number RP604K331B-TR   Battery voltage 1.8～5.5V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA (when step down)   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips スイッチ、コネクタについて \n   Item Description     Switch Switch for turning on and off the 3.3v power   Connector JST SH connector    サンプルアプリ  バッテリ電圧読み取り  ドキュメント  仕様書 回路図 部品配置図(表面) 部品配置図(裏面) レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2020年1月初版  ","excerpt":"特徴 JST製SHコネクタを実装し、2～4.5Vの電池電圧を昇降圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、 …","ref":"/docs/leaf/power/av04/","title":"AV04 2V～4.5V"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/2_p/basic/","title":"ESP32 Wi-Fi Kit + Basic Kit"},{"body":"Leafony bus の仕様 Leafony busは、複数のリーフが電気信号および電源接続を行う共通経路部。リーフの相互接続を可能にするために、Leafony busは、リーフの20mm x 5.5mm領域の電気的及び、物理的な仕様が定められています。\nコネクタ形状 基板の厚さは、t=0.8。パッド部分は、金めっき。レイアウト図のデータは（dxf、、KiCad、EAGLE)は、az02 29pin を参照願います。\nLeafony bus のライセンスについて Leafony busのアートワークの著作者は、LEAFONY SYSTEMS 社です。ライセンスは、 表示 4.0 国際(CC BY 4.0) で、提供されています。なお、著作権表示や無保証を参照する表示は、ありません。Leafony bus以外は、LEAFONY SYSTEMS社は、著作権を主張することはありません。\nLeafony busのアートワークをコピーして、使用する場合は、「この製品の一部は、LEAFONY SYSTEMSによるLeafony busのアートワークを利用しています。」と表示をお願いします。\nLeafony bus 準拠のオリジナルリーフを制作する場合 Leafony は、LEAFONY SYSTEMS社の商標です。 オリジナルのリーフを作成する場合は、他のリーフとの互換性を確保するため、Leafony busの電気的・物理的仕様に合致させてください。合致させたものは、「Leafony bus 準拠」と表示して頂いても結構です。勿論、商業的にも自由に無償で使えますが、商品名称に、Leafony の名前を付けることは、LEAFONY SYSTEMS社の製品ラインナップと混同してしまうので、控えて下さい。\n","excerpt":"Leafony bus の仕様 Leafony busは、複数のリーフが電気信号および電源接続を行う共通経路部。リーフの相互接続を可能にするために、Leafony busは、リーフの20mm x …","ref":"/en/docs/license/","title":"License Terms"},{"body":"","excerpt":"","ref":"/en/docs/examples/advanced/lora/","title":"LoRa Example"},{"body":"  \n特徴 Arduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\nブロック図 \nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"  \n特徴 Arduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\nブロック図 \nドキュメント  仕様書 回路図 部品配置図 レイアウト …","ref":"/en/docs/leaf/extension/ax01/","title":"AX01 Shield"},{"body":"  \n特徴 Arduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\nブロック図 \nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"  \n特徴 Arduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\nブロック図 \nドキュメント  仕様書 回路図 部品配置図 レイアウト …","ref":"/docs/leaf/extension/ax01/","title":"AX01 Shield"},{"body":"プロセッサ \rAP01 AVR MCU\r\rATmega328Pを使用したリーフです。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。\nBasic Kit\r\r\r\rAP02 ESP32 MCU\r\rEspressif Systemsの、技的認証済みWi-FiとBluetooth LEを内蔵したモジュールESP32-WROOM-32を搭載した32bit MCUリーフです。USB-UART変換ICを搭載し、スケッチの書き込みができます。USBのVBUS(5V)から降圧電源回路により、VBUSと3.3Vを供給します。また、リセットボタンを備えています。\nESP32 Wi-Fi Kit\r\r \r通信 \rAC02 BLE Sugar\r\rSilicon Labsの技的認証済みBluetooth LEモジュールBGM11S22F256GA-V2を搭載したリーフです。\nBasic Kit\r\r\r\rAC03 LoRa Easy\r\rEASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。\n\r \rIO \rAI01 4-Sensors\r\r温湿度センサ、照度センサ、加速度センサを搭載したリーフです。省電力なセンサを搭載し長時間のセンシングに適しています。\nBasic Kit\r\r\r\rAI02 SP\u0026amp;PIR\r\r圧電スピーカと人感センサを搭載したリーフです。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で物体の接近を検知することが可能です。\nExtension Kit\r\r \rAI03 MIC\u0026amp;VR\u0026amp;LED\r\rMEMSマイク、ボリューム、LEDを搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\nExtension Kit\r\r \rAI04 LCD\r\rキャラクタLCDユニットとユーザスイッチ2個を搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\nExtension Kit\r\r \r電源 \rAV01 CR2032\r\rCR2032コイン電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。2cm x 2cmのサイズで3.3Vの電源を供給可能です。\nBasic Kit\r\r\r\rAV02 CR2450\r\rCR2450コイン電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。\n\r \rAV03 AA BAT\r\r単3電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。3つのLeafonyコネクタを搭載しより多くのリーフに電源供給が可能です。\nExtension Kit\r\r \rAV04 2V～4.5V\r\rリチウムイオンバッテリや電池ボックス接続用のJST製SHコネクタと電源スイッチ、電圧モニタ用のADコンバータ、3.3V昇降圧回路を搭載した電源リーフです。2V～4.5Vの電池電圧入力に対応しています。\nESP32 Wi-Fi Kit\r\r \r拡張 \rAX01 Shield\r\rArduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\nExtension Kit\r\r\r\rAX02 29pin\r\rリーフI/Fの29ピン全てを2.54mmピッチのスルーホールに接続したリーフです。\nBasic Kit\r\r \rAX03 Leaf x2\r\rリーフを横並びに接続するためのコネクタリーフです。\nExtension Kit\r\r \rAX04 Spacer\r\r積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\nExtension Kit\r\r \rAX05 I Meas.\r\r3.3VおよびVBUSに流れる電流を測定するためのリーフです。通常Leafony busは両面とも電気的に接続されていますが、このリーフでは3.3VとVBUSのみ表裏で切断され、それぞれスルーホールに接続されています。\nExtension Kit\r\r \rAX06 Grove\u0026amp;5V\r\rSeeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\nExtension Kit\r\r \rAX07 Back to back\r\rリーフを背中合わせに接続可能なコネクタリーフです。\nESP32 Wi-Fi Kit\r\r \rAX08 29pin header\r\rリーフI/Fの29ピン全てを2.54mmピッチのピンヘッダに接続したリーフです。\nESP32 Wi-Fi Kit\r\r \rその他 \rAZ01 USB\r\rAVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\nBasic Kit\r\r\r\rAZ02 RTC\u0026amp;microSD\r\rNXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。microSDカードはSPIでアクセスします。\nESP32 Wi-Fi Kit\r\r \rAZ61 Connector\r\rLeafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\nConnector\r\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\nNut \u0026 Conn. Cover\r\r \rAZ63 Nut Plate\r\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\nNut \u0026 Conn. Cover\r\r \rAZ66 Basic kit case\r\rBasic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\nBasic Kit\r\r ","excerpt":"プロセッサ \rAP01 AVR MCU\r\rATmega328Pを使用したリーフです。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセット …","ref":"/docs/leaf/","title":"リーフ技術資料"},{"body":"拡張リーフ一覧\n","excerpt":"拡張リーフ一覧","ref":"/en/docs/leaf/extension/","title":"拡張リーフ"},{"body":"拡張リーフ一覧\n","excerpt":"拡張リーフ一覧","ref":"/docs/leaf/extension/","title":"拡張リーフ"},{"body":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Thermo-hygrometer ESP32 // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/07/28 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // 2点補正用データ //--------------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  void setup() { // initialize serial communication at 115200 bit per second:  Serial.begin(115200); // I2C 初期化  pinMode(21, OUTPUT); // SDA  digitalWrite(21, 0); Wire.begin(); // I2C 100kHz  // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // 温度補正  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // 湿度補正  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } ESP32_Thermo-Hygrometer.ino\n2点間補正 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。以下は、温度を例に、補正方法を記します。\nまず、４-Sensorsと、基準となる計測器で、２点の温度を測定してください。次に、測定した値を、サンプルスケッチに書き込んで、実行して頂ければ、４-Sensorsの温度が、表示させたい温度に近づきます。　実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、温度と湿度が表示されます。\n","excerpt":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/2_p/basic/temp_humid_sensors/","title":"温湿度センサ読み取り"},{"body":"  \n特徴 リーフI/Fの29ピン全てをスルーホールに接続したリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ※個人の方が、多く利用しているKiCadとEAGLEのデータをご用意しました。Zuken のCADデータを変換して作成したので、変換ミスの可能性をぬぐいきれません。各自で、寸法等十分確認の上、ご使用ください。\n レイアウト図(KiCad) レイアウト図(EAGLE)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"  \n特徴 リーフI/Fの29ピン全てをスルーホールに接続したリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  ※個人の方が、多く利用して …","ref":"/en/docs/leaf/extension/ax02/","title":"AX02 29 pin"},{"body":"  \n特徴 リーフI/Fの29ピン全てをスルーホールに接続したリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) レイアウト図(KiCad) 1 レイアウト図(EAGLE) 1  変更履歴  Rev A: 2019年8月初版    個人の方が、多く利用しているKiCadとEAGLEのデータをご用意しました。Zuken のCADデータを変換して作成したので、変換ミスの可能性をぬぐいきれません。各自で、寸法等十分確認の上、ご使用ください。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"  \n特徴 リーフI/Fの29ピン全てをスルーホールに接続したリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) レイアウト図(KiCad) …","ref":"/docs/leaf/extension/ax02/","title":"AX02 29 pin"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AI02 SP\u0026amp;PIR 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduinoを開き、ファイル → スケッチ例 → 02.Digital → toneMelodyを開いてください。\nこのサンプルコードでは、スピーカが8番ピンに接続されている事になっています。\nしかし、Leafonyではスピーカが5番ピンに接続されているので、下記の部分を修正して正しいピン接続になるようにしましょう。\n 37行目の8を5に変更  tone(5, melody[thisNote], noteDuration);\r 44行目の8を5に変更  noTone(5);\r実行結果 スピーカーから一度だけメロディが鳴ります。\n","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty …","ref":"/en/docs/examples/beginner/extension/speaker/","title":"スピーカ"},{"body":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Illuminance meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、照度が表示されます。\n","excerpt":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/2_p/basic/illum_sensor/","title":"照度センサ読み取り"},{"body":"  \n特徴 全てのリーフI/F端子を接続したリーフを横に接続するためのリーフです\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"  \n特徴 全てのリーフI/F端子を接続したリーフを横に接続するためのリーフです\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev …","ref":"/en/docs/leaf/extension/ax03/","title":"AX03 Leaf x2"},{"body":"  \n特徴 全てのリーフI/F端子を接続したリーフを横に接続するためのリーフです\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"  \n特徴 全てのリーフI/F端子を接続したリーフを横に接続するためのリーフです\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev …","ref":"/docs/leaf/extension/ax03/","title":"AX03 Leaf x2"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。 磁石付きのLeafonyケースに入れると、玄関などにくっつけて使えます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI02 SP\u0026amp;PIR 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n ビープ音の場合  //===================================================================== // Human Sensing // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/16 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; // 人を検出したら呼び出される関数 void onHumanDetected() { Serial.println(\u0026#34;Detect!\u0026#34;); tone(5, 262, 300); // ビープ音を鳴らす } void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with AK9754AE:  Wire.begin(); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); //人接近検知割り込み  attachInterrupt(0, onHumanDetected, FALLING ); } void loop() { // バッファをクリア  clearI2CReadbuf(); // レジスタ読み出し  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); //IRセンサ  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); //センサ温度  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); delay(1000); } double clacTemp() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } double clacIR() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C スレーブデバイスに1バイト書き込む **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから1バイト読み込む **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C スレーブデバイスに複数バイト書き込む **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから複数バイト読み込む **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C 受信バッファクリア **********************************************/ void clearI2CReadbuf(){ memcpy(i2c_recvBuf, 0x00, I2C_RECV_BUF_LENGTH); } Human_Sensing.ino\n","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。 磁石付きのLeafonyケースに入れる …","ref":"/en/docs/examples/beginner/extension/ir_sensor/","title":"人感センサ"},{"body":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Accelerometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、加速度と傾きが表示されます。\n","excerpt":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/2_p/basic/accelerometer/","title":"加速度センサ読み取り"},{"body":"  \n特徴 積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"  \n特徴 積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) …","ref":"/en/docs/leaf/extension/ax04/","title":"AX04 Spacer"},{"body":"  \n特徴 積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"  \n特徴 積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) …","ref":"/docs/leaf/extension/ax04/","title":"AX04 Spacer"},{"body":"概要 工場出荷時に、ESP32 MCUリーフにArduinoのスケッチが書き込まれているので、スマートフォンやパソコンのWi-Fiを使ってタッチセンサの値を送信して、表示がされます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AX07 Back to back 1   AX08 29pin header 1   AZ62 Connector Cover  2   AZ63 Nut Plate 2    AAA battery holder 1    M2*15mm screw 4    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード  ESP32 MCUをArduino IDEで使用するには、Arduino core for the ESP32 のインストールが必要です。詳しくは、こちら。 Arduino IDEで、以下のスケッチをマイコンボードに書き込んでください。  //===================================================================== // Leafony Platform sample sketch // Platform : ESP32 // Processor : ESP32-WROOM-32 // Application : ESP32 Touch Sensor // // Leaf configuration // (1) ap02 ESP MCU // (2) ax08 29pin header // // (c) 2019 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2019/11/21 First release //===================================================================== #include \u0026lt;WiFi.h\u0026gt; // ESP32用WiFiライブラリ#include \u0026lt;WiFiClient.h\u0026gt;#include \u0026lt;WiFiAP.h\u0026gt; //---------------------------------------------- // Wi-Fi Set these to your desired credentials. //---------------------------------------------- const char *ssid = \u0026#34;Leafony_ESP32-AP\u0026#34;; const char *password = \u0026#34;password\u0026#34;; WiFiServer server(80); #define TIMEOUT 20000 // タイムアウト 20秒 int update=1; // ブラウザのページ更新間隔(秒)初期値  //---------------------------------------------- // Touch //---------------------------------------------- int threshold = 20; // Touch 検出閾値 // bool touch1detected = false; // bool touch2detected = false; // bool touch3detected = false; // bool touch4detected = false; // bool touch5detected = false; // bool touch6detected = false;  //---------------------------------------------- // Touch 割り込み //---------------------------------------------- // ------ T0 ------ // void gotTouch1(){ // touch1detected = true; // } // ------ T3 ------ // void gotTouch2(){ // touch2detected = true; // } // ------ T4 ------ // void gotTouch3(){ // touch3detected = true; // } // ------ T5 ------ // void gotTouch4(){ // touch4detected = true; // } // ------ T6 ------ // void gotTouch5(){ // touch5detected = true; // } // ------ T7 ------ // void gotTouch6(){ // touch6detected = true; // }  //==================================================================== void setup(){ Serial.begin(115200); // デバッグシリアル出力開始  Serial.println(\u0026#34;Wi-Fi \u0026amp; Touch Sensor Test\u0026#34;); // シリアル出力表示  WiFi.softAP(ssid, password); IPAddress myIP = WiFi.softAPIP(); Serial.print(\u0026#34;AP IP address: \u0026#34;); Serial.println(myIP); server.begin(); // サーバ起動  delay(1000); // Wait  Serial.println(\u0026#34;Server started\u0026#34;); //---------------------------------------------- // Touch 割り込み設定 //---------------------------------------------- // touchAttachInterrupt(T0, gotTouch1, threshold); // D2/22pin // touchAttachInterrupt(T3, gotTouch2, threshold); // D7/9pin // touchAttachInterrupt(T4, gotTouch3, threshold); // D5/28pin // touchAttachInterrupt(T5, gotTouch4, threshold); // D4/26pin // touchAttachInterrupt(T6, gotTouch5, threshold); // D6/7pin // touchAttachInterrupt(T7, gotTouch6, threshold); // D3/24pin } //==================================================================== void loop(){ delay(1000); // Wait：これが短いと”このページは動作していません\u0026#34;が頻発する  WiFiClient client = server.available(); // 接続中のクライアントからデータを受信  char read_data; // 文字変数を定義  char s[65]; // 文字列変数を定義 65バイト64文字  byte data[32]; // 画像転送用の一時保存変数  int len=0; // 文字列等の長さカウント用  int t_wait=0; // 更新時間カウント用  int i,f_size; delay(500); // Wait：これが短いと”このページは動作していません\u0026#34;が頻発する  client = server.available(); // 接続されたクライアントを生成  if(!client)return; // loop()の先頭に戻る // Serial.println(\u0026#34;Connected\u0026#34;); // シリアル出力表示  while(client.connected()){ // 当該クライアントの接続状態を確認  if(client.available()){ // クライアントからのデータを確認  t_wait=0; // 待ち時間変数をリセット  read_data=client.read(); // データを文字変数read_dataに代入  if(read_data==\u0026#39;\\n\u0026#39;){ // 改行を検出した時  if(len\u0026gt;5 \u0026amp;\u0026amp; strncmp(s,\u0026#34;GET /\u0026#34;,5)==0) break; len=0; // 文字列長を0に  }else if(read_data!=\u0026#39;\\r\u0026#39; \u0026amp;\u0026amp; read_data!=\u0026#39;\\0\u0026#39;){ s[len]=read_data; // 文字列変数に文字read_dataを追加  len++; // 変数lenに1を加算  s[len]=\u0026#39;\\0\u0026#39;; // 文字列を終端  if(len\u0026gt;=64) len=63; // 文字列変数の上限  } } t_wait++; // 変数t_waitの値を1増加させる  if(t_wait\u0026gt;TIMEOUT) break; else delay(1); // TIMEOUTに到達したらwhileを抜ける  } delay(1); // クライアント側の応答待ち時間  if(!client.connected()||len\u0026lt;6) return; // 切断された場合はloop()の先頭へ // Serial.println(s); // 受信した命令をシリアル出力表示  if(strncmp(s,\u0026#34;GET / \u0026#34;,6)==0){ // コンテンツ取得命令時  //----------------------------------------------  // Web 表示  //----------------------------------------------  html(client,update,WiFi.softAPIP()); // コンテンツ表示  client.flush(); // ESP32用 ERR_CONNECTION_RESET対策 // client.stop(); // クライアントの切断  return; // 処理の終了・loop()の先頭へ  } //----------------------------------------------  // 更新時間の設定  //----------------------------------------------  if(strncmp(s,\u0026#34;GET /?INT=\u0026#34;,10)==0){ // 更新時間の設定命令を受けた時  update = atoi(\u0026amp;s[10]); // 受信値を変数updateに代入  } //----------------------------------------------  // コマンド送信  //----------------------------------------------  for(i=6;i\u0026lt;strlen(s);i++) if(s[i]==\u0026#39; \u0026#39;||s[i]==\u0026#39;+\u0026#39;) s[i]=\u0026#39;\\0\u0026#39;; htmlMesg(client,\u0026amp;s[6],WiFi.softAPIP()); // メッセージ表示  client.flush(); // ESP32用 ERR_CONNECTION_RESET対策 // client.stop(); // クライアント切断  Serial.println(\u0026#34;Sent HTML\u0026#34;); // シリアル出力表示 } * ESP32_AP_Touch.inoと同じフォルダに保存してください。自動的に読み込まれます //===================================================================== // Leafony Platform sample sketch // Application : html // // (c) 2019 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2019/11/07 First release //===================================================================== //==================================================================== // Web表示 //==================================================================== void html(WiFiClient \u0026amp;client, int update, uint32_t ip){ char s[65],s_ip[16]; uint16_t touchData; uint16_t touchTemp; sprintf(s_ip,\u0026#34;%d.%d.%d.%d\u0026#34;, ip \u0026amp; 255, ip\u0026gt;\u0026gt;8 \u0026amp; 255, ip\u0026gt;\u0026gt;16 \u0026amp; 255, ip\u0026gt;\u0026gt;24 ); client.println(\u0026#34;HTTP/1.1 200 OK\u0026#34;); // HTTP OKを応答  client.println(\u0026#34;Content-Type: text/html\u0026#34;); // HTMLコンテンツ  client.println(\u0026#34;Connection: close\u0026#34;); // 応答終了後にセッションを閉じる  client.println(); client.println(\u0026#34;\u0026lt;html\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Test Page\u0026lt;/title\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;meta http-equiv=\\\u0026#34;Content-type\\\u0026#34;content=\\\u0026#34;text/html; charset=UTF-8\\\u0026#34;\u0026gt;\u0026#34;); if(update){ client.print(\u0026#34;\u0026lt;meta http-equiv=\\\u0026#34;refresh\\\u0026#34;content=\\\u0026#34;\u0026#34;); client.print(update); client.print(\u0026#34;;URL=http://\u0026#34;); client.print(s_ip); client.println(\u0026#34;/\\\u0026#34;\u0026gt;\u0026#34;); } client.println(\u0026#34;\u0026lt;/head\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;body\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;h3\u0026gt;Wi-Fi \u0026amp; Touch Sensor Test\u0026lt;/h3\u0026gt;\u0026#34;); // ------ T6 ------  touchData=touchRead(T6); client.print(\u0026#34;F7 /D6:\u0026#34;); for (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){ client.print(\u0026#34;*\u0026#34;); } client.print(\u0026#34;:\u0026#34;+String(touchData)); // if(touch5detected){  if(touchData\u0026lt;=threshold){ // touch5detected = false;  Serial.println(\u0026#34;T6/D6/ 7pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;); client.println(\u0026#34; :Touch detected\u0026#34;); } client.println(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;); // ------ T3 ------  touchData=touchRead(T3); client.print(\u0026#34;F9 /D7:\u0026#34;); for (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){ client.print(\u0026#34;*\u0026#34;); } client.print(\u0026#34;:\u0026#34;+String(touchData)); // if(touch2detected){  if(touchData\u0026lt;=threshold){ // touch2detected = false;  Serial.println(\u0026#34;T3/D7/ 9pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;); client.println(\u0026#34; :Touch detected\u0026#34;); } client.println(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;); // ------ T0 ------  touchData=touchRead(T0); client.print(\u0026#34;F22/D2:\u0026#34;); for (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){ client.print(\u0026#34;*\u0026#34;); } client.print(\u0026#34;:\u0026#34;+String(touchData)); // if(touch1detected){  if(touchData\u0026lt;=threshold){ // touch1detected = false;  Serial.println(\u0026#34;T0/D2/22pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;); client.println(\u0026#34; :Touch detected\u0026#34;); } client.println(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;); /* // ------ T7 ------ touchData=touchRead(T7); client.print(\u0026#34;F24/D3:\u0026#34;); for (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){ client.print(\u0026#34;*\u0026#34;); } client.print(\u0026#34;:\u0026#34;+String(touchData)); // if(touch6detected){ if(touchData\u0026lt;=threshold){ // touch6detected = false; Serial.println(\u0026#34;T7/D3/24pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;); client.println(\u0026#34; :Touch detected\u0026#34;); } client.print(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;); */ // ------ T5 ------  touchData=touchRead(T5); client.print(\u0026#34;F26/D4:\u0026#34;); for (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){ client.print(\u0026#34;*\u0026#34;); } client.print(\u0026#34;:\u0026#34;+String(touchData)); // if(touch4detected){  if(touchData\u0026lt;=threshold){ // touch4detected = false;  Serial.println(\u0026#34;T5/D4/26pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;); client.println(\u0026#34; :Touch detected\u0026#34;); } client.println(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;); // ------ T4 ------  touchData=touchRead(T4); client.print(\u0026#34;F28/D5:\u0026#34;); for (touchTemp=0; touchTemp\u0026lt;=touchData/5; touchTemp++){ client.print(\u0026#34;*\u0026#34;); } client.print(\u0026#34;:\u0026#34;+String(touchData)); // if(touch3detected){  if(touchData\u0026lt;=threshold){ // touch3detected = false;  Serial.println(\u0026#34;T4/D5/28pin :\u0026#34;+String(touchData)+\u0026#34; :Touch detected\u0026#34;); client.println(\u0026#34; :Touch detected\u0026#34;); } client.println(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;); client.print(\u0026#34;更新間隔 = \u0026#34;); client.print(update); client.println(\u0026#34; 秒\u0026lt;/p\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;hr\u0026gt;\u0026#34;); // client.println(\u0026#34;\u0026lt;h3\u0026gt;HTTP GET\u0026lt;/h3\u0026gt;\u0026#34;);  client.print(\u0026#34;\u0026lt;p\u0026gt;http://\u0026#34;); client.print(s_ip); sprintf(s,\u0026#34;\u0026lt;form method=\\\u0026#34;GET\\\u0026#34;action=\\\u0026#34;http://%s/\\\u0026#34;\u0026gt;\u0026#34;,s_ip); client.println(s); client.println(\u0026#34;自動更新:\u0026lt;input type=\\\u0026#34;submit\\\u0026#34;name=\\\u0026#34;INT\\\u0026#34;value=\\\u0026#34;0 停止\\\u0026#34;\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;input type=\\\u0026#34;submit\\\u0026#34;name=\\\u0026#34;INT\\\u0026#34;value=\\\u0026#34;1 秒\\\u0026#34;\u0026gt;\u0026#34;); // client.println(\u0026#34;\u0026lt;input type=\\\u0026#34;submit\\\u0026#34; name=\\\u0026#34;INT\\\u0026#34; value=\\\u0026#34;2 秒\\\u0026#34;\u0026gt;\u0026#34;); // client.println(\u0026#34;\u0026lt;input type=\\\u0026#34;submit\\\u0026#34; name=\\\u0026#34;INT\\\u0026#34; value=\\\u0026#34;5 秒\\\u0026#34;\u0026gt;\u0026#34;); // client.println(\u0026#34;\u0026lt;input type=\\\u0026#34;submit\\\u0026#34; name=\\\u0026#34;INT\\\u0026#34; value=\\\u0026#34;10 秒\\\u0026#34;\u0026gt;\u0026#34;); // client.println(\u0026#34;　\u0026lt;input type=\\\u0026#34;submit\\\u0026#34; name=\\\u0026#34;RESET\\\u0026#34; value=\\\u0026#34;リセット\\\u0026#34;\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026#34;);  client.println(\u0026#34;\u0026lt;/form\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;/body\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;/html\u0026gt;\u0026#34;); } //==================================================================== // コマンド送信 //==================================================================== void htmlMesg(WiFiClient \u0026amp;client, char *txt, uint32_t ip){ char s_ip[16]; sprintf(s_ip,\u0026#34;%d.%d.%d.%d\u0026#34;, ip \u0026amp; 255, ip\u0026gt;\u0026gt;8 \u0026amp; 255, ip\u0026gt;\u0026gt;16 \u0026amp; 255, ip\u0026gt;\u0026gt;24 ); client.println(\u0026#34;HTTP/1.1 200 OK\u0026#34;); // HTTP OKを応答  client.println(\u0026#34;Content-Type: text/html\u0026#34;); // HTMLコンテンツ  client.println(\u0026#34;Connection: close\u0026#34;); // 応答終了後にセッションを閉じる  client.println(); client.println(\u0026#34;\u0026lt;html\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Test Page2\u0026lt;/title\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;meta http-equiv=\\\u0026#34;Content-type\\\u0026#34;content=\\\u0026#34;text/html; charset=UTF-8\\\u0026#34;\u0026gt;\u0026#34;); client.print(\u0026#34;\u0026lt;meta http-equiv=\\\u0026#34;refresh\\\u0026#34;content=\\\u0026#34;3;URL=http://\u0026#34;); client.print(s_ip); client.println(\u0026#34;/\\\u0026#34;\u0026gt;\u0026#34;); client.print(\u0026#34;\u0026lt;p\u0026gt;\u0026#34;); client.print(txt); client.println(\u0026#34;\u0026lt;/p\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;/body\u0026gt;\u0026#34;); client.println(\u0026#34;\u0026lt;/html\u0026gt;\u0026#34;); } ESP32_AP_Touch.ino\n Arduino IDE 1.8.9で動作を確認しています。書き込みエラーが発生したら、IDEのバージョンを確認してください  表示のやり方 表示のやり方は、クイックスタートに記載していますので、ご参照願います。\n","excerpt":"概要 工場出荷時に、ESP32 MCUリーフにArduinoのスケッチが書き込まれているので、スマートフォンやパソコンのWi-Fiを使ってタッチセンサの値を送信して、表示がされます。\n使用するリーフ  …","ref":"/en/docs/examples/advanced/esp32/wifi_touchsensor/","title":"Wi-Fi タッチセンサ"},{"body":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI03 MIC\u0026amp;VR\u0026amp;LED 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nMIC\u0026amp;VR\u0026amp;LEDリーフを使うためにはライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください\n//===================================================================== // Sound level meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/17 First release //===================================================================== #include \u0026lt;MsTimer2.h\u0026gt;#include \u0026lt;avr/wdt.h\u0026gt;#include \u0026lt;avr/sleep.h\u0026gt;#include \u0026lt;avr/power.h\u0026gt;#include \u0026lt;Wire.h\u0026gt; #define AVR_LED 13 #define LED1 6 #define LED2 7 #define LED3 8 #define LED4 9 #define LED5 10 #define LED6 11  #define MIC 16 #define VR 17  unsigned int dataVR; unsigned int dataMic; //----------------------------------------------- // VRとMICデータを取得する //----------------------------------------------- void getSencerData() { dataVR = analogRead(A3); dataMic = analogRead(A2); Serial.println(\u0026#34;---------------------\u0026#34;); Serial.print(\u0026#34;MIC = \u0026#34;); Serial.println(dataMic,DEC); Serial.print(\u0026#34;VR = \u0026#34;); Serial.println(dataVR,DEC); } //----------------------------------------------- // VRとMICの値にあわせてLEDを点灯、消灯させる //----------------------------------------------- void viewSencerData() { if (dataVR \u0026lt; 400) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 400 \u0026amp;\u0026amp; dataVR \u0026lt; 800) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 800 \u0026amp;\u0026amp; dataVR \u0026lt; 900) { digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else { digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; 450) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= 450 \u0026amp;\u0026amp; dataMic \u0026lt; 550) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= 550 \u0026amp;\u0026amp; dataMic \u0026lt; 650) { digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else { digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup() { Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(AVR_LED, OUTPUT); digitalWrite(AVR_LED, LOW); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); //起動テスト(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); } void loop() { getSencerData(); viewSencerData(); delay(100); } Sound_Level_Meter.ino\n","excerpt":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type …","ref":"/en/docs/examples/beginner/extension/sound_level/","title":"サウンドレベルメータ"},{"body":"  \n特徴 3.3VおよびVBUSの消費電流を測定することが出来るリーフです。 電流測定リーフでは3.3VとVBUSは表面と裏面のパッドが電気的に切り離されているので、下記の各々スルーホールに電流計を接続することで、電池リーフから遠い部分にある単体リーフあるいは複数リーフ群の全電源電流を測定出来ます。下の例では、センサーリーフとBLEリーフが電流測定リーフを介して、電池リーフの遠い側に配置されているので、両リーフの合計電流が測定出来ます。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"  \n特徴 3.3VおよびVBUSの消費電流を測定することが出来るリーフです。 電流測定リーフでは3.3VとVBUSは表面と裏面のパッドが電気的に切り離されているので、下記の各々スルーホールに電流計を …","ref":"/en/docs/leaf/extension/ax05/","title":"AX05 I Meas"},{"body":"  \n特徴 3.3VおよびVBUSの消費電流を測定することが出来るリーフです。 電流測定リーフでは3.3VとVBUSは表面と裏面のパッドが電気的に切り離されているので、下記の各々スルーホールに電流計を接続することで、電池リーフから遠い部分にある単体リーフあるいは複数リーフ群の全電源電流を測定出来ます。下の例では、センサリーフとBLEリーフが電流測定リーフを介して、電池リーフの遠い側に配置されているので、両リーフの合計電流が測定出来ます。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"  \n特徴 3.3VおよびVBUSの消費電流を測定することが出来るリーフです。 電流測定リーフでは3.3VとVBUSは表面と裏面のパッドが電気的に切り離されているので、下記の各々スルーホールに電流計を …","ref":"/docs/leaf/extension/ax05/","title":"AX05 I Meas"},{"body":"概要 電源リーフには、電池電圧をモニタするためのADコンバータを実装。温度、湿度、照度、傾きだけでなく、電池電圧も測定し、LCDに表示させます。 温度（または、湿度）の補正の仕方 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。詳しくは、こちら。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AI04 LCD 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AZ01 USB 1   AX03 Leaf×2 1   AV01 CR2032 1   AZ62 Connector Cover 2   AZ63 Nut Plate 1    CR2032 coin cell battery 1    M2*15mm screw 4    リーフの組立 ソースコード  書き込みには、4-Sensors、LCD、AVR MCUライブラリ（タイマ割り込み）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、[こちら]。 Arduino IDEで、以下のスケッチをマイコンボードに書き込んでください。  //===================================================================== // Leafony Platform sample sketch // Platform : 4-Sensors // Processor : ATmega328P (3.3V /8MHz) // Application : 4-Sensors with LCD // // Leaf configuration // (1) AI01 4-Sensors // (2) AI04 LCD // (3) AP01 AVR MCU // (4) AV02 CR2450 or AV01 CR2032 // (5) AZ01 USB\t(for debug) // //\t(c) 2019 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/20 First release //===================================================================== //use libraries //Adafruit LIS3DH //https://github.com/adafruit/Adafruit_LIS3DH //※ Adafruit_LIS3DH.h // uint8_t readRegister8(uint8_t reg); // void writeRegister8(uint8_t reg, uint8_t value); // をpublic:に移動する //Adafruit Unified Sensor Driver //https://github.com/adafruit/Adafruit_Sensor //SmartEverything ST HTS221 Humidity Sensor //https://github.com/ameltech/sme-hts221-library //ClosedCube Arduino Library for ClosedCube OPT3001 //https://github.com/closedcube/ClosedCube_OPT3001_Arduino //ST7032 - Arduino LiquidCrystal compatible library //https://github.com/tomozh/arduino_ST7032 //=====================================================================  //===================================================================== // difinition //===================================================================== #include \u0026lt;MsTimer2.h\u0026gt;#include \u0026lt;avr/wdt.h\u0026gt;#include \u0026lt;avr/sleep.h\u0026gt;#include \u0026lt;avr/power.h\u0026gt; #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #include \u0026lt;Adafruit_Sensor.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt;#include \u0026lt;SoftwareSerial.h\u0026gt;#include \u0026lt;ST7032.h\u0026gt;//=====================================================================  //===================================================================== // シリアルコンソールへのデバック出力 // #define DEBUG = 出力あり //　//#define DEBUG = 出力なし（コメントアウトする） //===================================================================== #define DEBUG //=====================================================================  //===================================================================== // IOピンの名前定義 // 接続するリーフに合わせて定義する //===================================================================== // -------------------------------------------- // PD port // digital 0: PD0 = PCRX (HW UART) // digital 1: PD1 = PCTX (HW UART) // digital 2: PD2 = INT0# // digital 3: PD3 = INT1# // digital 4: PD4 = Reserved /* not use */ // digital 5: PD5 = Reserved /* not use */ // digital 6: PD6 = Reserved /* not use */ // digital 7: PD7 = Reserved /* not use */ // -------------------------------------------- #define PCTX 0 #define PCRX 1 #define INT0 2 #define INT1 3 #define RSV_D4 4 #define RSV_D5 5 #define RSV_D6 6 #define RSV_D7 7  // -------------------------------------------- // PB port // digital 8: PB0 = Reserved /* not use */ // digital 9: PB1 = Reserved /* not use */ // digital 10:PB2 = SS# // digital 11:PB3 = MOSI // digital 12:PB4 = MISO // digital 13:PB5 = SCK (LED) // PB6 = XTAL1 // PB7 = XTAL2 //--------------------------------------------- #define RSV_D8 8 #define RSV_D9 9 #define SS 10 #define MOSI 11 #define MISO 12 #define LED_PIN 13  // -------------------------------------------- // PC port // digital 14/ Analog0: PC0 = Reserved /* not use */ // digital 15/ Analog1: PC1 = Reserved /* not use */ // digital 16/ Analog2: PC2 = Reserved /* not use */ // digital 17/ Analog3: PC3 = Reserved /* not use */ // digital 18/ SDA : PC4 = SDA (I2C) // digital 19/ SCL : PC5 = SCL (I2C) // RESET : PC6 = RESET# //----------------------------------------------- #define RSV_D14 14 #define RSV_D15 15 #define RSV_D16 16 #define RSV_D17 17 #define SDA 18 #define SCL 19  //===================================================================== // プログラム内で使用する定数定義 // //===================================================================== //----------------------------------------------- //３軸センサ、輝度センサ I2Cアドレス //----------------------------------------------- #define LIS2DH_ADDRESS 0x19 // SD0/SA0 pin = VCC #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC #define I2C_EXPANDER_ADDR_LCD 0x1A  //----------------------------------------------- // loop() interval // MsTimer2のタイマー割り込み発生間隔(ms) //----------------------------------------------- #define LOOP_INTERVAL 125 // 125ms interval  //----------------------------------------------- // LIS2DH //----------------------------------------------- #define DIVIDER_2G 16383 // full scale 2G (=0xFFFF/4) #define DIVIDER_4G 8191 // full scale 4G (=0xFFFF/4/2) #define DIVIDER_8G 4096 // full scale 8G (=0xFFFF/4/4) #define DIVIDER_16G 1365 // full scale 16G (=0xFFFF/4/12)  //----------------------------------------------- // Batt ADC ADC081C027 //----------------------------------------------- #define BATT_ADC_ADDR 0x50  //===================================================================== // object //===================================================================== //----------------------------------------------- // Sensor //----------------------------------------------- Adafruit_LIS3DH accel = Adafruit_LIS3DH(); ClosedCube_OPT3001 light; //----------------------------------------------- // LCD //-----------------------------------------------  ST7032 lcd; //===================================================================== // プログラムで使用する変数定義 // //===================================================================== //===================================================================== // RAM data //===================================================================== //--------------------------- // loop counter //--------------------------- uint8_t iLoop1s = 0; //--------------------------- // event //--------------------------- bool eventSensorRead = false; bool eventWriteLCD = false; //--------------------------- // int0 interrupt //--------------------------- volatile bool bEventSleep = false; //--------------------------- // interval Timer2 interrupt //--------------------------- volatile bool bInterval = false; //--------------------------- // LIS2DH : accelerometer //--------------------------- int16_t dataX, dataY, dataZ; float dataX_g, dataY_g, dataZ_g; float dataTilt, avrTilt; //--------------------------- // HTS221 : Temperature/Humidity //--------------------------- float dataTemp, avrTemp; float dataHumid, avrHumid; float calcTemp = 0; float calcHumid = 0; //--------------------------- // 2点補正用データ //--------------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  //--------------------------- // OPT3001 : Light //--------------------------- float dataLight, avrLight; float calcLight = 0; //--------------------------- // LCD //--------------------------- volatile bool bLCDchange = false; volatile int lcd_view_sts = 0; //--------------------------- // Sleep, Watchdog Timer //---------------------------  volatile int countWDT = 0; volatile int wakeupWDT = 2; //--------------------------- // Batt //--------------------------- float dataBatt = 0; //===================================================================== // setup //===================================================================== //----------------------------------------------- // port //----------------------------------------------- //===================================================================== // IOピンの入出力設定 // 接続するリーフに合わせて設定する //===================================================================== void setupPort(){ //---------------------  // PD port  //---------------------  // PD0 : digital 0 = RX  // PD1 : digital 1 = TX  pinMode(INT0, INPUT); // PD2 : digital 2 = BLE interrupt  pinMode(INT1, INPUT); // PD3 : digital 3 = sensor interrupt  //---------------------  // PB port  //---------------------  pinMode(LED_PIN, OUTPUT); // PB5 : digital 13 = DEV _LED  digitalWrite(LED_PIN, LOW); //---------------------  // PC port  //---------------------  // PC4 : digital 18 = I2C SDA  // PC5 : digital 19 = I2C SCL } //===================================================================== // 割り込み処理初期設定 // //===================================================================== //----------------------------------------------- // external interrupt // 外部割り込み設定 //----------------------------------------------- void setupExtInt(){ attachInterrupt(0, intExtInt0, FALLING); // Sw1 INT0# = enabled  detachInterrupt(1); // sensor INT1# = disabled } //----------------------------------------------- // timer2 interrupt (interval=125ms, int=overflow) // メインループのタイマー割り込み設定 //----------------------------------------------- void setupTC2Int(){ MsTimer2::set(LOOP_INTERVAL, intTimer2); } //===================================================================== // I2C　制御関数 // //===================================================================== //----------------------------------------------- //I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } //===================================================================== // 各デバイスの初期設定 // //===================================================================== //----------------------------------------------- // sensor //----------------------------------------------- void setupSensor(){ //-------------------------------------  // LIS2DH (accelerometer)  //-------------------------------------  //-------------------  // I2C address  //------------------  accel.begin(LIS2DH_ADDRESS); //-------------------  // register  //-------------------  accel.writeRegister8(LIS3DH_REG_CTRL1, 0x07); //X,Y,Z axis = enable  accel.setDataRate(LIS3DH_DATARATE_1_HZ); //Data rate = 1Hz  accel.writeRegister8(LIS3DH_REG_CTRL2, 0x00); accel.writeRegister8(LIS3DH_REG_CTRL3, 0x00); // INT Disable  accel.writeRegister8(LIS3DH_REG_CTRL4, 0x80); //BUD = enable, Scale = +/-2g  //-------------------------------------  // HTS221 (temperature /humidity)  //-------------------------------------  smeHumidity.begin(); //-------------------------------------  // OPT3001 (light)  //-------------------------------------  OPT3001_Config newConfig; OPT3001_ErrorCode errorConfig; //-------------------  // I2C address  //-------------------  light.begin(OPT3001_ADDRESS); //-------------------  // config register  //-------------------  newConfig.RangeNumber = B1100; // automatic full scale  newConfig.ConvertionTime = B1; // convertion time = 800ms  newConfig.ModeOfConversionOperation = B11; // continous conversion  newConfig.Latch = B0; // hysteresis-style  errorConfig = light.writeConfig(newConfig); if(errorConfig != NO_ERROR){ errorConfig = light.writeConfig(newConfig); //retry  } } //===================================================================== // 割り込み処理 // //===================================================================== //===================================================================== // interrupt //===================================================================== //---------------------------------------------- // Timer2 INT // タイマー割り込み関数 //---------------------------------------------- void intTimer2(){ bInterval = 1; } //--------------------------------------------- // Watchdog Timer INT // WDT割り込み関数 //--------------------------------------------- ISR(WDT_vect){ wdt_disable(); countWDT += 1; if (countWDT \u0026gt;= wakeupWDT){ countWDT = 0; } } //---------------------------------------------- // INT0 // INT0割り込み関数 //---------------------------------------------- void intExtInt0(){ if (bEventSleep == false) { bEventSleep = true; } else { bEventSleep = false; } } //---------------------------------------------- // INT1 // INT1割り込み関数 //---------------------------------------------- void intExtInt1(){ //bWakeupINT1 = true; } //==================================================================== // functions //==================================================================== //-------------------------------------------------------------------- // counter /event //-------------------------------------------------------------------- //----------------------------------------- // main loop // メインループのループ回数をカウントし // 1秒間隔でセンサーデータの取得をONにする // 4秒間隔でスリープ確認をONにする //----------------------------------------- void loopCounter(){ iLoop1s += 1; //--------------------  // 1s period  //--------------------  if (iLoop1s \u0026gt;= 8){ // 125ms x 8 = 1s  iLoop1s = 0; eventSensorRead = true; eventWriteLCD = true; } } //-------------------------------------------------------------------- // sensor //-------------------------------------------------------------------- //----------------------------------------- // main loop // センサーデータ取得がONのとき、各センサーからデータを取得 // コンソール出力がONのときシリアルに測定値と計算結果を出力する //----------------------------------------- void loopSensor(){ double temp_mv; //---------------------------  // 1s period  //---------------------------  if (eventSensorRead == true){ //-------------------------  // initialize parameter  //-------------------------  eventSensorRead = false; //-------------------------  // LIS2DH  // 3軸センサーのデータ取得  //-------------------------  accel.read(); dataX_g = accel.x_g; //X軸  dataY_g = accel.y_g; //Y軸  dataZ_g = accel.z_g; //Z軸  if(dataZ_g \u0026gt;= 1.0){ dataZ_g = 1.00; } else if (dataZ_g \u0026lt;= -1.0){ dataZ_g = -1.00; } dataTilt = acos(dataZ_g)/PI*180; //-------------------------  // HTS221  // 温湿度センサーデータ取得  //-------------------------  dataTemp = (float)smeHumidity.readTemperature(); //温度  dataHumid = (float)smeHumidity.readHumidity(); //湿度  //-------------------------  // 温度と湿度の2点補正  //-------------------------  dataTemp=TM0+(TM1-TM0)*(dataTemp-TL0)/(TL1-TL0); // 温度補正  dataHumid=HM0+(HM1-HM0)*(dataHumid-HL0)/(HL1-HL0); // 湿度補正  //-------------------------  // OPT3001  // 照度センサーデータ取得  //-------------------------  OPT3001 result = light.readResult(); if(result.error == NO_ERROR){ dataLight = result.lux; } //-------------------------  // ADC081C027（ADC)  // 電池リーフ電池電圧取得  //-------------------------  uint8_t adcVal1 = 0; uint8_t adcVal2 = 0; Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); adcVal1 = Wire.read(); adcVal2 = Wire.read(); if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { //測定値がFFならバッテリリーフはつながっていない  adcVal1 = adcVal2 = 0; } //電圧計算　ADC　* （(リファレンス電圧(3.3V)/ ADCの分解能(256)) * 分圧比（２倍））  //dataBatt = (((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * (3.3 / 256)) * 2 ;  temp_mv = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; dataBatt = (float)(temp_mv / 1000); //-------------------------  // シリアルモニタ表示  //------------------------- #ifdef DEBUG  Serial.println(\u0026#34;\u0026#34;); #if 0Serial.println(\u0026#34;--- sensor data ---\u0026#34;); Serial.println(\u0026#34; Tmp[degC] = \u0026#34; + String(dataTemp)); Serial.println(\u0026#34; Hum[%] = \u0026#34; + String(dataHumid)); Serial.println(\u0026#34; Lum[lx] = \u0026#34; + String(dataLight)); Serial.println(\u0026#34; Ang[arc deg] = \u0026#34; + String(dataTilt)); Serial.println(\u0026#34; Bat[V] = \u0026#34; + String(dataBatt)); //Serial.println(\u0026#34;\u0026#34;); //Serial.println(\u0026#34; Accel X,Y,Z\u0026#34; + String(dataX_g) + \u0026#34; \u0026#34; + String(dataY_g) + \u0026#34; \u0026#34; + String(dataZ_g)); #else  Serial.println(\u0026#34;T =\u0026#34; + String(dataTemp) + \u0026#34; H =\u0026#34; + String(dataHumid) + \u0026#34; L=\u0026#34; + String(dataLight) + \u0026#34; A=\u0026#34; + String(dataTilt) + \u0026#34; V=\u0026#34; + String(dataBatt)); #endif #endif  //bWakeupINT1 = false;  } } //debug /// void getBattVal() { uint8_t adcVal1 = 0; uint8_t adcVal2 = 0; Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); adcVal1 = Wire.read(); adcVal2 = Wire.read(); if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { //測定値がFFならバッテリリーフはつながっていない  adcVal1 = adcVal2 = 0; } //電圧計算　ADC　* （(リファレンス電圧(3.3V)/ ADCの分解能(256)) * 分圧比（２倍））  //dataBatt = (((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * (3.3 / 256)) * 2 ;  double temp_mv = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; float batval = (float)(temp_mv / 1000); Serial.println(\u0026#34; V=\u0026#34; + String(batval)); } void loopLCD( void ){ /* */ if( eventWriteLCD == true ){ eventWriteLCD = false; veiwSencerData(); } } //--------------------------------------- // Veiw sensor data // センサーデータを文字列に変換してLCDに表示する //--------------------------------------- void veiwSencerData(){ float value; char temp[7], humid[7], light[7], tilt[7],battVolt[7]; char code[4]; char sendData[40]; //-----------------------------------  //センサーデータを文字列に変換  //dtostrf(変換する数字,変換される文字数,小数点以下の桁数,変換した文字の格納先);  //変換される文字数を-にすると変換される文字は左詰め、+なら右詰めとなる  //-----------------------------------  //-------------------------  // Temperature (4Byte)  //-------------------------  value = dataTemp; if(value \u0026gt;= 100){ value = 99.9; } else if(value \u0026lt;= -10){ value = -9.9; } dtostrf(value,4,1,temp); //-------------------------  // Humidity (4Byte)  //-------------------------  value = dataHumid; dtostrf(value,4,1,humid); //-------------------------  // Ambient Light (5Byte)  //-------------------------  value = dataLight; if(value \u0026gt;= 100000){ value = 99999; } dtostrf(value,5,0,light); //-------------------------  // Tilt (4Byte)  //-------------------------  value = dataTilt; if(value \u0026lt; 3){ value = 0; } dtostrf(value,4,0,tilt); //-------------------------  // Battery Voltage (4Byte)  //-------------------------  value = dataBatt; if (value \u0026gt;= 10){ value = 9.99; } dtostrf(value, 4, 2, battVolt); trim(temp); trim(humid); trim(light); trim(tilt); trim(battVolt); lcd.clear(); switch (lcd_view_sts) { case 0: // Tmp XX.X [degC]  lcd.print(\u0026#34;Temp\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(temp) +\u0026#34; C\u0026#34;); break; case 1: // Hum xx.x [%]  lcd.print(\u0026#34;Humidity\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(humid) +\u0026#34; %\u0026#34;); break; case 2: // Lum XXXXX [lx]  lcd.print(\u0026#34;Luminous\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(light) +\u0026#34; lx\u0026#34;); break; case 3: // Ang XXXX [arc deg]  lcd.print(\u0026#34;Angle\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(tilt) +\u0026#34; deg\u0026#34;); break; case 4: // Bat X.XX [V]  lcd.print(\u0026#34;Battery\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(battVolt) +\u0026#34; V\u0026#34;); break; default: break; } if (lcd_view_sts \u0026lt; 4){ lcd_view_sts++; } else{ lcd_view_sts = 0; } //debug// #ifdef DEBUG  //getBattVal(); #endif //debug// } //--------------------------------------- // trim // 文字列配列からSPを削除する //--------------------------------------- void trim(char * data) { int i = 0, j = 0; while (*(data + i) != \u0026#39;\\0\u0026#39;){ if (*(data + i) != \u0026#39; \u0026#39;){ *(data + j) = *(data + i); j++; } i++; } *(data + j) = \u0026#39;\\0\u0026#39;; } //-------------------------------------------------------------------- // sleep //-------------------------------------------------------------------- //----------------------------------------- // main loop // スリープ移行要求があった場合、センサーリーフをSLEEPさせて // WDTをセットしマイコンリーフをスリープさせる //----------------------------------------- void loopSleep(){ if (bEventSleep == true){ //bEventSleep = false;  #ifdef DEBUG  Serial.print(\u0026#34; \u0026gt;\u0026gt;\u0026gt; Go to sleep : \u0026#34;); Serial.flush(); #endif  //-----------------------  // sleep  //-----------------------  sleepLCD(); sleepSensor(); //wdt_start();  sleep(); //-----------------------  // wakeup  //-----------------------  wakeupSensor(); wakeupLCD(); #ifdef DEBUG  Serial.println(\u0026#34; \u0026lt;\u0026lt;\u0026lt; Wake up \u0026lt;\u0026lt;\u0026lt;\u0026#34;); #endif  } } //----------------------------------------- // SLEEP //----------------------------------------- void sleep(){ ADCSRA \u0026amp;= ~(1 \u0026lt;\u0026lt; ADEN); //ADC停止  set_sleep_mode(SLEEP_MODE_PWR_DOWN); //SET SLEEP MODE  sleep_enable(); // SLEEP ENABLE  // BOD停止  MCUCR |= (1 \u0026lt;\u0026lt; BODSE) | (1 \u0026lt;\u0026lt; BODS); // MCUCRのBODSとBODSEに1をセット  MCUCR = (MCUCR \u0026amp; ~(1 \u0026lt;\u0026lt; BODSE)) | (1 \u0026lt;\u0026lt; BODS); // すぐに（4クロック以内）BODSSEを0, BODSを1に設定  asm(\u0026#34;sleep\u0026#34;); // 3クロック以内にスリープ  sleep_disable(); // SLEEP DISABLE } //----------------------------------------- // WDT //----------------------------------------- void wdt_start(){ // watchdog timer reset  wdt_reset(); //disable interruput  cli(); //clear WatchDog system Reset Flag(WDRF)  MCUSR \u0026amp;= ~(1 \u0026lt;\u0026lt; WDRF); // WDT変更許可  // WDCEとWDE同時セットで変更許可  WDTCSR |= 1 \u0026lt;\u0026lt; WDCE | 1 \u0026lt;\u0026lt; WDE; //WDT設定  // WDE=0,WDIE=1 :WDT overflowで割り込み  // WDP3=1,WDP2=0,WDP1=0,WDP0=1: 8s  WDTCSR = 1 \u0026lt;\u0026lt; WDIE | 0 \u0026lt;\u0026lt; WDE | 1 \u0026lt;\u0026lt; WDP3 | 0 \u0026lt;\u0026lt; WDP2 | 0 \u0026lt;\u0026lt; WDP1 | 1 \u0026lt;\u0026lt; WDP0; //enable interruput  sei(); } //----------------------------------------- // sleep sensor // センサーリーフをスリープさせる //----------------------------------------- void sleepSensor(){ //-----------------------  // OPT3001 sleep  //-----------------------  OPT3001_Config newConfig; OPT3001_ErrorCode errorConfig; newConfig.ModeOfConversionOperation = B00; errorConfig = light.writeConfig(newConfig); if(errorConfig != NO_ERROR){ errorConfig = light.writeConfig(newConfig); } //-----------------------  // LIS2DH sleep  //-----------------------  accel.setDataRate(LIS3DH_DATARATE_POWERDOWN); //-----------------------  // HTS221 sleep  //-----------------------  smeHumidity.deactivate(); } //----------------------------------------- // wakeup sensor // センサーリーフをスリープから復帰させる //----------------------------------------- void wakeupSensor(){ //-----------------------  // OPT3001 wakeup  //-----------------------  OPT3001_Config newConfig; OPT3001_ErrorCode errorConfig; newConfig.RangeNumber = B1100; //automatic full scale  newConfig.ConvertionTime = B1; //convertion time = 800ms  newConfig.ModeOfConversionOperation = B11; //continous conversion  newConfig.Latch = B1; //latch window style  errorConfig = light.writeConfig(newConfig); if(errorConfig != NO_ERROR){ errorConfig = light.writeConfig(newConfig); //retry  } //-----------------------  // LIS2DH wakeup  //-----------------------  accel.setDataRate(LIS3DH_DATARATE_1_HZ); //-----------------------  // HTS221 wakeup  //-----------------------  smeHumidity.activate(); } //----------------------------------------- // sleep LCD // LCDリーフをスリープさせる //----------------------------------------- void sleepLCD() { lcd.noDisplay(); } //----------------------------------------- // sleep LCD // LCDリーフをスリープさせる //----------------------------------------- void wakeupLCD(){ lcd.display(); } //----------------------------------------- // poweroff LCD // LCDの電源OFF //----------------------------------------- void powerOffLCD(){ // LCD 電源 OFF  i2c_write_byte(I2C_EXPANDER_ADDR_LCD, 0x01, 0x00); } //----------------------------------------- // wakeup LCD // LCDリーフをスリープさせる //----------------------------------------- void powerOnLCD(){ // LCD 電源　ＯＮ  i2c_write_byte(I2C_EXPANDER_ADDR_LCD, 0x01, 0x01); // LCDの電源が一度落ちたので、ＬＣＤを再設定  lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); } //==================================================================== // setup //==================================================================== void setup() { //WDT disable  wdt_disable(); delay(10); Serial.begin(115200); // UART 9600bps  Wire.begin(); // I2C 100KHz  i2c_write_byte(I2C_EXPANDER_ADDR_LCD, 0x03, 0xFE); powerOnLCD(); #ifdef DEBUG  Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;setup start\u0026#34;); #endif  setupPort(); delay(10); noInterrupts(); setupExtInt(); setupTC2Int(); interrupts(); setupSensor(); MsTimer2::start(); // Timer2 inverval start  #ifdef DEBUG  Serial.println(\u0026#34;\u0026#34;); Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;loop start\u0026#34;); Serial.println(\u0026#34;\u0026#34;); #endif  } //==================================================================== // loop //==================================================================== void loop() { //-----------------------------------------------------  // Timer2 interval　125ms で1回ループ  //-----------------------------------------------------  if (bInterval == true){ bInterval = false; //--------------------------------------------  //--------------------------------------------  // loop counter  //--------------------------------------------  loopCounter(); //--------------------------------------------  // sensor read  //--------------------------------------------  loopSensor(); //--------------------------------------------  // LCD  //--------------------------------------------  loopLCD(); //--------------------------------------------  // sleep/resume  //--------------------------------------------  loopSleep(); } } 4-Sensors_LCD.ino\n","excerpt":"概要 電源リーフには、電池電圧をモニタするためのADコンバータを実装。温度、湿度、照度、傾きだけでなく、電池電圧も測定し、LCDに表示させます。 温度（または、湿度）の補正の仕方 表示させたい温度（ま …","ref":"/en/docs/examples/beginner/extension/lcd/","title":"LCD"},{"body":"  \n特徴 Seeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。Grove対応ピンの仕様は以下の通り。 低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\n性能 電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 5V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1B)    ブロック図 \nピン配置 \nTips サンプルデザイン  超音波センサで距離測定 カメラの撮影  ライブラリ ライブラリは、予めここからインストールしておきましょう。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 Seeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給し …","ref":"/en/docs/leaf/extension/ax06/","title":"AX06 Grove\u00265V"},{"body":"  \n特徴 Seeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。Grove対応ピンの仕様は以下の通り。 低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\n性能 電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 5V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1B)    ブロック図 \nピン配置 \nTips UART、I2C、Analog、Digitalについて \n   Item Description     UART For UART communication   I2C For I2C communication   Analog Analog Signal Inputs   Digital Digital Signal Inputs    サンプルアプリ  超音波センサで距離測定 カメラの撮影  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 Seeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給し …","ref":"/docs/leaf/extension/ax06/","title":"AX06 Grove\u00265V"},{"body":"概要 時刻がパソコンのシリアルモニタに表示されます。 使用するリーフ    Type Name Q\u0026rsquo;ty     AZ02 RTC\u0026amp;microSD 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組立 スケッチの書き込み  書き込みには、RTC＆MicroSDライブラリが必要です。予め、ライブラリをインクルードしておいてください。詳しくは、[こちら]。 Arduino IDEで、「ファイル」→「スケッチ例」→「RTClib」→「pcf8523」で、マイコンボードに書き込んでください。 ここまででRTC自体は作動しますが、時刻の設定がされていません。  ソースコード  現在の時刻の自動設定と、低消費電力設定のため、以下のように青字の部分のスケッチを変更してください。  void setup () { while (!Serial) { delay(1); // for Leonardo/Micro/Zero 　} Serial.begin(57600);　if (! rtc.begin()) { Serial.println(“Couldn’t find RTC”); while (1); } if (! rtc.initialized()) { Serial.println(“RTC is NOT running!”); // following line sets the RTC to the date \u0026amp; time this sketch was compiled 　rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));　//自動時刻合わせ 　// This line sets the RTC with an explicit date \u0026amp; time, for example to set 　// January 21, 2014 at 3am you would call: 　//rtc.adjust(DateTime(2019, 8, 9, 13, 0, 0));　 } rtc.writeSqwPinMode(PCF8523_OFF);　//低消費電力化 } 時刻の設定 RTCの停止と起動を行って、時刻を設定してください。\n USBケーブルを抜き、CR2032リーフのPower switchをOFFにして、RTCを停止します。 USBケーブルを入れ、RTCを起動させます。 CR2032リーフのPower switchをONにします。  シリアルモニタの表示 シリアルモニターを起動させて、時刻が表示されていることを確認してください。\n","excerpt":"概要 時刻がパソコンのシリアルモニタに表示されます。 使用するリーフ    Type Name Q\u0026rsquo;ty     AZ02 RTC\u0026amp;microSD 1   AP01 AVR MCU …","ref":"/en/docs/examples/beginner/extension/rtc/","title":"リアルタイムクロック"},{"body":"  \n特徴 全てのリーフI/F端子を接続したリーフを反転させて接続するためのリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2020年1月初版  ","excerpt":"  \n特徴 全てのリーフI/F端子を接続したリーフを反転させて接続するためのリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) …","ref":"/en/docs/leaf/extension/ax07/","title":"AX07 Back to back"},{"body":"  \n特徴 全てのリーフI/F端子を接続したリーフを反転させて接続するためのリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2020年1月初版  ","excerpt":"  \n特徴 全てのリーフI/F端子を接続したリーフを反転させて接続するためのリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) …","ref":"/docs/leaf/extension/ax07/","title":"AX07 Back to back"},{"body":"概要 microSD カードの情報が、パソコンのシリアルモニタに表示されます。 使用するリーフ    Type Name Q\u0026rsquo;ty     AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ02 RTC\u0026amp;microSD 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    microSD card 1    M2*15mm screw 2    リーフの組立 スケッチの書き込み  Arduino IDEで、「ファイル」→「スケッチ例」→「SD」→「CardInfo」で、マイコンボードに書き込んでください。  ソースコード  安定してデータを取得するため、HALF→QUARTERにスピードを遅くしてください。  if (!card.init(SPI_HALF_SPEED, chipSelect)) {　→if (!card.init(SPI_QUARTER_SPEED, chipSelect)) {  chipselectのデジタルピンを４→10に変更してください。  const int chipSelect = 4; →const int chipSelect = 10;　","excerpt":"概要 microSD カードの情報が、パソコンのシリアルモニタに表示されます。 使用するリーフ    Type Name Q\u0026rsquo;ty     AP01 AVR MCU 1   AV01 …","ref":"/en/docs/examples/beginner/extension/microsd/","title":"micro SD"},{"body":"  \n特徴 リーフI/Fの29ピン全てをピンヘッダに接続したリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2020年1月初版  ","excerpt":"  \n特徴 リーフI/Fの29ピン全てをピンヘッダに接続したリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: …","ref":"/en/docs/leaf/extension/ax08/","title":"AX08 29pin header"},{"body":"  \n特徴 リーフI/Fの29ピン全てをピンヘッダに接続したリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2020年1月初版  ","excerpt":"  \n特徴 リーフI/Fの29ピン全てをピンヘッダに接続したリーフです。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: …","ref":"/docs/leaf/extension/ax08/","title":"AX08 29pin header"},{"body":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。超音波センサで測定した距離をLCDに表示させます。超音波センサは、通常、デジタルピンに入力するが、LCDのスイッチ1とGrove\u0026amp;5VのDin1が同じピンを使用しているため、UARTピンに接続しUARTピンをデジタルピンとして使用します。\n\r\r使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI04 LCD 1   AX04 Spacer 1   AX06 Grove\u0026amp;5V 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    Grove – Ultrasonic Distance Sensor 1    CR2032 coin cell battery 1    M2*18mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード  書き込みには、LCDライブラリ、超音波制御 ライブラリ（ Ultrasonic.h ）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで下記のプログラムを書きましょう。  //===================================================================== // Leafony Platform sample sketch // Platform : Grove + Ultrasonic // Processor : ATmega328P (3.3V /8MHz) // Application : Ultrasonic Ranger demo // // Leaf configuration // (1) AI04 LCD // (2) AP01 AVR MCU // (3) AX01 Grove\u0026amp;5V + Grove - Ultrasonic Ranger (UART pinに接続) // ※ Ultrasonic RangerはGrove\u0026amp;5VのUARTに接続する // (4) AZ01 USB // //\t(c) 2019 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //Grove - Ultrasonic Rangerを使用したデモ //LCDに超音波センサーから取得した対象物からの距離を表示 //===================================================================== //use libraries //ST7032 - Arduino LiquidCrystal compatible library //https://github.com/tomozh/arduino_ST7032 //Grove_Ultrasonic_Ranger //https://github.com/Seeed-Studio/Grove_Ultrasonic_Ranger/ //=====================================================================  #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ST7032.h\u0026gt; // LCD ST7032 lcd; char strMessage[8]; #include \u0026#34;Ultrasonic.h\u0026#34;Ultrasonic ultrasonic(A1); void setup() { Serial.begin(115200); //LCD Initialize  lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(1000); lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(500); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++) { lcd.setCursor(i, 0); delay(100); } for (i=0 ; i\u0026lt;8 ;i++) { lcd.setCursor(i, 1); delay(100); } lcd.noBlink(); } void loop() { long RangeInCentimeters; lcd.clear(); lcd.print(\u0026#34;Distance\u0026#34;); RangeInCentimeters = ultrasonic.MeasureInCentimeters(); sprintf(strMessage,\u0026#34;%5d cm\u0026#34;,RangeInCentimeters); lcd.setCursor(0, 1); lcd.print(strMessage); delay(250); } Grove-Ultrasonic_LCD.ino\n","excerpt":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。超音波センサで測定した距離をLCDに表示させます。超音波センサは、通常、デジタルピンに入力するが、LCDのスイッチ1 …","ref":"/docs/examples/advanced/1_p/exten/distance_sensor/","title":"超音波センサで距離測定"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/2_p/exten/","title":"ESP32 Wi-Fi Kit + Extension Kit"},{"body":"\n特徴 Leafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\nTips コネクタの取り付け・取り外し リーフ基板にコネクタを取り付ける、または、外す場合は下図のように行ってください。\n\u0026ndash; 取り付け\n\u0026ndash; 取り外し\nドキュメント  コネクタの試験結果  変更履歴  Rev A: 2019年8月初版  ","excerpt":"\n特徴 Leafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材 …","ref":"/en/docs/leaf/others/az61/","title":"AZ61 Connector"},{"body":"  \n特徴 AVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\n性能 USB-UART変換    Item Description     Part Number FT232RQ   USB USB 2.0 Full Speed   Data transfer rates 300 baud to 3 Mbaud    電源    Item Description     Part number XCL222B331ER-G   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 500mA   Protection circuit Over current protection / thermal shutdown/short-circuit protection    ブロック図 \nピン配置 \nTips  Micro USB USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給する。 LED DS120\nFT232RQが制御するLEDである。\nUART TX通信によるプログラム書き込み時に点滅する。 LED DS121\nFT232RQが制御するLEDである。\nUART RX通信によるプログラム書き込み時に点滅する。  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 AVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電 …","ref":"/en/docs/leaf/others/az01/","title":"AZ01 USB"},{"body":"  \n特徴 AVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\n性能 USB-UART変換    Item Description     Part Number FT232RQ   USB USB 2.0 Full Speed   Data transfer rates 300 baud to 3 Mbaud    電源    Item Description     Part number XCL222B331ER-G   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 500mA   Protection circuit Over current protection / thermal shutdown/short-circuit protection    ブロック図 \nピン配置 \nTips micro USB、LEDについて \n   Item Description     micro USB It is used for writing a sketch to the MCU and serial monitoring by connecting a PC.This also converts USB’s VBUS(5V) to 3.3V by using step-down power circuit and provide VBUS and 3.3V to each leaf.   LED TX LED which controlled by FT232RQ. Blinks when program is written by UART TX communication.   LED RX LED which controlled by FT232RQ. Blinks when program is written by UART TX communication.    ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2019年8月初版  ","excerpt":"特徴 AVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電 …","ref":"/docs/leaf/others/az01/","title":"AZ01 USB"},{"body":"その他リーフ一覧\n","excerpt":"その他リーフ一覧","ref":"/en/docs/leaf/others/","title":"その他"},{"body":"その他リーフ一覧\n","excerpt":"その他リーフ一覧","ref":"/docs/leaf/others/","title":"その他"},{"body":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。超音波センサで測定した距離をLCDに表示させます。超音波センサは、通常、デジタルピンに入力するが、LCDのスイッチ1とGrove\u0026amp;5VのDin1が同じピンを使用しているため、UARTピンに接続しUARTピンをデジタルピンとして使用します。\n\n使用するリーフ    Type Name Q\u0026rsquo;ty     AI04 LCD 1   AP01 AVR MCU 1   AV01 CR2032 1   AX06 Grove\u0026amp;5V 1   AZ01 USB 1   AZ62 Connector Cover 1    Grove – Ultrasonic Distance Sensor 1    CR2032 coin cell battery 1    M2*18mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード  書き込みには、LCDライブラリ、超音波制御 ライブラリ（ Ultrasonic.h ）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで下記のプログラムを書きましょう。  //===================================================================== // Leafony Platform sample sketch // Platform : Grove + Ultrasonic // Processor : ATmega328P (3.3V /8MHz) // Application : Ultrasonic Ranger demo // // Leaf configuration // (1) AI04 LCD // (2) AP01 AVR MCU // (3) AX01 Grove\u0026amp;5V + Grove - Ultrasonic Ranger (UART pinに接続) // ※ Ultrasonic RangerはGrove\u0026amp;5VのUARTに接続する // (4) AZ01 USB // //\t(c) 2019 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //Grove - Ultrasonic Rangerを使用したデモ //LCDに超音波センサーから取得した対象物からの距離を表示 //===================================================================== //use libraries //ST7032 - Arduino LiquidCrystal compatible library //https://github.com/tomozh/arduino_ST7032 //Grove_Ultrasonic_Ranger //https://github.com/Seeed-Studio/Grove_Ultrasonic_Ranger/ //=====================================================================  #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ST7032.h\u0026gt; // LCD ST7032 lcd; char strMessage[8]; #include \u0026#34;Ultrasonic.h\u0026#34;Ultrasonic ultrasonic(A1); void setup() { Serial.begin(115200); //LCD Initialize  lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(1000); lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(500); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++) { lcd.setCursor(i, 0); delay(100); } for (i=0 ; i\u0026lt;8 ;i++) { lcd.setCursor(i, 1); delay(100); } lcd.noBlink(); } void loop() { long RangeInCentimeters; lcd.clear(); lcd.print(\u0026#34;Distance\u0026#34;); RangeInCentimeters = ultrasonic.MeasureInCentimeters(); sprintf(strMessage,\u0026#34;%5d cm\u0026#34;,RangeInCentimeters); lcd.setCursor(0, 1); lcd.print(strMessage); delay(250); } Grove-Ultrasonic_LCD.ino\n","excerpt":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。超音波センサで測定した距離をLCDに表示させます。超音波センサは、通常、デジタルピンに入力するが、LCDのスイッチ1 …","ref":"/en/docs/examples/advanced/grove/distance_sensor/","title":"超音波センサで距離測定"},{"body":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。定点観測用カメラ。1分に一回カメラで撮影した画像をmicroSDカードに保存してみよう。 \r\r使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ02 RTC\u0026amp;microSD 1   AX04 Spacer 1   AX06 Grove\u0026amp;5V 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    Grove-Serial Camera Kit 1    microSD card  1    M2*18mm screw 2    リーフの組み立て ソースコード  書き込みには、4-Sensors、AVR MCUライブラリ（タイマ割り込み）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで下記のプログラムを書きましょう。  //===================================================================== // Leafony Platform sample sketch // Platform : Grove + Camera // Processor : ATmega328P (3.3V /8MHz) // Application : Camera // // Leaf configuration // (1) AP01 AVR MCU // (2) AX01 Grove\u0026amp;5V + Grove Serial Camera Kit // (3) AZ01 USB // (4) AZ02 RTC＆MicroSD // //\t(c) 2019 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //use libraries //=====================================================================  //===================================================================== // difinition //===================================================================== #include \u0026lt;MsTimer2.h\u0026gt;#include \u0026lt;SPI.h\u0026gt;#include \u0026lt;SD.h\u0026gt;#include \u0026lt;SoftwareSerial.h\u0026gt;#include \u0026lt;avr/wdt.h\u0026gt;#include \u0026lt;avr/sleep.h\u0026gt;#include \u0026lt;avr/power.h\u0026gt;//=====================================================================  #define DEBUG  //===================================================================== // SPI CLOCK // SDカードのSPI I/Fのクロック速度4Mでは動作しないので4M以下に設定すること //===================================================================== #define SD_CLCK 2500000  //===================================================================== // 撮影間隔（秒） // //===================================================================== #define SNAP_WAIT 60  //===================================================================== // IOピンの名前定義 // 接続するリーフに合わせて定義する //===================================================================== // -------------------------------------------- // PD port // digital 0: PD0 = PCRX (HW UART) // digital 1: PD1 = PCTX (HW UART) // digital 2: PD2 = INT0# // digital 3: PD3 = INT1# // digital 4: PD4 = RSV // digital 5: PD5 = RSV // digital 6: PD6 = RSV // digital 7: PD7 = RSV // -------------------------------------------- #define PCTX 0 #define PCRX 1 #define INT0 2 #define INT1 3 #define RSV_D4 4 #define RSV_D5 5 #define SD_EN 6 #define RSV_D7 7  // -------------------------------------------- // PB port // digital 8: PB0 = UART2_RX (software UART) /* not use */ // digital 9: PB1 = UART2_TX (software UART) /* not use */ // digital 10:PB2 = CS# // digital 11:PB3 = MOSI // digital 12:PB4 = MISO // digital 13:PB5 = SCK (AVR LED) // PB6 = XTAL1 // PB7 = XTAL2 //--------------------------------------------- #define UART2_RX 8 #define UART2_TX 9 #define SD_CS 10 #define MOSI 11 #define MISO 12 #define LED_PIN 13  // -------------------------------------------- // PC port // digital 14/ Analog0: PC0 = RSV // digital 15/ Analog1: PC1 = CAMERA TX (software UART) // digital 16/ Analog2: PC2 = CAMERA RX (software UART) // digital 17/ Analog3: PC3 = RSV // digital 18/ SDA : PC4 = SDA (I2C) // digital 19/ SCL : PC5 = SCL (I2C) // RESET : PC6 = RESET# //----------------------------------------------- #define RSV_D14 14 #define UART3_TX 15 #define UART3_RX 16 #define RSV_D17 17 #define SDA 18 #define SCL 19 //=====================================================================  //===================================================================== // camera //===================================================================== //Color Setting #define COLOR_2BIT_GRAY 0x01 #define COLOR_4BIT_GRAY 0x02 #define COLOR_8BIT_GRAY 0x03 #define COLOR_2BIT_COLOR 0x05 #define COLOR_4BIT_COLOR 0x06 #define COLOR_JPEG 0x07 //Preview Resolution #define PRE_RES_80_60 0x01 #define PRE_RES_160_120 0x03 //JPEG Resolution #define JPEG_RES_80_60 0x01 #define JPEG_RES_QQVGA 0x03 #define JPEG_RES_QVGA 0x05 #define JPEG_RES_VGA 0x07 //Get Setting #define GET_SNAPCHOT 0x01 #define GET_PRE_PIC 0x02 #define GET_PRE_JPEG 0x03 //Snapshot Setting #define COMPRESSED 0x00 #define UNCOMPRESSED 0x01 //data length #define PIC_PKT_LEN 128  //===================================================================== // SD //===================================================================== File myFile; SoftwareSerial CameraSerial(UART3_RX, UART3_TX); //===================================================================== // 変数定義 //===================================================================== unsigned long picTotalLen = 0; // picture length int picNameNum = 0; char fname[16]; //--------------------------- // interval Timer2 interrupt //--------------------------- volatile bool bInterval = false; volatile int intcnt = 0; //===================================================================== // setup //===================================================================== //----------------------------------------------- // port //----------------------------------------------- //===================================================================== // IOピンの入出力設定 // 接続するリーフに合わせて設定する //===================================================================== void setupPort(){ //---------------------  // PD port  //---------------------  // PD0 : digital 0 = RX  // PD1 : digital 1 = TX  pinMode(INT0, INPUT); // PD2 : digital 2 = INT0#  pinMode(INT1, INPUT); // PD3 : digital 3 = INT1#  pinMode(RSV_D4, OUTPUT); // PD4 : digital 4 = LED  digitalWrite(RSV_D4, LOW); pinMode(RSV_D5, OUTPUT); // PD5 : digital 5 = not used  digitalWrite(RSV_D5, LOW); pinMode(SD_EN, OUTPUT); // PD6 : digital 6 = BLE reset active-low  digitalWrite(SD_EN, HIGH); pinMode(RSV_D7, OUTPUT); // PD7 : digital 7 = BLE sleep  digitalWrite(RSV_D7, HIGH); //---------------------  // PB port  //---------------------  pinMode(UART2_RX, OUTPUT); // PB0 : digital 8 = software UART2  digitalWrite(UART2_RX, LOW); pinMode(UART2_TX, OUTPUT); // PB1 : digital 9 = software UART2  digitalWrite(UART2_TX, LOW); //---------------------  // PC port  //---------------------  pinMode(RSV_D14, OUTPUT); // PC0 : digital 14 = not used  digitalWrite(RSV_D14, LOW); // PC1 : digital 15 = Camera RX  // PC2 : digital 16 = Camera TX  pinMode(RSV_D17, OUTPUT); // PC3 : digital 17 = not used  digitalWrite(RSV_D17, LOW); // PC4 : digital 18 = I2C SDA  // PC5 : digital 19 = I2C SCL } //===================================================================== // 割り込み処理 // //===================================================================== //----------------------------------------------- // timer2 interrupt (interval=1000ms, int=overflow) // メインループのタイマー割り込み設定 //----------------------------------------------- void setupTC2Int(){ MsTimer2::set(1000, intTimer2);} //---------------------------------------------- // Timer2 INT // タイマー割り込み関数 //---------------------------------------------- void intTimer2(){ intcnt++; if (intcnt \u0026gt; SNAP_WAIT) { intcnt = 0; bInterval = true; } } //==================================================================== // camera //==================================================================== //---------------------------------------------- // clearReadBuf // カメラデータの受信バッファクリア //---------------------------------------------- void clearReadBuf() { while (CameraSerial.available()) { CameraSerial.read(); } } //---------------------------------------------- // sendCmd // カメラへのコマンド送信 //---------------------------------------------- void sendCmd(char cmd[], int cmd_len) { for (char i = 0; i \u0026lt; cmd_len; i++) CameraSerial.write(cmd[i]); } //---------------------------------------------- // readRespons // カメラからのデータ受信 //---------------------------------------------- int readRespons(char *dest, int len, unsigned int timeout) { int read_len = 0; unsigned long t = millis(); while (read_len \u0026lt; len) { while (CameraSerial.available()\u0026lt;1) { if ((millis() - t) \u0026gt; timeout) { //Serial.println(\u0026#34;timeout\u0026#34;);  return read_len; } } *(dest+read_len) = CameraSerial.read(); #ifdef DEBUG  //Serial.write(*(dest+read_len),); //debug #endif  read_len++; } return read_len; } //---------------------------------------------- // initialize // カメラとの通信確立 //---------------------------------------------- void initialize() { char cmd[] = {0xaa,0x0d,0x00,0x00,0x00,0x00} ; unsigned char resp[6]; Serial.print(\u0026#34;initializing camera...\u0026#34;); while (1) { sendCmd(cmd,6); if (readRespons((char *)resp, 6,1000) != 6) { Serial.print(\u0026#34;.\u0026#34;); continue; } if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x0d \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) { if (readRespons((char *)resp, 6, 500) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0d \u0026amp;\u0026amp; resp[2] == 0 \u0026amp;\u0026amp; resp[3] == 0 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } } cmd[1] = 0x0e; cmd[2] = 0x0d; sendCmd(cmd, 6); Serial.println(\u0026#34; done.\\r\\n\u0026#34;); } //---------------------------------------------- // preCapture // カメラの初期設定 //---------------------------------------------- void preCapture() { char cmd[] = { 0xaa, 0x01, 0x00, COLOR_JPEG, PRE_RES_80_60, JPEG_RES_VGA }; unsigned char resp[6]; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x01 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } } //---------------------------------------------- // Capture // カメラの撮影実施 //---------------------------------------------- void Capture() { char cmd[] = { 0xaa, 0x06 , 0x08, PIC_PKT_LEN \u0026amp; 0xff, (PIC_PKT_LEN\u0026gt;\u0026gt;8) \u0026amp; 0xff ,0}; unsigned char resp[6]; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x06 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } cmd[1] = 0x05; cmd[2] = 0; cmd[3] = 0; cmd[4] = 0; cmd[5] = 0; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x05 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } cmd[1] = 0x04; cmd[2] = GET_SNAPCHOT; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x04 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) { if (readRespons((char *)resp, 6, 1000) != 6) { continue; } if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0a \u0026amp;\u0026amp; resp[2] == 0x01) { picTotalLen = (resp[3]) | (resp[4] \u0026lt;\u0026lt; 8) | (resp[5] \u0026lt;\u0026lt; 16); //Serial.print(\u0026#34;picTotalLen:\u0026#34;);  //Serial.println(picTotalLen);  break; } } } } //---------------------------------------------- // GetData // カメラからデータを取得しSDに書き込む //---------------------------------------------- void GetData() { char cmd[] = { 0xaa, 0x0e , 0x00, 0x00, 0x00, 0x00 }; unsigned char pkt[PIC_PKT_LEN]; unsigned int pktCnt = (picTotalLen) / (PIC_PKT_LEN - 6); if ((picTotalLen % (PIC_PKT_LEN-6)) != 0) pktCnt += 1; set_filename(); if (SD.exists(fname)) { SD.remove(fname); } myFile = SD.open(fname, FILE_WRITE); if(!myFile){ Serial.println(\u0026#34;myFile open fail...\u0026#34;); } else{ Serial.print(\u0026#34;Saving \u0026#34;);Serial.print(fname); Serial.print(\u0026#34;..... \u0026#34;); for (unsigned int i = 0; i \u0026lt; pktCnt; i++) { cmd[4] = i \u0026amp; 0xff; cmd[5] = (i \u0026gt;\u0026gt; 8) \u0026amp; 0xff; int retry_cnt = 0; retry: delay(10); clearReadBuf(); sendCmd(cmd, 6); uint16_t cnt = readRespons((char *)pkt, PIC_PKT_LEN, 200); unsigned char sum = 0; for (int y = 0; y \u0026lt; cnt - 2; y++) { sum += pkt[y]; } if (sum != pkt[cnt-2]) { if (++retry_cnt \u0026lt; 100) goto retry; else break; } myFile.write((const uint8_t *)\u0026amp;pkt[4], cnt-6); //if (cnt != PIC_PKT_LEN) break;  } cmd[4] = 0xf0; cmd[5] = 0xf0; sendCmd(cmd, 6); } myFile.close(); Serial.println(\u0026#34;end!!\u0026#34;); } //---------------------------------------------- // set_filename // SDに書き込みファイ名を作成IMGxxxx.JPG //---------------------------------------------- void set_filename(){ sprintf(fname, \u0026#34;IMG%04d.JPG\u0026#34;, picNameNum); picNameNum ++; if( picNameNum \u0026gt; 100 ){ picNameNum = 0; // Overwrite  } } //==================================================================== // setup //==================================================================== void setup() { //WDT disable  wdt_disable(); //内部の各モジュールの電源OFF  //power_all_disable();  //power_timer0_enable();  //power_timer2_enable();  //power_spi_enable();  //power_usart0_enable();  delay(10); Serial.begin(115200); CameraSerial.begin(9600); #ifdef DEBUG  Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;setup start\u0026#34;); #endif  setupPort(); delay(10); setupTC2Int(); if (!SD.begin(SD_CLCK,SD_CS)) { Serial.print(\u0026#34;sd init failed\u0026#34;); return; } Serial.print(\u0026#34;sd init finish\\r\\n\u0026#34;); initialize(); delay(1); preCapture(); delay(1000); Capture(); GetData(); MsTimer2::start(); } //==================================================================== // loop //==================================================================== void loop() { if (bInterval == true) { bInterval = false; Capture(); GetData(); } } Grove-Camera_microSD.ino\n","excerpt":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。定点観測用カメラ。1分に一回カメラで撮影した画像をmicroSDカードに保存してみよう。 \r\r使用するリー …","ref":"/docs/examples/advanced/1_p/exten/camera/","title":"カメラの撮影"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI02 SP\u0026amp;PIR 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n#define LEDC_CHANNEL_0 0 // use first channel of 16 channels (started from zero) #define LEDC_TIMER_13_BIT 13 // use 13 bit precission for LEDC timer #define LEDC_BASE_FREQ 5000 // use 5000 Hz as a LEDC base frequency  //------------------------------ // buzzer output = 13pin //------------------------------ #define BUZZER_OUT 13  const int NOTE_NONE = NOTE_MAX; // notes in the melody: int melody[] = { NOTE_C, NOTE_C, NOTE_G, NOTE_G, NOTE_A, NOTE_A, NOTE_G, NOTE_F, NOTE_F, NOTE_E, NOTE_E,NOTE_D,NOTE_D,NOTE_C }; int noteOctaves[] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }; // note durations: 4 = quarter note, 8 = eighth note, etc.: int noteDurations[] = { 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 2 }; //===================================================================== // setup //===================================================================== void setup() { ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); ledcAttachPin(BUZZER_OUT, LEDC_CHANNEL_0); // iterate over the notes of the melody:  for (int thisNote = 0; thisNote \u0026lt; 14; thisNote++) { // to calculate the note duration, take one second divided by the note type.  //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.  ledcWriteNote(LEDC_CHANNEL_0, (note_t)melody[thisNote], noteOctaves[thisNote]); // to distinguish the notes, set a minimum time between them.  // the note\u0026#39;s duration + 30% seems to work well:  int pauseBetweenNotes = 1000 / noteDurations[thisNote] * 1.30; delay(pauseBetweenNotes); // stop the tone playing:  ledcWriteTone(LEDC_CHANNEL_0, 0); delay(30); } } //===================================================================== // Main loop //===================================================================== void loop() { // no need to repeat the melody. } ESP32_toneMelody_Twinkle.ino\n実行結果 スピーカーから一度だけメロディが鳴ります。\n","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/2_p/exten/speaker/","title":"スピーカ"},{"body":"\n特徴 Connector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n外形図 \n変更履歴  Rev A: 2019年8月初版  ","excerpt":"\n特徴 Connector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n外形図 \n変更履歴  Rev A: 2019 …","ref":"/en/docs/leaf/others/az62/","title":"AZ62 Connector Cover"},{"body":"  \n特徴 NXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。microSDカードはSPIでアクセスします。\n性能　    Item Description     Part number PCF8523TK   Type Real-Time Clock (RTC) and calendar   Interrupt Alarm and timer   Quartz crystal unit FC-12M 32.768000kHz 7.0 +20.0-20.0   Interfaces I2C(Address: 0x68)    ブロック図 \nピン配置 \nサンプルデザイン  リアルタイムクロック microSD カード カメラの撮影  ライブラリ ライブラリは、予めここからインストールしておきましょう。 ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2020年1月初版  ","excerpt":"  \n特徴 NXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能で …","ref":"/en/docs/leaf/others/az02/","title":"AZ02 RTC\u0026microSD"},{"body":"  \n特徴 NXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。microSDカードはSPIでアクセスします。\n性能　    Item Description     Part number PCF8523TK   Type Real-Time Clock (RTC) and calendar   Interrupt Alarm and timer   Quartz crystal unit FC-12M 32.768000kHz 7.0 +20.0-20.0   Interfaces I2C(Address: 0x68)    ブロック図 \nピン配置 \nサンプルアプリ  リアルタイムクロック microSD カード カメラの撮影  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールして利用して下さい\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf)  変更履歴  Rev A: 2020年1月初版  ","excerpt":"  \n特徴 NXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能で …","ref":"/docs/leaf/others/az02/","title":"AZ02 RTC\u0026microSD"},{"body":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。定点観測用カメラ。1分に一回カメラで撮影した画像をmicroSDカードに保存してみよう。 \n使用するリーフ    Type Name Q\u0026rsquo;ty     AP01 AVR MCU 1   AV01 CR2032 1   AX06 Grove\u0026amp;5V 1   AZ01 USB 1   AZ02 RTC\u0026amp;MicroSD 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    Grove-Serial Camera Kit 1    microSD card  1    M2*18mm screw 2    リーフの組み立て ソースコード  書き込みには、4-Sensors、AVR MCUライブラリ（タイマ割り込み）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで下記のプログラムを書きましょう。  //===================================================================== // Leafony Platform sample sketch // Platform : Grove + Camera // Processor : ATmega328P (3.3V /8MHz) // Application : Camera // // Leaf configuration // (1) AP01 AVR MCU // (2) AX01 Grove\u0026amp;5V + Grove Serial Camera Kit // (3) AZ01 USB // (4) AZ02 RTC＆MicroSD // //\t(c) 2019 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //use libraries //=====================================================================  //===================================================================== // difinition //===================================================================== #include \u0026lt;MsTimer2.h\u0026gt;#include \u0026lt;SPI.h\u0026gt;#include \u0026lt;SD.h\u0026gt;#include \u0026lt;SoftwareSerial.h\u0026gt;#include \u0026lt;avr/wdt.h\u0026gt;#include \u0026lt;avr/sleep.h\u0026gt;#include \u0026lt;avr/power.h\u0026gt;//=====================================================================  #define DEBUG  //===================================================================== // SPI CLOCK // SDカードのSPI I/Fのクロック速度4Mでは動作しないので4M以下に設定すること //===================================================================== #define SD_CLCK 2500000  //===================================================================== // 撮影間隔（秒） // //===================================================================== #define SNAP_WAIT 60  //===================================================================== // IOピンの名前定義 // 接続するリーフに合わせて定義する //===================================================================== // -------------------------------------------- // PD port // digital 0: PD0 = PCRX (HW UART) // digital 1: PD1 = PCTX (HW UART) // digital 2: PD2 = INT0# // digital 3: PD3 = INT1# // digital 4: PD4 = RSV // digital 5: PD5 = RSV // digital 6: PD6 = RSV // digital 7: PD7 = RSV // -------------------------------------------- #define PCTX 0 #define PCRX 1 #define INT0 2 #define INT1 3 #define RSV_D4 4 #define RSV_D5 5 #define SD_EN 6 #define RSV_D7 7  // -------------------------------------------- // PB port // digital 8: PB0 = UART2_RX (software UART) /* not use */ // digital 9: PB1 = UART2_TX (software UART) /* not use */ // digital 10:PB2 = CS# // digital 11:PB3 = MOSI // digital 12:PB4 = MISO // digital 13:PB5 = SCK (AVR LED) // PB6 = XTAL1 // PB7 = XTAL2 //--------------------------------------------- #define UART2_RX 8 #define UART2_TX 9 #define SD_CS 10 #define MOSI 11 #define MISO 12 #define LED_PIN 13  // -------------------------------------------- // PC port // digital 14/ Analog0: PC0 = RSV // digital 15/ Analog1: PC1 = CAMERA TX (software UART) // digital 16/ Analog2: PC2 = CAMERA RX (software UART) // digital 17/ Analog3: PC3 = RSV // digital 18/ SDA : PC4 = SDA (I2C) // digital 19/ SCL : PC5 = SCL (I2C) // RESET : PC6 = RESET# //----------------------------------------------- #define RSV_D14 14 #define UART3_TX 15 #define UART3_RX 16 #define RSV_D17 17 #define SDA 18 #define SCL 19 //=====================================================================  //===================================================================== // camera //===================================================================== //Color Setting #define COLOR_2BIT_GRAY 0x01 #define COLOR_4BIT_GRAY 0x02 #define COLOR_8BIT_GRAY 0x03 #define COLOR_2BIT_COLOR 0x05 #define COLOR_4BIT_COLOR 0x06 #define COLOR_JPEG 0x07 //Preview Resolution #define PRE_RES_80_60 0x01 #define PRE_RES_160_120 0x03 //JPEG Resolution #define JPEG_RES_80_60 0x01 #define JPEG_RES_QQVGA 0x03 #define JPEG_RES_QVGA 0x05 #define JPEG_RES_VGA 0x07 //Get Setting #define GET_SNAPCHOT 0x01 #define GET_PRE_PIC 0x02 #define GET_PRE_JPEG 0x03 //Snapshot Setting #define COMPRESSED 0x00 #define UNCOMPRESSED 0x01 //data length #define PIC_PKT_LEN 128  //===================================================================== // SD //===================================================================== File myFile; SoftwareSerial CameraSerial(UART3_RX, UART3_TX); //===================================================================== // 変数定義 //===================================================================== unsigned long picTotalLen = 0; // picture length int picNameNum = 0; char fname[16]; //--------------------------- // interval Timer2 interrupt //--------------------------- volatile bool bInterval = false; volatile int intcnt = 0; //===================================================================== // setup //===================================================================== //----------------------------------------------- // port //----------------------------------------------- //===================================================================== // IOピンの入出力設定 // 接続するリーフに合わせて設定する //===================================================================== void setupPort(){ //---------------------  // PD port  //---------------------  // PD0 : digital 0 = RX  // PD1 : digital 1 = TX  pinMode(INT0, INPUT); // PD2 : digital 2 = INT0#  pinMode(INT1, INPUT); // PD3 : digital 3 = INT1#  pinMode(RSV_D4, OUTPUT); // PD4 : digital 4 = LED  digitalWrite(RSV_D4, LOW); pinMode(RSV_D5, OUTPUT); // PD5 : digital 5 = not used  digitalWrite(RSV_D5, LOW); pinMode(SD_EN, OUTPUT); // PD6 : digital 6 = BLE reset active-low  digitalWrite(SD_EN, HIGH); pinMode(RSV_D7, OUTPUT); // PD7 : digital 7 = BLE sleep  digitalWrite(RSV_D7, HIGH); //---------------------  // PB port  //---------------------  pinMode(UART2_RX, OUTPUT); // PB0 : digital 8 = software UART2  digitalWrite(UART2_RX, LOW); pinMode(UART2_TX, OUTPUT); // PB1 : digital 9 = software UART2  digitalWrite(UART2_TX, LOW); //---------------------  // PC port  //---------------------  pinMode(RSV_D14, OUTPUT); // PC0 : digital 14 = not used  digitalWrite(RSV_D14, LOW); // PC1 : digital 15 = Camera RX  // PC2 : digital 16 = Camera TX  pinMode(RSV_D17, OUTPUT); // PC3 : digital 17 = not used  digitalWrite(RSV_D17, LOW); // PC4 : digital 18 = I2C SDA  // PC5 : digital 19 = I2C SCL } //===================================================================== // 割り込み処理 // //===================================================================== //----------------------------------------------- // timer2 interrupt (interval=1000ms, int=overflow) // メインループのタイマー割り込み設定 //----------------------------------------------- void setupTC2Int(){ MsTimer2::set(1000, intTimer2);} //---------------------------------------------- // Timer2 INT // タイマー割り込み関数 //---------------------------------------------- void intTimer2(){ intcnt++; if (intcnt \u0026gt; SNAP_WAIT) { intcnt = 0; bInterval = true; } } //==================================================================== // camera //==================================================================== //---------------------------------------------- // clearReadBuf // カメラデータの受信バッファクリア //---------------------------------------------- void clearReadBuf() { while (CameraSerial.available()) { CameraSerial.read(); } } //---------------------------------------------- // sendCmd // カメラへのコマンド送信 //---------------------------------------------- void sendCmd(char cmd[], int cmd_len) { for (char i = 0; i \u0026lt; cmd_len; i++) CameraSerial.write(cmd[i]); } //---------------------------------------------- // readRespons // カメラからのデータ受信 //---------------------------------------------- int readRespons(char *dest, int len, unsigned int timeout) { int read_len = 0; unsigned long t = millis(); while (read_len \u0026lt; len) { while (CameraSerial.available()\u0026lt;1) { if ((millis() - t) \u0026gt; timeout) { //Serial.println(\u0026#34;timeout\u0026#34;);  return read_len; } } *(dest+read_len) = CameraSerial.read(); #ifdef DEBUG  //Serial.write(*(dest+read_len),); //debug #endif  read_len++; } return read_len; } //---------------------------------------------- // initialize // カメラとの通信確立 //---------------------------------------------- void initialize() { char cmd[] = {0xaa,0x0d,0x00,0x00,0x00,0x00} ; unsigned char resp[6]; Serial.print(\u0026#34;initializing camera...\u0026#34;); while (1) { sendCmd(cmd,6); if (readRespons((char *)resp, 6,1000) != 6) { Serial.print(\u0026#34;.\u0026#34;); continue; } if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x0d \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) { if (readRespons((char *)resp, 6, 500) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0d \u0026amp;\u0026amp; resp[2] == 0 \u0026amp;\u0026amp; resp[3] == 0 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } } cmd[1] = 0x0e; cmd[2] = 0x0d; sendCmd(cmd, 6); Serial.println(\u0026#34; done.\\r\\n\u0026#34;); } //---------------------------------------------- // preCapture // カメラの初期設定 //---------------------------------------------- void preCapture() { char cmd[] = { 0xaa, 0x01, 0x00, COLOR_JPEG, PRE_RES_80_60, JPEG_RES_VGA }; unsigned char resp[6]; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x01 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } } //---------------------------------------------- // Capture // カメラの撮影実施 //---------------------------------------------- void Capture() { char cmd[] = { 0xaa, 0x06 , 0x08, PIC_PKT_LEN \u0026amp; 0xff, (PIC_PKT_LEN\u0026gt;\u0026gt;8) \u0026amp; 0xff ,0}; unsigned char resp[6]; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x06 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } cmd[1] = 0x05; cmd[2] = 0; cmd[3] = 0; cmd[4] = 0; cmd[5] = 0; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x05 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } cmd[1] = 0x04; cmd[2] = GET_SNAPCHOT; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x04 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) { if (readRespons((char *)resp, 6, 1000) != 6) { continue; } if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0a \u0026amp;\u0026amp; resp[2] == 0x01) { picTotalLen = (resp[3]) | (resp[4] \u0026lt;\u0026lt; 8) | (resp[5] \u0026lt;\u0026lt; 16); //Serial.print(\u0026#34;picTotalLen:\u0026#34;);  //Serial.println(picTotalLen);  break; } } } } //---------------------------------------------- // GetData // カメラからデータを取得しSDに書き込む //---------------------------------------------- void GetData() { char cmd[] = { 0xaa, 0x0e , 0x00, 0x00, 0x00, 0x00 }; unsigned char pkt[PIC_PKT_LEN]; unsigned int pktCnt = (picTotalLen) / (PIC_PKT_LEN - 6); if ((picTotalLen % (PIC_PKT_LEN-6)) != 0) pktCnt += 1; set_filename(); if (SD.exists(fname)) { SD.remove(fname); } myFile = SD.open(fname, FILE_WRITE); if(!myFile){ Serial.println(\u0026#34;myFile open fail...\u0026#34;); } else{ Serial.print(\u0026#34;Saving \u0026#34;);Serial.print(fname); Serial.print(\u0026#34;..... \u0026#34;); for (unsigned int i = 0; i \u0026lt; pktCnt; i++) { cmd[4] = i \u0026amp; 0xff; cmd[5] = (i \u0026gt;\u0026gt; 8) \u0026amp; 0xff; int retry_cnt = 0; retry: delay(10); clearReadBuf(); sendCmd(cmd, 6); uint16_t cnt = readRespons((char *)pkt, PIC_PKT_LEN, 200); unsigned char sum = 0; for (int y = 0; y \u0026lt; cnt - 2; y++) { sum += pkt[y]; } if (sum != pkt[cnt-2]) { if (++retry_cnt \u0026lt; 100) goto retry; else break; } myFile.write((const uint8_t *)\u0026amp;pkt[4], cnt-6); //if (cnt != PIC_PKT_LEN) break;  } cmd[4] = 0xf0; cmd[5] = 0xf0; sendCmd(cmd, 6); } myFile.close(); Serial.println(\u0026#34;end!!\u0026#34;); } //---------------------------------------------- // set_filename // SDに書き込みファイ名を作成IMGxxxx.JPG //---------------------------------------------- void set_filename(){ sprintf(fname, \u0026#34;IMG%04d.JPG\u0026#34;, picNameNum); picNameNum ++; if( picNameNum \u0026gt; 100 ){ picNameNum = 0; // Overwrite  } } //==================================================================== // setup //==================================================================== void setup() { //WDT disable  wdt_disable(); //内部の各モジュールの電源OFF  //power_all_disable();  //power_timer0_enable();  //power_timer2_enable();  //power_spi_enable();  //power_usart0_enable();  delay(10); Serial.begin(115200); CameraSerial.begin(9600); #ifdef DEBUG  Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;setup start\u0026#34;); #endif  setupPort(); delay(10); setupTC2Int(); if (!SD.begin(SD_CLCK,SD_CS)) { Serial.print(\u0026#34;sd init failed\u0026#34;); return; } Serial.print(\u0026#34;sd init finish\\r\\n\u0026#34;); initialize(); delay(1); preCapture(); delay(1000); Capture(); GetData(); MsTimer2::start(); } //==================================================================== // loop //==================================================================== void loop() { if (bInterval == true) { bInterval = false; Capture(); GetData(); } } Grove-Camera_microSD.ino\n","excerpt":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。定点観測用カメラ。1分に一回カメラで撮影した画像をmicroSDカードに保存してみよう。 \n使用するリーフ    Type …","ref":"/en/docs/examples/advanced/grove/camera/","title":"カメラの撮影"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI02 SP\u0026amp;PIR 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n ビープ音の場合  //===================================================================== // Leafony Platform sample sketch // Application : Human_Sensing (Beep) // Processor : ESP32-WROOM-32 (ESP32 Dev Module) // Arduino IDE : 1.8.13 // Arduino ESP32: 1.0.4 // // Leaf configuration // (1) AI02 SP\u0026amp;PIR // (2) AP02 ESP32 MCU // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2020/08/20 First release //===================================================================== //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C //----------------------------------------------- // IOピン一覧 //----------------------------------------------- // D0 IO3 (RXD) // D1 IO1 (TXD) // D2 IO4 (INT0) // D3 IO27 (INT1) // D4 IO12 (H-MISO) // D5 IO13 (H-MOSI) // D6 IO14 (H-SCK) // D7 IO15 (H-SS) // D8 IO17 (UART_TX) // D9 IO16 (UART_RX) // D10 IO5 (SS) // D11 IO23 (MOSI) // D12 IO19 (MISO) // D13 IO18 (SCK) // D14 IO21 (SDA) // D15 IO22 (SCL) // A0 IO36 // A1 IO25 (UART_TX) // A2 IO26 (UART_RX) // A3 IO39 // A4 IO34 // A5 IO35  //----------------------------------------------- // IOピンの名前定義 // 接続するリーフに合わせて定義する //----------------------------------------------- #define PIR_INT 4 // D2 IO4 #define BUZZER_OUT 13 // D5 IO13 buzzer output  //------------------------------ // Tone設定 //------------------------------ #define LEDC_CHANNEL_0 0 // use first channel of 16 channels (started from zero) #define LEDC_TIMER_13_BIT 13 // use 13 bit precission for LEDC timer #define LEDC_BASE_FREQ 5000 // use 5000 Hz as a LEDC base frequency  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; volatile int HumanDetected = 0; //===================================================================== // setup //===================================================================== void setup(){ // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication:  Wire.begin(); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); // Beep  ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); ledcAttachPin(BUZZER_OUT, LEDC_CHANNEL_0); // 人接近検知割り込み  attachInterrupt(PIR_INT,onHumanDetected , FALLING ); } //--------------------------------------------------------------------- // 割り込み設定 //--------------------------------------------------------------------- //---------------------------------------------- // 人を検出したら呼び出される関数 //---------------------------------------------- void onHumanDetected(){ HumanDetected = 1; } //===================================================================== // Main loop //===================================================================== void loop(){ // レジスタ読み出し  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); // IRセンサ  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); // センサ温度  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); if (HumanDetected == 1){ // 人の接近を検知  Serial.println(\u0026#34;Detect!\u0026#34;); // Beep  ledcWriteNote(LEDC_CHANNEL_0, NOTE_C, 5); int pauseBetweenNotes = 1000 / 4 * 1.30; delay(pauseBetweenNotes); // stop the tone  ledcWriteTone(LEDC_CHANNEL_0, 0); HumanDetected = 0; } delay(1000); } //===================================================================== double clacTemp(){ double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000){ val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else{ ret = (double)val * 0.0019837; } return ret + 25; } //===================================================================== double clacIR(){ double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ((val \u0026amp; 0x8000) == 0x8000){ val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else{ ret = (double)(val * 0.4578 ); } return ret; } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- // I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- // I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } //----------------------------------------------- // I2C スレーブデバイスに複数バイト書き込む //----------------------------------------------- void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } //----------------------------------------------- // I2C スレーブデバイスから複数バイト読み込む //----------------------------------------------- void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } ESP32_Human_Sensing.ino\n実行結果 人が近づくと音が鳴ります。\n","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用しま …","ref":"/docs/examples/beginner/2_p/exten/ir_sensor/","title":"人感センサ"},{"body":"\n特徴 Nut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n外形図 \n変更履歴  Rev A: 2019年8月初版  ","excerpt":"\n特徴 Nut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n外形図 \n変更履歴  Rev A: 2019 …","ref":"/en/docs/leaf/others/az63/","title":"AZ63 Nut Plate"},{"body":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI03 MIC\u0026amp;VR\u0026amp;LED 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nMIC\u0026amp;VR\u0026amp;LEDリーフを使うためにはライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください\n//===================================================================== // ESP32 Sound level meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/08/20 First release //=====================================================================  // LED4-6:VRのレベル表示 // LED1-3:MICの音圧レベル表示  #define LED1 14 // D6 IO14 #define LED2 15 // D7 IO15 #define LED3 17 // D8 IO17 #define LED4 16 // D9 IO16 #define LED5 5 // D10 IO5 #define LED6 23 // D11 IO23 #define MIC 26 // A2 IO26 #define VR 39 // A3 IO39  unsigned int dataVR; unsigned int dataMic; //----------------------------------------------- // VRとMICデータを取得する //----------------------------------------------- void getSensorData(){ dataVR = analogRead(VR); dataMic = analogRead(MIC); Serial.println(\u0026#34;---------------------\u0026#34;); Serial.print(\u0026#34;MIC = \u0026#34;); Serial.println(dataMic,DEC); Serial.print(\u0026#34;VR = \u0026#34;); Serial.println(dataVR,DEC); } //----------------------------------------------- // VRとMICの値にあわせてLEDを点灯、消灯させる //----------------------------------------------- void dispSensorData(){ if (dataVR \u0026lt; 1500){ digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 1500 \u0026amp;\u0026amp; dataVR \u0026lt; 2600){ digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 2600 \u0026amp;\u0026amp; dataVR \u0026lt; 3600){ digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else{ digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; 400){ digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= 400 \u0026amp;\u0026amp; dataMic \u0026lt; 600){ digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= 600 \u0026amp;\u0026amp; dataMic \u0026lt; 950){ digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else{ digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup(){ Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); //起動テスト(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); } void loop() { getSensorData(); dispSensorData(); delay(100); } ESP32_Sound_Level_Meter.ino\n実行結果 ボリュームを回転させると回転量に応じた数のLEDが点灯します。マイクにより周囲の音量に応じた数のLEDが点灯します。\n","excerpt":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type …","ref":"/docs/examples/beginner/2_p/exten/sound_level/","title":"サウンドレベルメータ"},{"body":"\n外形図 \n変更履歴  Rev A: 2019年8月初版  ","excerpt":"\n外形図 \n変更履歴  Rev A: 2019年8月初版  ","ref":"/en/docs/leaf/others/az64/","title":"az66 Basic Kit Case"},{"body":"\n特徴 Basic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\n外形図 \n","excerpt":"特徴 Basic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\n外形図","ref":"/en/docs/leaf/others/az66/","title":"AZ66 Basic kit case"},{"body":"\n特徴 ケース（下）\n 外形図\n  ","excerpt":"\n特徴 ケース（下）\n 外形図\n  ","ref":"/en/docs/leaf/others/az65/","title":"AZ64A Lowercase"},{"body":"概要 LCD(液晶ディスプレイ)リーフを使用すると、文字列を簡単に画面に表示することができます。\nまた、ボタンスイッチが2個搭載されていて、コントローラとして使うこともできます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI04 LCD 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : ESP32-WROOM-32 (ESP32 Dev Module) // Arduino IDE : 1.8.13 // Arduino ESP32: 1.0.4 // // Leaf configuration // (1) AI04 LCD // (2) AP02 ESP32 MCU // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2020/08/20 First release //===================================================================== //use libraries //ST7032 - Arduino LiquidCrystal compatible library //https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IOピン一覧 //----------------------------------------------- // D0 IO3 (RXD) // D1 IO1 (TXD) // D2 IO4 (INT0) // D3 IO27 (INT1) // D4 IO12 (H-MISO) // D5 IO13 (H-MOSI) // D6 IO14 (H-SCK) // D7 IO15 (H-SS) // D8 IO17 (UART_TX) // D9 IO16 (UART_RX) // D10 IO5 (SS) // D11 IO23 (MOSI) // D12 IO19 (MISO) // D13 IO18 (SCK) // D14 IO21 (SDA) // D15 IO22 (SCL) // A0 IO36 // A1 IO25 (UART_TX) // A2 IO26 (UART_RX) // A3 IO39 // A4 IO34 // A5 IO35  //----------------------------------------------- // IOピンの名前定義 // 接続するリーフに合わせて定義する //----------------------------------------------- #define SW1 4 // D2 IO4  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8文字, 2行  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8文字, 2行  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop() { char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- //I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } ESP32_LCD-SW_test.ino\n実行結果 LCDに下記の順で画面が表示されます。\n 「Hello」の文字列 カーソルの移動 ボタンの入力状態表示  ","excerpt":"概要 LCD(液晶ディスプレイ)リーフを使用すると、文字列を簡単に画面に表示することができます。\nまた、ボタンスイッチが2個搭載されていて、コントローラとして使うこともできます。\n使用するリー …","ref":"/docs/examples/beginner/2_p/exten/lcd/","title":"LCD"},{"body":"\n特徴 Leafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\nTips コネクタの取り付け・取り外し リーフ基板にコネクタを取り付ける、または、外す場合は下図のように行ってください。\n\u0026ndash; 取り付け\n\u0026ndash; 取り外し\nドキュメント  コネクタの試験結果  変更履歴  Rev A: 2019年8月初版  ","excerpt":"\n特徴 Leafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材 …","ref":"/docs/leaf/others/az61/","title":"AZ61 Connector"},{"body":"\n特徴 Connector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n外形図 \n変更履歴  Rev A: 2019年8月初版  ","excerpt":"\n特徴 Connector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n外形図 \n変更履歴  Rev A: 2019 …","ref":"/docs/leaf/others/az62/","title":"AZ62 Connector Cover"},{"body":"\n特徴 Nut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n外形図 \n変更履歴  Rev A: 2019年8月初版  ","excerpt":"\n特徴 Nut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n外形図 \n変更履歴  Rev A: 2019 …","ref":"/docs/leaf/others/az63/","title":"AZ63 Nut Plate"},{"body":"\n特徴 Basic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\n外形図 \n変更履歴  Rev A: 2019年8月初版  ","excerpt":"\n特徴 Basic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\n外形図 \n変更履歴  Rev A: 2019年8月初版  ","ref":"/docs/leaf/others/az66/","title":"AZ66 Basic kit case"},{"body":"","excerpt":"","ref":"/docs/examples/advanced/1_p/basic/","title":"Basic Kit"},{"body":"公開予定\n概要 Beaconを作成するための最小構成プロジェクト\n用意するもの サンプルアプリのコード Leafonyの構成    Type Name Q\u0026rsquo;ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Leafonyの組み立て ","excerpt":"公開予定\n概要 Beaconを作成するための最小構成プロジェクト\n用意するもの サンプルアプリのコード Leafonyの構成    Type Name Q\u0026rsquo;ty     AC02 BLE …","ref":"/docs/examples/advanced/1_p/basic/simple_ble_advertising/","title":"Simple BLE Advertising"},{"body":"このサンプルはBasic Kit スタートガイドで紹介したものと同様です。ソースコードを読みながら、動作を理解していきましょう。\nはじめに Leafonyは省電力で小型なIoTデバイスの開発を簡単に行えるように、それぞれのリーフが省電力な設計になっています。 バッテリで長時間動作するため、様々な場所に設置してセンサで定点観測を行うことも可能です。\nでは、センサで測定した温度や湿度、照度のようなデータはどのようにして集められるのでしょうか。 一般的にWi-FiやBluetooth、LoRaといった無線通信が用いられるでしょう。 Leafonyでは無線通信規格の中でも省電力なBluetoothを搭載したリーフが存在します。\nBasic Kitは省電力なセンサを複数搭載した4-Sensorリーフと、省電力なBluetooth規格であるBluetooth LE (以下、BLE)を搭載したBLEリーフを使った長時間バッテリ駆動のIoTセンサの開発を簡単に行えるキットです。\nそれでは、Leafonyが送るBLEを受信するためにはどうすれば良いでしょうか。 PCやスマホ・タブレットには色々な環境があります。Windowsが動くPC、MacOSが動くPC、Android、iPhoneなど、身近なものでも非常に沢山の環境が存在します。 これらの環境でBluetoothを使うためには、それぞれの環境に合わせたプログラミング言語で開発するのが普通です。PCであればC言語やPythonなどの言語を使って開発できますが、AndroidやiPhoneであれば、Android StudioやXcode等を使ってまた別のプログラミング言語でソフトを作る必要があります。\n多くの人が様々な環境で使うものを簡単に開発するにはどうすれば良いでしょうか。 今回のサンプルアプリでは一つの方法として、Bluetoothの通信を行いデータを画面に表示するためにWebブラウザを使うことにしました。\n使用する言語はHTMLとJava Scriptです。この2つの言語で記述したプログラムが、Webブラウザ上であればどの環境においても同様に動作します。\nポイント\r Web Bluetoothライブラリを使うと、Bluetooth接続するソフトをWebアプリで記述できる。 Webアプリであればブラウザが動く機器であれば同じソースコードが動く。 表やグラフ等のGUIはHTMLとCSSでラクラク開発  \r用意するもの  Leafony Basic Kit Windows1、 Mac2、 Linux3のどれかのPC (開発用) Android4、 iPhone5、 iPad5のスマートフォンまたはタブレット (テスト用 なくても良い) Google Chrome (バージョン70.0.3526.0以降) Arduino IDE  サンプルアプリのソースコード あらかじめどちらもダウンロードしてください。\n Arduino スケッチ Web Bluetooth アプリ  Leafonyの構成 このサンプルでは下記のリーフ構成で試せます。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nピンアサイン 各リーフのピンアサインは下図を参考\n\n実行方法  Arduino IDEで4-Sensors_BLE.inoを書き込む ダウンロードしたWeb Bluetooth アプリのindex.htmlをGoogle Chromeで開く\nWebアプリの使い方の詳細はBasic Kit クイックスタートガイドを参考  データの送信 BLEでデータを送受信する方法を見てみましょう。\nLeafony側 4-Sensors_BLE.inoの1020行目付近でBluetoothで送信するテキストデータを生成しています。 このテキストを変えることで任意のデータを送信可能です。\nsendLen = sprintf(sendData, \u0026#34;%04s,%04s,%04s,%04s,%04s,%01s\\n\u0026#34;, temp, humid, light, tilt, battVolt, pips) 上記では\u0026lt;温度\u0026gt;,\u0026lt;湿度\u0026gt;,\u0026lt;照度\u0026gt;,\u0026lt;傾き\u0026gt;,\u0026lt;電池電圧\u0026gt;,\u0026lt;サイコロ\u0026gt;のようにカンマ区切りのデータを送信しています。\n実際にこのテキストデータを送信しているのは下記の部分です。(1085行目付近)\nble112.ble_cmd_gatt_server_send_characteristic_notification( 1, 0x000C, sendLen, (const uint8 *)sendData ); Webアプリ側 Webアプリ側ではleafony.jsにデータ受信時の処理が書かれています。\nleafony.jsの75行目の記述で、データを受信した時に呼び出される関数を指定します。 ここではhandleData()という関数が呼び出されます。\nchar.read.addEventListener( \u0026#39;characteristicvaluechanged\u0026#39;, handleData ); handleData()関数もleafony.jsに記述されています。\nBLEで受信したデータはevent.target.valueに含まれています。\n一旦dataという変数に値をコピーした後に、受信データをutf-8でデコードし、改行コード(\\r\\n)を取り除いてから、カンマ,で区切って配列にしています。\nこれらのデータはstateという変数に任意の名前をつけて保存しています。(state.tempやstate.humidなど)\nLeafony側で送るデータを変更した際は、handleData()関数を修正することでデコードすることが可能です。\n/** * Characteristicの値が変化した時に呼び出される関数 * @param {*} event */ function handleData( event ) { // 受信したデータの文字コードを変換して、カンマでデータを分けている  // このサンプルではLeafonyは  // 温度,湿度,傾き,電池の電圧  // のようにカンマ区切りのテキストを送信している。  let data = event.target.value; let decoder = new TextDecoder( \u0026#39;utf-8\u0026#39; ); data = decoder.decode( data ); data = data.replace( /\\r?\\n/g, \u0026#39;\u0026#39; ); data = data.split( \u0026#39;,\u0026#39; ); state.devn = deviceName; state.unin = uniqueName; state.temp = data[0]; state.humd = data[1]; state.illm = data[2]; state.tilt = data[3]; state.batt = data[4]; state.dice = data[5]; // ここで updateTable() が実行されている  onStateChangeCallback( state ); // 省略  } データの受信 Webアプリ側 Webアプリの画面で「LED+」「LED-」ボタンを押すと、LeafonyのLEDの点滅スピードを変えることができます。\nボタン押された時の処理はapp.jsの下記の部分に記述されています。\nbuttonLedPls.addEventListener ( \u0026#39;click\u0026#39;, function () { console.log( \u0026#39;LED Plus Button Clicked\u0026#39; ); leafony.sendCommand( \u0026#39;PLS\u0026#39; ); }); leafony.sendCommand( '文字列' );で任意の文字列をLeafonyに送信しています。\nLeafony側 Webアプリ側から送信された文字列をLeafonyが受信したとき、4-Sensors.inoのmy_evt_gatt_server_attribute_value()関数が呼び出されます。\nデコードされた文字列はrcv_dataという変数にコピーされ、その文字列の内容に応じた処理をしています。\nvoid my_evt_gatt_server_attribute_value( const struct ble_msg_gatt_server_attribute_value_evt_t *msg ) { uint16 attribute = (uint16)msg -\u0026gt; attribute; uint16 offset = 0; uint8 value_len = msg -\u0026gt; value.len; uint8 value_data[20]; String rcv_data; rcv_data = \u0026#34;\u0026#34;; for (uint8_t i = 0; i \u0026lt; value_len; i++) { rcv_data += (char)(msg -\u0026gt; value.data[i]); } // 中略  if( rcv_data.indexOf(\u0026#34;SND\u0026#34;) == 0 ){ bBLEsendData = true; iToggle = 8; } else if( rcv_data.indexOf(\u0026#34;STP\u0026#34;) == 0 ){ bBLEsendData = false; bLCDchange = true; lcd_view_sts = 1; } else if(rcv_data.indexOf(\u0026#34;PLS\u0026#34;) == 0){ if(iToggle \u0026lt; 16){ iToggle += 2; } } else if(rcv_data.indexOf(\u0026#34;MNS\u0026#34;) == 0){ if(iToggle \u0026gt; 2){ iToggle -= 2; } } } 上記の部分を修正することで簡単にデータの送受信を行うことができます。\n仕組み  PeripheralとCentral アドバタイズ GATT Characteristic  Webアプリ側 index.htmlとapp.jsとleafony.jsの3つのファイルで構成されています。\nindex.htmlはボタンや表の配置を行ったり、他2つのjavascriptのファイルを読み込むだけの単純なものです。\napp.jsはボタンが押されたときの処理などメインの処理が記述されています。\nleafony.jsはWeb Bluetoothを使ってLeafonyと接続するための具体的な処理がかかれています。\nWeb Bluetoothの注意点 2020年6月時点ではWeb Bluetoothは以下の点に注意しなければいけません。\n iPhoneのChromeでは動作しません。WebBLEという有料のアプリを使えば利用可能です。 Web Bluetoothの開発状況と対応ブラウザについてはimplementation-status.mdで確認できます。  参考 https://qiita.com/s_nkg/items/bdb235388eaeb567b54d\n  Windows 10 version 1703以降 \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite以降 \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow以降 \u0026#x21a9;\u0026#xfe0e;\n iPhoneまたはiPadの場合は WebBLE(有料)が必要です。iPhone、iPad版のChromeではWeb Bluetoothが実装されていないためです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"このサンプルはBasic Kit スタートガイドで紹介したものと同様です。ソースコードを読みながら、動作を理解していきましょう。\nはじめに Leafonyは省電力で小型なIoTデバイスの開発を簡単に行 …","ref":"/docs/examples/advanced/1_p/basic/webbluetooth_iot/","title":"Web Bluetoothを使ったIoTアプリ入門"},{"body":"概要 Leafony Beacon1)とRaspberry Piとを使ってIoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\n Beaconとは、地上にある電波を特定の機器で受信することで、位置をはじめとした各種情報を取得するための設備です。BluetoothのBeacon機器の場合、温度や気圧などのセンサを搭載したモジュールを任意の場所に設置して、その場所の環境を観測します。  用意するもの  Leafony Basic Kit Raspberry Pi (3, 4, zero等) ブラウザが閲覧できるPCやスマホ Arduino IDE  サンプルアプリのコード  Github - Leafony/leafony-beacon  Raspberry Piの準備  Raspberry Pi 初めての方は、Raspberry Pi 3 B＋ スターターキット（ https://www.switch-science.com/catalog/3880/ ）が便利です。Raspbian OSイメージを書き込んだmicroSDが入っていますが、ディスプレイ、キーボード、マウスは有りません。別途　ご用意してください。 Raspberry Pi は、無線LANでインターネットに接続します。こちらも事前にご用意してください。  Leafonyの構成    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Leafonyの組み立て スケッチの書き込み  書き込みには、BLE、4-Sensorsライブラリが必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで、以下のスケッチをマイコンボードに書き込んでください。 ・leafony_beacon.ino Arduino IDE 1.8.9で動作を確認しています。書き込みエラーが発生したら、IDEのバージョンを確認してください。  Raspberry Piの環境構築 BLE Beaconの受信機にはRaspberry Piを使います。今回使用するサンプルコードでは、Node.jsでnobleを使ってBLE Beaconを受信します。受信したデータはGoogle API経由でGoogle スプレッドシートに書き込んでいます。\n下記のスクリプト(6項目)を実行して環境構築をします。https://github.com/Leafony/leafony-beacon/tree/master/spreadsheet-logger\nsudo apt update sudo apt upgrade sudo apt install -y bluetooth libbluetooth-dev libudev-dev git git clone https://github.com/Leafony/leafony-beacon cd leafony-beacon/spreadsheet-logger npm install 注意:WARNINGと表示されますが、このまま進んでください。\nGoogle Sheets APIの取得 Google スプレットシートをNode.jsで操作するためにはAPIを取得する必要があります。まず、下記 Node.js Quick Start のStep.1で、 Enable the Google Sheets API をクリックし、credentials.jsonをダウンロードします。次に、credentials.jsonをleafony-beacon/spreadsheet-loggerディレクトリにコピーしてください。\nNode.js Quickstart | Sheets API | Google Developers : https://developers.google.com/sheets/api/quickstart/nodejs\nindex.js へGoogle SheetsのIDとシート名の設定 Google スプレッドシート を開いて、URLの赤線部分の「シートID」と「シート名」を確認します。\nleafony-beacon/spreadsheet-loggerディレクトリ「index.js」があります。「index.js」の18, 19行目にある「spreadsheetId」と「sheetName」に、上記の「シートID」と「シート名」を貼り付けることで、データが書き込まれます。\nアプリの実行 Raspberry piのターミナルに「sudo node .」と入力してEnterをクリックしてください。\n上記URLにブラウザでアクセスすると、Googleアカウントに移動し、ご自身のアカウントを選択します。\n「詳細」をクリックしてください。\n「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。\n「詳細」をクリックしてください。\n「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。\n「許可」をクリックしてください。以下のコードをコピーしてください。ターミナル内に貼り付けると、「token.json」というファイルが生成されたあとに、beaconのスキャンが始まります。\nBeaconが見つかるとログが表示されると同時に、スプレッドシートに同じ内容が追記されるので、スプレッドシートを開いてデータを確認してください。\n","excerpt":"概要 Leafony Beacon1)とRaspberry Piとを使ってIoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\n Beaconとは、地上にある電 …","ref":"/docs/examples/advanced/1_p/basic/google_sheets_iot/","title":"Google SheetsをつかったIoTサービス入門"},{"body":"","excerpt":"","ref":"/docs/examples/advanced/1_p/exten/","title":"Basic Kit + Extension Kit"},{"body":"AVR MCUを使ったサンプルアプリです。\n","excerpt":"AVR MCUを使ったサンプルアプリです。","ref":"/docs/examples/beginner/1_p/","title":"AVR MCU Examples"},{"body":"AVR MCUを使ったサンプルアプリです。\n","excerpt":"AVR MCUを使ったサンプルアプリです。","ref":"/docs/examples/advanced/1_p/","title":"AVR MCU Examples"},{"body":"ESP32 MCUを使ったサンプルアプリです。\n","excerpt":"ESP32 MCUを使ったサンプルアプリです。","ref":"/docs/examples/beginner/2_p/","title":"ESP32 MCU Examples"},{"body":"ESP32 MCUを使ったサンプルアプリです。\n","excerpt":"ESP32 MCUを使ったサンプルアプリです。","ref":"/docs/examples/advanced/2_p/","title":"ESP32 MCU Examples"},{"body":"LoRaリーフを使ったサンプルアプリです。\n","excerpt":"LoRaリーフを使ったサンプルアプリです。","ref":"/docs/examples/advanced/1_p/lora/","title":"Basic Kit + LoRa"},{"body":"ESP32 MCUリーフを使ったサンプルアプリです。\n","excerpt":"ESP32 MCUリーフを使ったサンプルアプリです。","ref":"/docs/examples/advanced/2_p/esp32/","title":"ESP32W-iFi Kit"},{"body":"概要 このサンプルアプリでは，ESP32リーフのWiFi機能を利用して，取得したセンサデータをGoogle Sheetsへ転送します。\nGoogle Sheets上では受け取ったセンサデータをグラフ描画します。\nこれによりセンサデータを簡単に管理出来るようになります。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover  2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て ESP32と4-Sensorsリーフを重ねてねじ止めします。\nソースコード 使用するスケッチは下記のGitHubリポジトリにあります。\nLeafony/Sample-Sketches/ESP32_GoogleSheets - GitHub\n実行方法 Google Sheetsの準備 データ転送先Google Sheetsの作成 スクリプトエディタを開く  Google Sheetsのタイトル（デフォルト：無題のスプレッドシート）は自由に変更して大丈夫です。 また，シート番号（デフォルト：シート1）も自由に変更して大丈夫です。 下のGoogle SheetsのURLの部分の赤枠で囲った記号列は，後でGoogle Sheetを指定するのに利用するので，適当な場所にコピーしておいてください。  ここでは，1kuK8196yuY9n37fLHc2ScT7OJUFTyGkiyY9nIuYmNGY    スクリプトの記述  Githubのソースコードをコピー\u0026amp;ペーストしてください。  Leafony/Sample-Sketches/ESP32_GoogleSheets/google_scripts_code.js - GitHub   以下の変数に，先ほど作成したGoogle Sheetの情報を入力してください。  id：先ほどコピーしたGoogle SheetsのURLの記号列 sheetName：書き込み先のシート名（デフォルト：シート1）    スクリプトのデプロイ 公開-\u0026gt;ウェブアプリケーションとして導入をクリックします。\n続いて開いたウィンドウで，ESP32から簡単にアクセス出来るように権限をAnyone, even anonymousに変更します。\nデプロイボタンを押すと，Script AppからGoogle Sheetsへのアクセス権限の確認が行なわれるので，許可を確認をクリックします。\n次に警告が出るので，以下をクリックします。\n最後にスクリプトからスプレッドシートへのアクセスリクエストを許可してください。\n以下のポップアップ画面が表示され，今回作成したウェブアプリのURLが発行されるので，URLをコピーしてはいをクリックしてください。\nなお，今回の例ではURLは以下のようになっています。\nhttps://script.google.com/macros/s/AKfycbxbxoqWzuN8Eztplnhf3ywC-0QpWc8utkIY1QLngj4fHJFRvZKh/exec\r以上でGoogle Sheets側の設定は完了です。\nスクリプトを修正して再デプロイ  公開-\u0026gt;ウェブアプリケーションとして導入をクリックします。 最初と全く同じ設定でデプロイすると修正したコードがうまく反映されないことがあるので，再デプロイのときはProject versionをNewに設定して更新をクリックします。 またその時動作しているウェブアプリのURLをここから確認出来ます  Google Sheetsの動作確認  ブラウザから先ほどコピーしたGoogle Scriptの記号列を使ってアクセスするとSpread Sheetにデータが書き込まれます 今回は試しに111, 222, 333のデータを書き込んでみます ここでは先ほど確認したウェブアプリのURLにアクセスすることでデータの書き込みが出来ます。 Spread Sheetに以下のようにデータが書き込まれていれば成功です。  今回の場合のアクセスするURL\rhttps://script.google.com/macros/s/AKfycbxbxoqWzuN8Eztplnhf3ywC-0QpWc8utkIY1QLngj4fHJFRvZKh/exec?temperature=111\u0026amp;humidity=222\u0026amp;brightness=333\rArduinoの準備 Githubのソースコードの以下の箇条書きの内容に注意して修正し，ESP32リーフに書き込んで下さい。\nLeafony/Sample-Sketches/ESP32_GoogleSheets/google_scripts_code.js - GitHub\n アクセスするWiFiの情報を以下の定数に代入してください。  const char* SSID = \u0026quot;wifi_ssid\u0026quot;; // WiFi SSID\rconst char* PASSWORD = \u0026quot;wifi_password\u0026quot;; // WiFi Password\r 先ほど作成したウェブアプリの情報を以下の定数に代入してください。  今回の例：const char* KEY = AKfycbxbxoqWzuN8Eztplnhf3ywC-0QpWc8utkIY1QLngj4fHJFRvZKh    const char* KEY = \u0026quot;google_scripts_key\u0026quot;;\r センサデータの書き込みの時間間隔を調整したいときは以下の定数に代入してください。  単位は秒です    uint64_t DEEP_SLEEP_TIME_SEC = 60;\r実行結果  Arduinoを実行して，逐次センサデータがGoogle Sheetsに書き込まれます。 お好みでGoogle Sheetsに新しいシートを追加して，センサデータをグラフ描画も簡単に実装出来ます。  ","excerpt":"概要 このサンプルアプリでは，ESP32リーフのWiFi機能を利用して，取得したセンサデータをGoogle Sheetsへ転送します。\nGoogle Sheets上では受け取ったセンサデータをグラフ描 …","ref":"/docs/examples/advanced/2_p/esp32/esp32_googlesheets/","title":"ESP32からGoogle Sheetsへのデータ転送"},{"body":"概要 ESP32 MCUリーフと4-Sensorsリーフだけで、IoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\nGoogle Sheetsの準備   Googleアカウントにログインし、新しいスプレッドシートを作成しましょう。アカウントがない場合は作成してください。\n  Google Sheetsのタイトル（デフォルト：無題のスプレッドシート）は自由に変更して大丈夫です。\nまた、シート番号（デフォルト：シート1）も自由に変更して大丈夫です。\n  下のGoogle SheetsのURLの部分の赤枠で囲った記号列は、後でGoogle Sheetを指定するのに利用するので、適当な場所にコピーしておいてください。\n ここでは、1o0cogc3aomAj58CRdMZARNJtoEmf8dB9ebY02jKV9tA    \nツールからスクリプトエディタを開き、Githubのソースコードをコピー\u0026amp;ペーストしてください。  Leafony/Sample-Sketches/ESP32_GoogleSheets/google_scripts_code.js - GitHub    \n以下の変数に、先ほど作成したGoogle Sheetsの情報を入力してください。  google_sheets_id：先ほどコピーしたGoogle SheetsのURLの記号列 sheet_name：書き込み先のシート名（デフォルト：シート1）    \nGoogle Sheetsを公開する手順について、説明します。\n公開-\u0026gt;ウェブアプリケーションとして導入をクリックします。  \n続いて、アクセスの権限をAnyone, even anonymousに変更し、誰でも閲覧できるようにします。  \nデプロイボタンを押すと、Script AppからGoogle Sheetsへのアクセス権限の確認が行なわれるので、許可を確認をクリックします。  \n次に警告が出るので、以下をクリックします。  \n最後にスクリプトからスプレッドシートへのアクセスリクエストを許可してください。  \n以下のポップアップ画面が表示され、今回作成したウェブアプリ固有のURLが発行されるので、URLをコピーしてOKをクリックしてください。  \n（アプリ固有のURL）\nhttps://script.google.com/macros/s/AKfycbw-8Wx8Zf0alULuD3aLQdwnyVM8hSHAiDsrj49wA17ZqE7y-tP8/exec\rGoogle Sheetsの動作確認   今回は試しに、Datetime、UniqueID=Leafony_AP02-1、Temperature=100、Humidity=100、Illumination=100 を、Google Sheetsに書き込んでみます。\n  アプリ固有のURLに、?UniqueID=Leafony_AP02-1\u0026amp;temperature=100\u0026amp;humidity=100\u0026amp;illumination=100を追加すると、以下の通りになります。\n  https://script.google.com/macros/s/AKfycbw-8Wx8Zf0alULuD3aLQdwnyVM8hSHAiDsrj49wA17ZqE7y-tP8/exec?UniqueID=Leafony_AP02-1\u0026amp;temperature=100\u0026amp;humidity=100\u0026amp;illumination=100\r\n上記のURLにアクセスすると、設定したGoogle Sheetsにデータが書き込まれます。  Google Sheetsの1行目に記載されているカラム名は自動表示されないため、予めご記載ください。 \nスクリプトのミスがあった場合  スクリプトを修正します。 公開-\u0026gt;ウェブアプリケーションとして導入をクリックします。 最初と全く同じ設定でデプロイすると修正したコードがうまく反映されないことがあるので、再デプロイのときはProject versionをNewに設定して更新をクリックします。 またその時動作しているウェブアプリのURLは以下で確認出来ます。  ","excerpt":"概要 ESP32 MCUリーフと4-Sensorsリーフだけで、IoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\nGoogle Sheets …","ref":"/docs/examples/advanced/2_p/esp32/esp32_googlesheets_1/","title":"Google SheetsをつかったIoTサービス その1"},{"body":"ESP32の設定 リーフを組み立ててスケッチを書き込み、データがGoogle Sheetsに書き込まれることを確認しましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover  2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て ESP32 MCUリーフと4-Sensorsリーフを重ねて、下図のようにねじ止めします。\nソースコード あらかじめダウンロードしてください。\n Arduino スケッチ  Githubのソースコードの以下の箇条書きの内容に注意して修正し、ESP32リーフに書き込んで下さい。\n アクセスするWiFiの情報を以下の定数に代入してください。  const char* SSID = \u0026quot;wifi_ssid\u0026quot;; // WiFi SSID\rconst char* PASSWORD = \u0026quot;wifi_password\u0026quot;; // WiFi Password\r先ほど作成したウェブアプリの情報を以下の定数に代入してください。  アプリ固有のURLより：const char* KEY = AKfycbxbxoqWzuN8Eztplnhf3ywC-0QpWc8utkIY1QLngj4fHJFRvZKh    const char* KEY = \u0026quot;google_scripts_key\u0026quot;;\rセンサデータの書き込みの時間間隔を調整したいときは以下の定数に代入してください。  単位は秒です    uint64_t DEEP_SLEEP_TIME_SEC = 60;\r#include \u0026lt;Arduino.h\u0026gt;#include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTTPClient.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; // Unique ID String UniqueID = \u0026#34;Leafony_AP02\u0026#34;; // Connecting WiFi Settings const char* SSID = \u0026#34;wifi_ssid\u0026#34;; // WiFi SSID const char* PASSWORD = \u0026#34;wifi_password\u0026#34;; // WiFi Password // Accessed Google Script Settings const char* APP_SERVER = \u0026#34;script.google.com\u0026#34;; const char* KEY = \u0026#34;google_scripts_key\u0026#34;; // Device sleep time (sec) to reduce Joule heat uint64_t DEEP_SLEEP_TIME_SEC = 60; // 省略 実行結果  Arduinoを実行して、逐次センサデータがGoogle Sheetsに書き込まれます。  ","excerpt":"ESP32の設定 リーフを組み立ててスケッチを書き込み、データがGoogle Sheetsに書き込まれることを確認しましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name …","ref":"/docs/examples/advanced/2_p/esp32/esp32_googlesheets_2/","title":"Google SheetsをつかったIoTサービス その2"},{"body":"概要 工場出荷時に、ESP32 MCUリーフにArduinoのスケッチが書き込まれているので、スマートフォンやパソコンのWi-Fiを使ってタッチセンサの値を送信して、表示がされます。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AX07 Back to back 1   AX08 29pin header 1   AZ62 Connector Cover  2   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*15mm screw 4    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nピンアサイン 各リーフのピンアサインは下図を参考\n\nソースコード 使用するスケッチは下記のGitHubリポジトリにあります。\nLeafony/Sample-Sketches/ESP32_AP_Touch - GitHub\n実行方法  単4電池ボックスに電池を挿入し、ESP32リーフの電源スイッチを入れる PCまたはスマートフォンで下記のWi-Fiに接続する  SSID: Leafony_ESP32-AP Password: password   PCまたはスマートフォンでWebブラウザを起動し、http://192.168.4.1にアクセス 29pin headerの7、9、22、24、26、28ピンがタッチセンサに割り当てられています。\nピンに触れると静電容量が減るため、値が減少します。値が閾値20以下になると”Touch detected”と表示されます。\n(24ピンはRTC\u0026amp;microSDと干渉しているため、サンプルスケッチでは非表示にしています。検出閾値は、スケッチで変更可能です。以下の写真では、指先で26ピンに触れています。)  26ピンに触れていると、以下のようにブラウザの表示が変化します。　  ","excerpt":"概要 工場出荷時に、ESP32 MCUリーフにArduinoのスケッチが書き込まれているので、スマートフォンやパソコンのWi-Fiを使ってタッチセンサの値を送信して、表示がされます。\n使用するリーフ  …","ref":"/docs/examples/advanced/2_p/esp32/wifi_touchsensor/","title":"Wi-Fi タッチセンサ"},{"body":"はじめに ESP32を使ったBLE Beacon型の環境センサアプリケーションの例です。 GATT ServerのAttributeにセンサデータを入れることで、データをブロードキャストするBeaconとして動作するとともに、 外部から接続要求があった場合にはサーバクライアント型の通信を行い、Characteristicでログデータのやり取りを行います。\nBeacon型で発生するパケットの受信失敗によるデータの損失を、ESP32内の不揮発メモリにセンサデータを残すことで防ぎます。 ユーザは任意のタイミングで接続してログデータを読み出す事ができ、データ転送完了後にはすぐにBeaconモードに移行することで電力の消費を大幅に抑えます。\nサンプルのソースコード 使用するスケッチやツールのソースコードは下記のリポジトリで閲覧可能です。\nSample-Sketches/ESP32_BLE_Beacon at master · Leafony/Sample-Sketches\n用意するもの  Leafony ESP32 Wi-Fi Kit Leafony Basic Kit Raspberry Pi Androidスマートフォン USB microケーブル  使用するリーフ    Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1   AI01 4-Sensors 1    M2 screw 2    動作方法 サンプルのプロジェクトを動かす手順について説明します。各ソースコードの動作の仕組みについて理解したい場合は、後述する仕組みをご覧ください。\n1. ESP32リーフにスケッチを書き込む ESP32リーフとPCをUSBで接続し、Arduino IDEでinoファイルを書き込んでください。\nサンプルコードにはESP32 Logging Libraryが使用されています。\nArduino IDEの「ツール → Code Debug Level」を任意のレベルに設定することでシリアルモニタにデバッグメッセージが表示されるようになります。\n2. ビーコンスキャナアプリを実行 AdvertisingパケットのScanningにはNode.jsで動くアプリを使用します。\nNode.jsが動く環境であれば動作環境は問いませんが、今回は屋外に定点設置するBeacon受信機とすることを想定し、 Raspberry Pi 4を使ってアプリの動作方法について解説します。\n必要なパッケージをインストールしてアプリ実行します。\ncd ./tools/node-scanner npm install npm start 3. ログ取得アプリを実行 ログデータの取得とグラフの表示にはWebアプリケーションを使用します。\nESP32 Sensors Logger\n仕組み BLE Beaconの仕組み GATT Advertising Characteristic ","excerpt":"はじめに ESP32を使ったBLE Beacon型の環境センサアプリケーションの例です。 GATT ServerのAttributeにセンサデータを入れることで、データをブロードキャストす …","ref":"/docs/examples/advanced/2_p/esp32/esp32_ble_beacon/","title":"ESP32 BLE Beacon"},{"body":"","excerpt":"","ref":"/en/index.json","title":""},{"body":"","excerpt":"","ref":"/index.json","title":""},{"body":"Overview  はじめに 製品一覧 用語の説明 ライセンス お問合せ  Quick start  クイックスタート  System  サンプルアプリ・応用例  Software  開発環境設定  Hardware  Leafonyブロック組立 自作リーフ開発 Leafony バス  Leaf  個別リーフ技術資料  ","excerpt":"Overview  はじめに 製品一覧 用語の説明 ライセンス お問合せ  Quick start  クイックスタート  System  サンプルアプリ・応用例  Software …","ref":"/docs/","title":"Documentation"},{"body":"\r\r#td-cover-block-0 {\rbackground-image: url(/en/featured-background_hubf9a9d0a00ddac7fb58721d040adf027_267411_960x540_fill_q75_catmullrom_top.jpg); }\r@media only screen and (min-width: 1200px) {\r#td-cover-block-0 {\rbackground-image: url(/en/featured-background_hubf9a9d0a00ddac7fb58721d040adf027_267411_1920x1080_fill_q75_catmullrom_top.jpg); }\r}\r\rLeafony an open innovation platform\rLearn More \r\rOnline Shop \r\rAn open innovation platform\n\n\r\r\r\r\r\r\r\rEnjoy IoT with the Leafony\r\r\r\r\r\r\rEasy Circuit Development\rLeafony makes the circuit design easy. Stack each module and make new circuits.\n\r\r\rOpen Source Hardware\rLeafony is an OSS project. All codes, circuits and designes are available on GitHub. Free for both personal and commercial use.\nRead more …\n\r\r\rNews\rCheck the latest news\nRead more …\n\r\r\r\r","excerpt":"#td-cover-block-0 {\rbackground-image: …","ref":"/en/","title":"Leafony"},{"body":"\r\r#td-cover-block-0 {\rbackground-image: url(/featured-background_hubf9a9d0a00ddac7fb58721d040adf027_267411_960x540_fill_q75_catmullrom_top.jpg); }\r@media only screen and (min-width: 1200px) {\r#td-cover-block-0 {\rbackground-image: url(/featured-background_hubf9a9d0a00ddac7fb58721d040adf027_267411_1920x1080_fill_q75_catmullrom_top.jpg); }\r}\r\rLeafony\rDocumentation \r\rShop　\r\rAn open innovation platform\n\r\r\r\r\r\r\r\rIoT向けのシステムを誰でも簡単に創れる小型・低消費電力プラットフォーム「Leafony」 \r\r\r\r\r\r超小型・簡単\r1円玉と同じ大きさ　新規開発のコネクタで組立はブロック玩具のように簡単　足りない機能だけをリーフ（電子基板モジュール）にするので短期間で開発\n\r\r\r低消費電力\rスタンバイモードやソフトウェアで制御可能な電源スイッチを搭載しているのでコイン電池駆動可能\n\r\r\rオープン\r商用でも無償で使える仕様、回路図、基板レイアウトなどのハードウェアやソフトウェアを公開\n\r\r\r\r活用事例\r\r\r\r\rサードパーティ\r\r\r\r\r作品例\r\r\r\r\r\r\r\r// --","excerpt":"\r\r#td-cover-block-0 {\rbackground-image: …","ref":"/","title":"Leafony"},{"body":"","excerpt":"","ref":"/en/search/","title":"Search Results"},{"body":"\rLeafonyを購入\r販売代理店一覧\nスタイル修正予定\n\r\r\r\r\r\r\r日本 \r\r\r\r\r\rCompany Name\rDescription\n\r\r\rCompany Name\rDescription\n\r\r\rCompany Name\rDescription\n\r\r\r\r\rCountry Name \r\r\r\r\r\rCompany Name\rDescription\n\r\r\rCompany Name\rDescription\n\r\r\rCompany Name\rDescription\n\r\r\r\r","excerpt":"\rLeafonyを購入\r販売代理店一覧\nスタイル修正予定\n\r\r\r\r\r\r\r日本 \r\r\r\r\r\rCompany Name\rDescription\n\r\r\rCompany Name\rDescription …","ref":"/en/shop/","title":"Online Shop"},{"body":"\rLeafony Online Shop\r\r\r\r\r\r\r\rLeafony Original \r\r\r\r\r\rLeafony Systems\rDescription\n続きを読む …\n\r\r\r\r\rJapan \r\r\r\r\r\rCompany Name\rDescription\n\r\r\rCompany Name\rDescription\n\r\r\rCompany Name\rDescription\n\r\r\r\r","excerpt":"\rLeafony Online Shop\r\r\r\r\r\r\r\rLeafony Original \r\r\r\r\r\rLeafony Systems\rDescription\n続きを読む …\n\r\r\r\r\rJapan …","ref":"/shop/","title":"Shop"},{"body":"About Leafony  Overview Our Products Licecnse Terms  For Creators  Getting Started Environment Settings Examples  For Developers  Leaf Technical Documents PCB  ","excerpt":"About Leafony  Overview Our Products Licecnse Terms  For Creators  Getting Started Environment …","ref":"/en/docs/","title":"Leafony Documentation Pages"},{"body":"","excerpt":"","ref":"/search/","title":"検索結果"}]