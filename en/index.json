[{"body":"Leafony only works when you write a program. For example, in Quick Start, a program has been written to read the four sensors and send data via Bluetooth LE.\nIf you are starting to use Leafony, you can make it work the way you want it to by writing a program that describes what you want it to do.\nNext Install the software needed to write a program in Leafony  What to prepare  Basic Kit PC (Windows, Mac OS X or Linux)  Installing Arduino IDE The Arduino IDE is a development environment for the Arduino, an open source hardware platform for electronics. . The development environment allows you to write programs, write programs to the Arduino board, and display the data coming from the board. . Leafony can be developed with the Arduino IDE.\nLet\u0026rsquo;s download the Arduino IDE right away.\n From the Arduino website, go to \u0026ldquo;SOFTWARE\u0026rdquo; and then \u0026ldquo;DOWNLOADS\u0026rdquo; to get to the Arduino IDE download page. Download the installer for your OS at the place where it says \u0026ldquo;Download the Arduino IDE\u0026rdquo;. Run the downloaded installer and follow the on-screen instructions to install the Arduino IDE.  Next Let’s write a program in Leafony and make it work!  Connecting to PC Connect to your PC with a USB cable.\nConfiguration of the microcontroller board To develop Leafony in the Arduino IDE, let\u0026rsquo;s follow the steps below to configure the IDE.\n Go to Tools → Board and select Arduino Pro or Pro Mini and ATmega328P (3.3V, 8MHz) for Processor.  \nGo to Tools → Serial Port and select the serial port that Leafony is connected to  Checking the operation of the microcontroller board  In the Arduino IDE, click on File → Sketch Examples → 01.Basics → Blink to open the sample app. The program is written to Leafony by pressing the write to microcontroller button. If you can confirm that the LED on the AVR MCU leaf is blinking, you are done.  When in doubt. If it doesn\u0026rsquo;t work, go to \u0026ldquo;Solution\u0026rdquo; to find a solution.\nNext A number of programs are available in Sample App. To make development easier, install the library and get started.  Installing Libraries To use some of the leaves, you will need to install additional libraries. Follow the steps below to install all libraries in advance.\n1. Library to use The libraries used in each Kit are as follows.\n  Leaf Required Library Recommended version Description     BLE TBGLib  Bluetooth Library   4-Sensors Adafruit_Sensor.h  Unified Sensor Driver   Adafruit_BusIO_Register.h  Bus IO Library   HTS221.h  Temperature and humidity sensor library   ClosedCube_OPT3001.h  Illuminance sensor library   Adafruit_LIS3DH.h 1.1.2 Accelerometer Library   LCD ST7032.h  LCD Library   AVR MCU MsTimer2.h  Timer interrupt library   RTC\u0026MicroSD RTClib.h  RTC Library    2. Download Library Clicking on the links in the table above will take you to the library\u0026rsquo;s GitHub repository. Click Code → Download ZIP to download the library.\n3. Include Library Launch the Arduino and choose Sketch → Include Library → Install ZIP Library to load the zip file you just downloaded.\n","excerpt":"Leafony only works when you write a program. For example, in Quick Start, a program has been written …","ref":"https://docs.leafony.com/en/docs/environment/avr/arduino/","title":"Arduino IDE Settings for AVR MCU"},{"body":"Follow the steps below to set up the ESP32 Wi-Fi Kit development environment.\nNext Install the software needed to write a program in Leafony.  What to prepare  ESP32 Wi-Fi Kit PC (Windows, Mac OS X or Linux)  Installing Arduino IDE The Arduino IDE is a development environment for the Arduino, an open source hardware platform for electronics. The development environment allows you to write programs, write programs to the Arduino board, and display the data coming from the board. Leafony can be developed with the Arduino IDE.\nLet\u0026rsquo;s download the Arduino IDE right away.\n From the Arduino website, go to SOFTWARE and then DOWNLOADS to get to the Arduino IDE download page. Download the installer for your OS at the place where it says Download the Arduino IDE. Run the downloaded installer and follow the on-screen instructions to install the Arduino IDE.  Next Let’s write a program in Leafony and make it work!  Connecting to PC Connect to your PC with a USB cable.\nConfiguration of the microcontroller board To use the ESP32 MCU leaf with the Arduino IDE, you need to install Arduino core for the ESP32.\n Open the File → Preferences in the Arduino IDE and enter the following URL in the Additional Board Manager URL: field.  　https://dl.espressif.com/dl/package_esp32_index.json\n\nSelect Tools -\u0026gt; Board -\u0026gt; Board Manager, search for esp32 by Espressif Systems and press the Install button.  \nChoose Tools → Board → ESP32 Dev Module to get your ESP32 MCU working.  Checking the operation of the microcontroller board Let\u0026rsquo;s write a Sample App and get the ESP32 Wi-Fi Kit running.\n Launch the Arduino. Paste the following sample code into your code editor.  //***************************** // ボタン入力の状態をシリアルモニタに表示するサンプル //***************************** int pushButton = 0; void setup() { Serial.begin(115200); pinMode(pushButton, INPUT); } void loop() { int buttonState = digitalRead(pushButton); Serial.println(buttonState); delay(1); } Select the COM port to which the ESP32 leaf is connected. Push the write to microcomputer board button to write a sketch. Press and hold the Boot mode switch on the ESP32 leaf when the following message appears during the writing process.  \nOpen the serial monitor and set the communication speed to 115200bps. Press the Boot mode switch (IO0) and see if the input state of the switch changes.  \nWhen in doubt. If it doesn\u0026rsquo;t work, go to \u0026ldquo;If it doesn\u0026rsquo;t work\u0026hellip;\u0026rdquo; to find a solution.\nNext A number of programs are available in Sample App. To make development easier, install the library and get started.  Installing Libraries To use some of the leaves, you will need to install additional libraries. Here to install all libraries in advance.\n","excerpt":"Follow the steps below to set up the ESP32 Wi-Fi Kit development environment.\nNext Install the …","ref":"https://docs.leafony.com/en/docs/environment/esp32/arduino/","title":"Arduino IDE Settings for ESP32 MCU"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/environment/avr/","title":"AVR MCU Development Environment Settings Manual"},{"body":"The Basic Kit is a small, coin cell powered development kit that includes a 4-Sensors leaf with temperature, humidity, illuminance and acceleration sensors, an AVR MCU leaf and a Bluetooth LE leaf.\nIt\u0026rsquo;s easy to send sensor information to a smartphone or computer via Bluetooth and to control the LEDs in the Basic Kit.\nThe Basic Kit has this program written into it that you can use right out of the box.\nOn the smartphone or computer side, an app called \u0026ldquo;Web Bluetooth\u0026rdquo; can be used to connect to the Basic Kit on any platform, with no installation required.\nWhat to prepare  Basic Kit Windows1, Mac2, Linux3, PC with Chrome OS or Android4, iPhone5, iPad5 smartphone or tablet Google Chrome (Since version 70.0.3526.0)6  Demo Video   Setup  Insert the CR2032 coin cell battery into the Basic Kit and turn on the power switch.    Usage  For Android For iPhone or iPad On Windows or macOS On Linux  For Android  Open Google Chrome. Open web app. Press the Connect button of the web app, select Leafony_AC02 and press the Pair button.\n   Connection complete.\n  The sample app used in this article is \u0026ldquo;Introduction to IoT Apps using Web Bluetooth\u0026rdquo;. You can see the source code and how it works here.\n  Next Steps Environment Settings and write the program in the Basic Kit.  For iPhone or iPad  Download WebBLE (paid) from the App Store5 Copy the following URL, launch WebBLE and paste it into the address bar.   https://docs.leafony.com/WebBluetooth_for_Leafony_app/  Press the Connect button of the web app, select Leafony_AC02 and press the Pair button.\n  Connection complete.\nThere is a \u0026ldquo;Download CSV\u0026rdquo; button on the screen, but it is not available on the iPhone.\n  The sample app I used this time is \u0026ldquo;Web Bluetooth IoT\u0026rdquo;. You can see the source code and how it works here.\n  Next Steps Environment Settings and write the program in the Basic Kit.  On Windows or macOS   Open Google Chrome.\n  Open web app.\n  Press the Connect button of the web app, select Leafony_AC02 and press the Pair button.\n  Connection complete.\n  The sample app used in this article is \u0026ldquo;Web Bluetooth IoT\u0026rdquo;. You can see the source code and how it works here.\n  Next Steps Environment Settings and write the program in the Basic Kit.  On Linux   To enable Web Bluetooth on Linux, please refer to the following articles to set up your environment.\n\u0026ldquo;How to get Chrome Web Bluetooth working on Linux\u0026rdquo;\n  Open Google Chrome.\n  Open web app.\n  Press the Connect button of the web app, select Leafony_AC02 and press the Pair button.\n  Connection complete.\n  The sample app used in this article is \u0026ldquo;Web Bluetooth IoT\u0026rdquo;. You can see the source code and how it works here.\n  Next Steps Environment Settings and write the program in the Basic Kit.    Windows 10 version 1703 or later \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite or later \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow or later \u0026#x21a9;\u0026#xfe0e;\n For iPhone or iPad, WebBLE (paid) is required. This is because Web Bluetooth is not implemented in the iPhone and iPad versions of Chrome. \u0026#x21a9;\u0026#xfe0e;\n If you have Chrome less than version 79, Web Bluetooth is not enabled by default.\nEnter the following URL in Chrome\u0026rsquo;s address bar and set the Experimental Web Platform features to Enable.\nchrome://flags/#enable-experimental-web-platform-features \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"The Basic Kit is a small, coin cell powered development kit that includes a 4-Sensors leaf with …","ref":"https://docs.leafony.com/en/docs/getting-started/basic/","title":"Basic Kit Getting Started Guide"},{"body":"\nOverview The kit includes an AVR microcontroller (Atmega328P), Bluetooth LE, temperature/humidity sensor, illuminance sensor, accelerometer, and a leaf with a magnetic plastic case, and is suitable for ultra-compact, low power consumption systems that can be powered by coin cell batteries. You can create a sensor device.\nContents    Type Item Q’ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AX02 29pin 1   AZ01 USB 1   AZ62 Connector Cover 1   AZ66 Basic Kit Case 1    Caution note 1    CR2032 coin cell battery 1    M2*15mm screw 2    Screw driver 1    Leaf List  AC02 BLE Sugar  The Leaf is equipped with Silicon Labs' technically certified Bluetooth LE module BGM11S22F256GA-V2.\n   AI01 4-Sensors  This leaf is equipped with a temperature/humidity sensor, an illuminance sensor and an acceleration sensor. Equipped with power-saving sensors and suitable for long-term sensing.\n   AP01 AVR MCU  This leaf uses the ATmega328P and features 14 digital input and output pins (six of which can be used as PWM outputs), six analog input pins, an 8 MHz oscillator, and a reset button.\n   AV01 CR2032  This power supply leaf contains a CR2032 coin cell battery holder, a power switch, an AD converter for voltage monitoring, and a 3.3 V to 3.3 V step-up circuit. 2cm x 2cm in size, it is capable of supplying 3.3 V power.\n   AX02 29pin  This is a leaf with all 29 pins of the leaf I/F connected to a 2.54mm pitch through-hole.\n   AZ01 USB  FTDI\u0026rsquo;s FT232RQ is mounted as a USB-UART conversion IC. It converts from USB VBUS (5V) to 3.3V with a step-down power supply circuit and supplies VBUS and 3.3V to each leaf.\n   AZ62 Connector Cover  The Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris.\n   AZ66 Basic kit case  This is a case for the Basic Kit. It can be fixed to the wall with the magnets on the bottom.\n   Sample App Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Overview The kit includes an AVR microcontroller (Atmega328P), Bluetooth LE, temperature/humidity …","ref":"https://docs.leafony.com/en/docs/products/basic/","title":"Basic Kit"},{"body":"  \nFeatures A leaf containing Silicon Labs' technically certified BLE module BGM11S22F256GA-V2, which is connected to the MCU leaf via UART. Radio certifications include CE, FCC, ISED Canada, TELEC, KC South-Korea, and NCC Taiwan (SLICON LABS Module Data Sheet Revision 1.2).\nSpecification    Item　 Description     Part number BGM11S22F256GA-V2　   SoC EFR32BG1 (ARM Cortex-M4)　   Bluetooth version 4.2   Frequency range 2400M ~ 2483.5MHz   RX sensitivity -90 dBm @ 1 Mbit/s GFSK   TX power +8dBm以下   RF certification CE, full FCC, ISED Canada, Japan and South-Korea   Flash 256KB   RAM 32KB   Interfaces UART   Dimension W23×D20.5×H4.7mm    Block diagram \nPinassign \nSample App  Simple BLE Characteristic (in progress) Simple BLE Advertisement (in progress） Web Bluetooth IoT  Google Sheets IoT  Library Libraries are available for this leaf. Please install the necessary libraries from Environment to use them.\nDocument  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Features A leaf containing Silicon Labs' technically certified BLE module BGM11S22F256GA-V2, which …","ref":"https://docs.leafony.com/en/docs/leaf/communication/ac02/","title":"AC02 BLE Sugar"},{"body":"About Leafony Leafony is an ultra-compact, low-power, easy to use open innovation platform. It makes it easy to prototype new IT services, IoT edge nodes, etc. The Trillion Node Engine Project1 is driving the research and development of this platform, and the finalized version is called \u0026ldquo;Leafony\u0026rdquo;. The company that manufactures and sells this Leafony is called Leafly Systems, Inc.\nIt is said that in the future, many IT nodes such as IoT/CPS2 will be used in society. Professor Emeritus Sakurai of the University of Tokyo has launched the Trillion Node Study Group in order to discuss such future and share information. He is using Leafony as a base for concrete thinking, and is working hard to promote Leafony for the development of the IoT/CPS. We also provide a place to connect related companies with needs and seeds.\nLeafony, a word coined by Leaf and Symphony, aims at the harmony of the individual and the whole, just as Symphony represents the wish for a harmony of tones to play a great piece of music, and for the Leaf to come together to create a great value.\nUsage scenario Enterprise  ・Proof of Concept (PoC) of IoT ・R\u0026amp;D and demonstration tests ・IoT system prototype service ・Creation of a reference model\n・Sales tools for our parts and technologies\n・Reuse and transfer of technology\n  Personal  ・New App\n・Service Exploration\n・Easy gadget making\n  Education and University  ・IoT Education\n・Research/Experiment ・Research results are demonstrated to accelerate practical application\n   Overview Video   For more information, please refer to the following.\nleafony general document EN Let\u0026rsquo;s get started. Let\u0026rsquo;s start using Leafony right away.\n Quick start Development Environment Settings Sample App    The Trillion Node Engine Project is a research and development project commissioned and subsidized by the New Energy and Industrial Technology Development Organization (NEDO). \u0026#x21a9;\u0026#xfe0e;\n IoT stands for Internet of Things and CPS stands for Cyber-Physical Systems. In particular, CPS is a system that connects real physical space and digital space without being connected to the Internet. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"About Leafony Leafony is an ultra-compact, low-power, easy to use open innovation platform. It makes …","ref":"https://docs.leafony.com/en/docs/overview/","title":"Introduction"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/environment/esp32/","title":"ESP32 MCU Development Environment Settings Manual"},{"body":"The ESP32 Wi-Fi Kit is a development kit with the ESP32-WROOM-32 with built-in Wi-Fi and Bluetooth LE, which can be powered by batteries or lithium batteries.\nIt\u0026rsquo;s easy to send touch sensor values to your smartphone or computer via Wi-Fi.\nThe ESP32 Wi-Fi Kit comes with this program written and ready to use right out of the box.\nWhat to prepare  ESP32 Wi-Fi Kit A Wi-Fi-enabled PC, smartphone or tablet Your preferred web browser  Usage  Insert three AAA batteries into the ESP32 Wi-Fi Kit and turn on the power switch.\n Use your PC, smartphone or tablet to search for Wi-Fi in the area and connect to the Wi-Fi of the following SSID.  SSID: Leafony_ESP32-AP Password: password   Copy the following URL, launch WebBLE and paste it into the address bar.   http://192.168.4.1  Pins 7, 9, 22, 24, 26 and 28 of the 29pin header are assigned to the touch sensor.\nTouching the pins increases the capacitance and decreases the value. If the value falls below the threshold of 20, \u0026ldquo;Touch detected\u0026rdquo; is displayed.\n(Pin 24 is hidden in the sample sketch due to interference with the RTC \u0026amp; microSD. The detection threshold can be changed in the sketch. In the picture below, I am touching pin 26 with my fingertip.)\n   When the 26-pin is touched, your web browser will change its display as shown below.　   There is a magnet on the Nut Plate part of the ESP32 Wi-Fi Kit. Let\u0026rsquo;s install it on a metal wall.\n  The sample app we used this time is \u0026ldquo;Wi-Fi Touchsensor\u0026rdquo;. The source code and how it works can be found here.  Next Steps Environment Settings and write the program to the ESP32 Wi-Fi Kit.  ","excerpt":"The ESP32 Wi-Fi Kit is a development kit with the ESP32-WROOM-32 with built-in Wi-Fi and Bluetooth …","ref":"https://docs.leafony.com/en/docs/getting-started/esp32/","title":"ESP32 Wi-Fi Kit Getting Started Guide"},{"body":"Try using a leaf equipped with a motion sensor, MEMS microphone, etc.!\n\nThe Extenston Kit is a development kit that can be used in conjunction with the Basic Kit and the ESP32 Wi-Fi Kit and contains a leaf with a motion sensor and MEMS microphone.\nTo drive the Extenston Kit, you must write a program to the MCU leaf of the Basic Kit or the ESP32 Wi-Fi Kit.\nWhat to prepare  Extenston Kit Basic Kit, or ESP32 Wi-Fi Kit PC (Windows, Mac OS X, or Linux)　  How to write a program If you haven\u0026rsquo;t prepared the PC environment yet, please refer to Basic Kit Development Environment Settings Manual or ESP32 Wi-Fi Kit Development Environment Settings Manual to prepare.\nNext step Let’s write the program in Sample app.  ","excerpt":"Try using a leaf equipped with a motion sensor, MEMS microphone, etc.!\n\nThe Extenston Kit is a …","ref":"https://docs.leafony.com/en/docs/getting-started/extension/","title":"Extension Kit Getting Started Guide"},{"body":"\nOverview The Extension Kit contains a variety of useful and easy-to-use leafs that can be used in conjunction with the Basic Kit and the ESP32 Wi-Fi Kit for a wider range of applications. It does not include a microcontroller leaf, so you will need the Basic Kit or the ESP32 Wi-Fi Kit to run the software.\nContents    Type Item Q’ty     AI02 SP \u0026amp; PIR 1   AI03 MIC \u0026amp; VR \u0026amp; LED 1   AI04 LCD 1   AV03 AA BAT 1   AX01 Shield 1   AX03 Leafx2 1   AX04 Spacer 1   AX05 I Meas. 1   AX06 Grove \u0026amp; 5V 1    Caution note 1    Leaf List  AI02 SP\u0026amp;PIR  The Leaf is equipped with a piezoelectric speaker and a motion sensor. The motion sensor has a built-in proximity detection algorithm and can detect the approach of an object with simple settings.\n   AI03 MIC\u0026amp;VR\u0026amp;LED  This leaf is equipped with a MEMS microphone, volume and LED. It can be powered off with a load switch by controlling the I2C Expander to achieve low power consumption.\n   AI04 LCD  This leaf is equipped with a character LCD unit and two user switches. It can be powered off with a load switch by controlling the I2C Expander to achieve low power consumption.\n   AV03 AA BAT  This is a power supply leaf with an AA battery holder, a power switch, an AD converter for voltage monitoring, a 3 V to 3.3 V boost circuit, and three Leafony connectors to provide power to more leaves.\n   AX01 Shield  An expansion board with an Arduino Shield connector, a SWD connector, an ICSP connector, and three leaf I/Fs mounted on it.\n   AX03 Leaf x2  This connector leaf is used to connect the leafs side-by-side.\n   AX04 Spacer  A spacer leaf that is placed between two stacked leaves. It can be used when parts of the leafs interfere with each other.\n   AX05 I Meas.  This leaf is used to measure the current flowing in the 3.3V and VBUS. Normally, the Leafony bus is electrically connected on both sides, but in this leaf, only the 3.3V and VBUS are disconnected in the front and the back, and they are connected to the through-hole.\n   AX06 Grove\u0026amp;5V  It is a UART, I2C, analog input and digital input leaf that operates at 3.3V and 5V in accordance with the Grove series from VBUSSeeed Studio. 3.3V is converted to 5V by a step-up power supply circuit and supplied to Grove. To achieve low power consumption, it is possible to turn off the 5V power supply by controlling the I2C Expander.\n   Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Overview The Extension Kit contains a variety of useful and easy-to-use leafs that can be used in …","ref":"https://docs.leafony.com/en/docs/products/extension/","title":"Extension Kit"},{"body":"Kits  Basic Kit  Bluetooth LE and 4 sensors. Compact and coin cell powered development kit.\n   ESP32 Wi-Fi Kit  The ESP32-WROOM-32 with built-in Wi-Fi and Bluetooth LE. Development kit that can be powered by dry batteries or lithium batteries.\n   Extension Kit  The kit contains a leaf with a motion sensor and MEMS microphone for use with the Basic Kit and ESP32 Wi-Fi Kit.\n   Others  Connector  A set of 10 Connectors for the Leafony platform.\n   Nut Plate \u0026amp; Connector Cover  A connector cover to protect the Nut Plate and ACR from debris when screwing the leaf in place.\n   Third party In progress.\n","excerpt":"Kits  Basic Kit  Bluetooth LE and 4 sensors. Compact and coin cell powered development kit.\n   ESP32 …","ref":"https://docs.leafony.com/en/docs/products/","title":"Our Products"},{"body":"\nOverview Based on the popular ESP32 microcontroller, this kit includes Wi-Fi wireless communication, microSD, and a real-time clock function. It doesn\u0026rsquo;t run on coin cell batteries, but it runs on a slightly larger battery. As is, you can send the value of the touch sensor to your smartphone or PC via Wi-Fi for easy display.\nContents    Type Item Q’ty     AP02 ESP32 MCU 1   AV04 2V～4.5V 1   AX07 Back to back 1   AX08 29 pin header 1   AZ02 RTC \u0026amp; micro SD 1   AZ62 Connector Cover 2   AZ63 Nut Plate 2    AAA battery holder 1    Caution note 1    M2*12mm screw 2    φ10x2mm magnet 1    Leaf list  AP02 ESP32 MCU  Espressif Systems' 32-bit MCU leaf featuring the ESP32-WROOM-32 module with integrated Wi-Fi and Bluetooth LE, which is technically certified.\n   AV04 2V～4.5V  The power supply leaflet contains a JST SH connector for lithium-ion battery or battery box connection, a power switch, an AD converter for voltage monitoring and a 3.3 V step-up/down circuit.\n   AX07 Back to back  A connector leaf that can be connected back to back.\n   AX08 29pin header  A leaf with all 29 pins of the leaf I/F connected to a 2.54mm pitch pin header.\n   AZ02 RTC\u0026amp;microSD  The RTC can output interrupts to the MCU with alarms and timers, while the microSD card is accessible via SPI.\n   AZ62 Connector Cover  The Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris.\n   AZ63 Nut Plate  The Nut Plate is used to fix the leaf with a screw. Be careful not to use commercially available hex nuts as they may cause a short circuit by touching the electrodes on the board.\n   Revision history  Rev A1.0: First edition, January 2020  ","excerpt":"Overview Based on the popular ESP32 microcontroller, this kit includes Wi-Fi wireless communication, …","ref":"https://docs.leafony.com/en/docs/products/esp32/","title":"ESP32 Wi-Fi Kit"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/environment/stm32/","title":"STM32 MCU Development Environment Settings Manual"},{"body":"Terms（alphabetical order） IoT/CPS IoT stands for Internet of Things and CPS stands for Cyber-Physical Systems. In particular, CPS is a system that connects real physical and digital spaces without being connected to the internet.\nLeaf It is the basis of the Leafony project, a 2 cm square electronic board/electronic module. We call it a leaf because it is small and green. You can easily make your own leaf.\nLeafony or the Leafony platform Leafony is an open hardware and software platform built from leafs. Its ultra-compact size and low power consumption make it easy to create IoT/CPS systems, which is ideal to increase the development efficiency for the future digital transformation. Software development is easy. Of course, you can also develop software outside of the Arduino environment.\nLeafony, a word coined from Leaf and Symphony, aims at the harmony between the individual and the whole, and Symphony represents the desire for the Leaf to come together to create great values, just as the sounds of the various instruments work in harmony to create a great piece of music.\nThe technical information on Leafony is basically free to use for commercial purposes. You can find more information about the license in the License section. User-specific leafs are sold by many companies, individuals, etc., under the guise of being Leafony bus compliant, and we encourage such activities. However, since Leafony is a registered trademark, we ask that you refrain from using the Leafony name on the leaf itself to avoid market confusion.\nLeafony block It is an electronic device that is made up of multiple leaves. Normally, stacked leaves form a block, so it is called a leaf block. An electronic device made by combining leaves, even if the structure is flat and spread out, is called a leaf block.\nLeafony bus A common pathway that connects multiple leaves to each other is called a Leafony bus. It defines the electrical and physical specifications for the electrical signal and power connections. A Leafony bus-compliant leaf will be able to communicate with other leaves, but since it depends on the software and so on whether the Leafony platform is completely safe to connect to, Leafony bus-compliance just means that it is possible to connect close to the physical level.\nThe Leafony bus artwork is copyrighted and published under the CC-BY License, so you can use it for commercial purposes as well as It is free to use as long as you state that it is Leafony compliant. Therefore, you are free to develop and sell your own leafs. However, since Leafony is a registered trademark, you should not label your leaf as Leafony on it itself; a leaf with the label Leafony will show you that the product quality has been verified, and you will avoid confusion.\nLeafony connector Newly developed anisotropic conductive rubber connectors for interconnecting the leaf. It is both a male and female connector. Although it is possible to connect the leaves with solder and other thermal compression techniques, the Leafony connector is more convenient.\nLEAFONY SYSTEMS Co.,Ltd. Leaf is the only company that manufactures and sells Leafony, which was researched and developed by the Trillion Node Engine Project, and is the only company that displays Leafony on Leaf by LEAFONY SYSTEMS. It has been identified by the Trillion Node Engine Project.\nLeafony bus-compliant reefs will be sold by many other companies, individuals, etc., and although we encourage such activities, there is no Leafony label on the reef itself.\nTrillion-node engine This is the electronics platform developed by the Trillion Node Engine Project. It is available to the public under the name Leafony, after organizing the hardware and software that are no longer under development.\nTrillion-node engine project The Trillion Node Engine Project is a research and development project commissioned and subsidized by the New Energy and Industrial Technology Development Organization (NEDO).\nTrillion-node study-group It is said that in the future, many IT nodes such as IoT/CPS will be used in society. The purpose of this workshop is to discuss such future and share information. We are using Leafony as a concrete basis for thinking, and we are trying to promote Leafony for the development of IoT/CPS. We also provide a place to connect related companies that have needs and seeds.\nHarness Electrical connections between a Leafony block and the outside world may require some wiring. Such a wiring is called a harness.\n","excerpt":"Terms（alphabetical order） IoT/CPS IoT stands for Internet of Things and CPS stands for …","ref":"https://docs.leafony.com/en/docs/terms/","title":"Terms"},{"body":"Let\u0026rsquo;s start using Leafony when it arrives!\nThe kit comes with an app installed that you can use as soon as you turn it on.\nTake a look at this page to experience the world of IoT.\n","excerpt":"Let\u0026rsquo;s start using Leafony when it arrives!\nThe kit comes with an app installed that you can …","ref":"https://docs.leafony.com/en/docs/getting-started/","title":"Getting Started"},{"body":"Software Since the Trillion-node engine project, or software developed and released by the Trillion-node study-group, is Licensed by MIT, you can use the You are free to use it. Other software, such as the library, that you may use when using Leafony, is under the licensing conditions of the respective code. The license terms are usually written in the respective program code.\nHardware The Leafony bus board layout (artwork) is copyrighted and published under the \u0026lt;a href=\u0026ldquo;https:// Since it is available under CC-BY License, you can use it freely for commercial purposes as long as you specify \u0026ldquo;Leafony compliant\u0026rdquo;. Therefore, you can develop and sell your own leafs freely. We do not claim the copyright of the other parts of the artwork.\nOn the other hand, \u0026ldquo;Leafony\u0026rdquo; is a registered trademark of Leafy Systems, Inc. Please refrain from using the name \u0026ldquo;Leafony\u0026rdquo; in the product name of your self-made leaf, as it may lead to confusion with the LEAFONY SYSTEMS Corporation\u0026rsquo;s product line and confuse the market.\nOther Leafony is a registered trademark of LEAFONY SYSTEMS Corporation.\n","excerpt":"Software Since the Trillion-node engine project, or software developed and released by the …","ref":"https://docs.leafony.com/en/docs/license/","title":"License"},{"body":"You can easily develop in the Arduino environment, just like the AVR MCU leaf. We have prepared sample applications for STM32 MCU Leaf, so you can try them out.\nWhat to prepare  STM32 MCU Basic Kit, Extenston Kit or ESP32 Wi-Fi Kit PC (Windows、Mac OS X , or Linux)　  How to write a program If your PC environment is not ready yet, please refer to the \u0026ldquo;Arduino IDE configuration for STM32 MCU\u0026rdquo; for preparation. Next step Let’s write the program in Sample app.  ","excerpt":"You can easily develop in the Arduino environment, just like the AVR MCU leaf. We have prepared …","ref":"https://docs.leafony.com/en/docs/getting-started/stm32/","title":"STM32 MCU Getting Started Guide"},{"body":"For inquiries about product technology and applications, please use the stack overflow Q\u0026amp;A site. When you post a question in the stack overflow, please make sure to include \u0026ldquo;Leafony\u0026rdquo; in the title. You must be a registered user to post on the stack overflow.\n stack overflow  ","excerpt":"For inquiries about product technology and applications, please use the stack overflow Q\u0026amp;A site. …","ref":"https://docs.leafony.com/en/docs/contacts/","title":"Contacts"},{"body":" How the board works Board design procedure Design tools Parts selection Circuit design Layout design Spacing Manufacturing order Component mounting Test  ","excerpt":" How the board works Board design procedure Design tools Parts selection Circuit design Layout …","ref":"https://docs.leafony.com/en/docs/pcb/pcb-tutorial/","title":"Board Development Tutorial"},{"body":"This is a summary of what to expect when assembling a Leafony block.\nHow to tighten the screw To avoid poor continuity, tighten the screws alternately and properly.\n\nInstalling and removing connectors Attach or remove the connector to the leaf board as shown below.\n\u0026ndash; Installing\n\u0026ndash; Removing\nWhen the connectors are dirty Dirt on the contacts of the connectors and the board may result in a poor connection. In this case, wipe them lightly with a paper rag moistened with anhydrous ethanol. If the problem persists, replace the connector.\n\n","excerpt":"This is a summary of what to expect when assembling a Leafony block.\nHow to tighten the screw To …","ref":"https://docs.leafony.com/en/docs/getting-started/assembly/","title":"Leafony block assembly"},{"body":"If you can\u0026rsquo;t find the serial port\u0026hellip; If you can\u0026rsquo;t find a Leafony serial port in the Arduino IDE, you can install a USB serial converter IC (FT232) driver. Download and install the device driver from FTDI VCP Driver.\nIf it doesn\u0026rsquo;t turn on\u0026hellip; If Leafony won\u0026rsquo;t turn on, you should check the following\n Direction of the button battery. Is the power switch turned on? Tightness of the screw. Make sure the batteries have enough remaining power.  ","excerpt":"If you can\u0026rsquo;t find the serial port\u0026hellip; If you can\u0026rsquo;t find a Leafony serial port in the …","ref":"https://docs.leafony.com/en/docs/getting-started/solution/","title":"If it doesn't work..."},{"body":"Follow these steps to set up your STM32 MCU development environment.\nWhat to prepare  STM32 MCU Leaf Basic Kit PC (Windows, Mac OS X or Linux)  Installing the Arduino IDE For instructions on how to install the Arduino IDE, please here.\nConnect to PC Connect it to your PC with a USB cable.\nConfiguration of the microcontroller board To use the STM32 MCU leaf with the Arduino IDE, the STM32 Cores must be installed. Please follow the steps below to configure the settings. (For more information about STM32 Cores, see here).\n Open the File → Preferences in the Arduino IDE and enter the following URL in the Additional Board Manager URL: field.  https://github.com/stm32duino/BoardManagerFiles/raw/master/STM32/package_stm_index.json \n Select Tools -\u0026gt; Board -\u0026gt; Board Manager, search for STM32 Cores and press the Install button. \n  Go to Tools → Board→ STM32 Boards (Selected from submenu)→ Nucleo-64 . \n  Go to Tools → Board part number: *****→ Nucleo L452RE . \n  Go to Tools → Upload method: ***** → STM32CubeProgrammer(Serial) . \n  Go to Tools → Serial Port and select the serial port to which Leafony is connected.   Installing the STM32CubeProg To be able to write programs to the STM32 MCU leaf, you need to install STM32CubeProg 1.The STM32CubeProg can be downloaded and installed on your PC here.\nWriting to the microcontroller board   When the program switch on the STM32 MCU leaf is set to the program side, the LED will light up. \n  Next, write a sketch and click write to microcontroller board in the Arduino IDE. If it is written successfully, the message Start operation achieved successfully will be displayed.If the message is not displayed 2, no write operation has been performed. (The entire display is here.) \n  When writing is complete, turn the STM32 MCU leaf\u0026rsquo;s Program switch to the Run side to turn off the LED.\n  Press the Reset switch on the STM32 MCU leaf.\n  Notes on Sketches Pin Designation Since the pin layout of the STM32 MCU is different from that of the Nucleo L452RE, it is not possible to use names when specifying pins.For STM32 MCU leaf, specify pins by port (Port)。\n\nInstalling libraries To use some of the leaves, you will need to install additional libraries. Here to install all libraries in advance. However, you cannot use the timer interrupt library (MsTimer2.h) because it is an AVR MCU library. Please refer to the following HardwareTimer.\nHardwareTimer An example of use is given below. For more information here. Initialization\nHardwareTimer *timer2 = new HardwareTimer (TIM2); timer2-\u0026gt;setOverflow(LOOP_INTERVAL, MICROSEC_FORMAT); // 125ms  timer2-\u0026gt;attachInterrupt(intTimer); timer2-\u0026gt;resume(); Interrupt routine\nvoid intTimer(void){ bInterval = true; ： ： } When in doubt You can find the solution in \u0026ldquo;If it doesn\u0026rsquo;t work\u0026hellip;\u0026rdquo;.\nNext step Sample app has several programs.\nTo make development easier, please install the library before you begin.    We have confirmed that V2.6.0 and V2.4.0 work on Windows 64bit. However, please note that V2.5.0 will not work. \u0026#x21a9;\u0026#xfe0e;\n When writing without the program switch on the program side, the message Writing to the board is complete is also displayed, but the bottom of the screen shows Timeout error occured while waiting for acknowledgement.  \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Follow these steps to set up your STM32 MCU development environment.\nWhat to prepare  STM32 MCU Leaf …","ref":"https://docs.leafony.com/en/docs/environment/stm32/arduino_ide/","title":"Arduino IDE configuration for STM32 MCU"},{"body":"Overview An AD converter is mounted on the power supply leaf to monitor the battery voltage. It measures not only temperature, humidity, illumination, and tilt, but also battery voltage and displays it on the LCD.\nHow to compensate for temperature (or humidity) If there is a discrepancy between the temperature (or humidity) you want to display and the temperature (or humidity) of the 4-Sensors, perform the correction between the two points. For details, see here.\n\nLeaf to use    Type Name Q\u0026rsquo;ty     AI04 LCD 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AZ01 USB 1   AX03 Leaf×2 1   AV01 CR2032 1   AZ62 Connector Cover 2   AZ63 Nut Plate 1    CR2032 coin cell battery 1    M2*15mm screw 4    Assembly Source code  4-Sensors, LCD, and AVR MCU library(timer interrupt) are required for writing. Please include the libraries beforehand. For details, see here. In the Arduino IDE, write the following sketch on the microcontroller board.  //===================================================================== // Leafony Platform sample sketch // Application : 4-Sensors with LCD // Processor : ATmega328P (3.3V /8MHz) // Arduino IDE : 1.8.13 // // Leaf configuration // (1) AI01 4-Sensors // (2) AI04 LCD // (3) AP01 AVR MCU // (4) AZ01 USB // //\t(c)2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/20 First release // Rev.01 2020/07/29 不要部分削除等体裁修正 //===================================================================== // use libraries // Adafruit Unified Sensor Driver // https://github.com/adafruit/Adafruit_Sensor // Adafruit Bus IO Library // https://github.com/adafruit/Adafruit_BusIO // Adafruit LIS3DH // https://github.com/adafruit/Adafruit_LIS3DH // SmartEverything ST HTS221 Humidity Sensor // https://github.com/ameltech/sme-hts221-library // ClosedCube Arduino Library for ClosedCube OPT3001 // https://github.com/closedcube/ClosedCube_OPT3001_Arduino // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;MsTimer2.h\u0026gt; // Timer#include \u0026lt;Wire.h\u0026gt; // I2C #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; // 3-axis accelerometer#include \u0026lt;HTS221.h\u0026gt; // humidity and temperature sensor#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; // Ambient Light Sensor#include \u0026lt;ST7032.h\u0026gt; // LCD //=====================================================================  //=============================================== // シリアルモニタへの出力 // #define SERIAL_MONITOR = 出力あり //\t//#define SERIAL_MONITOR = 出力なし（コメントアウトする） //=============================================== #define SERIAL_MONITOR  //----------------------------------------------- // IOピン一覧 //----------------------------------------------- // D0 0 // PD0 (RXD) // D1 1 // PD1 (TXD) // D2 2 // PD2 (INT0) // D3 3 // PD3 (INT1) // D4 4 // PD4 // D5 5 // PD5 // D6 6 // PD6 // D7 7 // PD7 // D8 8 // PB0 (S-UART2_RX) // D9 9 // PB1 (S-UART2_TX) // D10 10 // PB2 (SS) // D11 11 // PB3 (MOSI) // D12 12 // PB4 (MISO) // D13 13 // PB5 (SCK/LED)  // D14 14 // [A0] PC0 // D15 15 // [A1] PC1 // D16 16 // [A2] PC2 // D17 17 // [A3] PC3  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- //------------------------------ // I2Cアドレス //------------------------------ #define LIS2DH_ADDRESS 0x19 // Accelerometer (SD0/SA0 pin = VCC) #define OPT3001_ADDRESS 0x45 // Ambient Light Sensor (ADDR pin = VCC) #define LCD_I2C_EXPANDER_ADDR 0x1A // LCD I2C Expander #define BATT_ADC_ADDR 0x50 // Battery ADC  //----------------------------------------------- // loop interval // MsTimer2のタイマー割り込み発生間隔(ms) //----------------------------------------------- #define LOOP_INTERVAL 125 // 125ms interval  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------  ST7032 lcd; //------------------------------ // Sensor //------------------------------ Adafruit_LIS3DH accel = Adafruit_LIS3DH(); ClosedCube_OPT3001 light; //--------------------------------------------------------------------- // プログラムで使用する変数定義 //--------------------------------------------------------------------- //--------------------------- // LCD //--------------------------- int8_t lcdSendCount = 0; //------------------------------ // Loop counter //------------------------------ uint8_t iLoop1s = 0; //------------------------------ // Event //------------------------------ bool event1s = false; //------------------------------ // interval Timer interrupt //------------------------------ volatile bool bInterval = false; //------------------------------ // LIS2DH : Accelerometer //------------------------------ float dataX_g, dataY_g, dataZ_g; float dataTilt; //------------------------------ // HTS221 : Humidity and Temperature sensor //------------------------------ float dataTemp; float dataHumid; //-------------------- // 2点補正用データ //-------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  //------------------------------ // OPT3001 : Ambient Light Sensor //------------------------------ float dataLight; //--------------------------- // Battery //--------------------------- float dataBatt = 0; //===================================================================== // setup //===================================================================== void setup(){ Wire.begin(); // I2C 100kHz #ifdef SERIAL_MONITOR  Serial.begin(115200); // UART 115200bps  Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;setup start\u0026#34;); #endif  i2c_write_byte(LCD_I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(LCD_I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD 電源ON  // LCD設定  lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;NOW\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;BOOTING!\u0026#34;); setupPort(); delay(10); noInterrupts(); setupTCInt(); interrupts(); setupSensor(); MsTimer2::start(); // Timer inverval start  #ifdef SERIAL_MONITOR  Serial.println(\u0026#34;\u0026#34;); Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;loop start\u0026#34;); Serial.println(\u0026#34;\u0026#34;); #endif } //----------------------------------------------- // IOピンの入出力設定 // 接続するリーフに合わせて設定する //----------------------------------------------- void setupPort(){ } //--------------------------------------------------------------------- // 各デバイスの初期設定 //--------------------------------------------------------------------- //------------------------------ // Sensor //------------------------------ void setupSensor(){ //-------------------------------------  // LIS2DH (accelerometer)  //-------------------------------------  accel.begin(LIS2DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  //-------------------------------------  // HTS221 (Humidity and Temperature sensor)  //-------------------------------------  smeHumidity.begin(); //-------------------------------------  // OPT3001 (Ambient Light Sensor)  //-------------------------------------  OPT3001_Config newConfig; OPT3001_ErrorCode errorConfig; light.begin(OPT3001_ADDRESS); // I2C address  newConfig.RangeNumber = B1100; // automatic full scale  newConfig.ConvertionTime = B1; // convertion time = 800ms  newConfig.ModeOfConversionOperation = B11; // continous conversion  newConfig.Latch = B0; // hysteresis-style  errorConfig = light.writeConfig(newConfig); if(errorConfig != NO_ERROR){ errorConfig = light.writeConfig(newConfig); //retry  } } //===================================================================== // 割り込み処理 //===================================================================== //----------------------------------------------- // 割り込み処理初期設定 // Timer interrupt (interval=125ms, int=overflow) // メインループのタイマー割り込み設定 //----------------------------------------------- void setupTCInt(){ MsTimer2::set(LOOP_INTERVAL, intTimer); } //---------------------------------------------- // Timer INT // タイマー割り込み関数 //---------------------------------------------- void intTimer(){ bInterval = true; } //==================================================================== // loop //==================================================================== //--------------------------------------------------------------------- // Main loop //--------------------------------------------------------------------- void loop(){ //-----------------------------------------------------  // Timer interval　125ms で1回ループ  //-----------------------------------------------------  if (bInterval == true){ bInterval = false; //--------------------------------------------  loopCounter(); // loop counter  //--------------------------------------------  // 1sに1回実行する  //--------------------------------------------  if (event1s == true){ event1s = false; // initialize parameter  loopSensor(); // sensor read  dispSencerData(); // LCD  } } } //--------------------------------------------------------------------- // Counter // メインループのループ回数をカウントし // 1秒間隔でセンサーデータの取得をONにする //--------------------------------------------------------------------- void loopCounter(){ iLoop1s += 1; //--------------------  // 1s period  //--------------------  if (iLoop1s \u0026gt;= 8){ // 125ms x 8 = 1s  iLoop1s = 0; event1s = true; } } //--------------------------------------------------------------------- // Sensor // センサーデータ取得がONのとき、各センサーからデータを取得 // コンソール出力がONのときシリアルに測定値と計算結果を出力する //--------------------------------------------------------------------- void loopSensor(){ double temp_mv; //-------------------------  // LIS2DH  // 3軸センサーのデータ取得  //-------------------------  accel.read(); dataX_g = accel.x_g; //X軸  dataY_g = accel.y_g; //Y軸  dataZ_g = accel.z_g; //Z軸  if(dataZ_g \u0026gt;= 1.0){ dataZ_g = 1.00; } else if (dataZ_g \u0026lt;= -1.0){ dataZ_g = -1.00; } dataTilt = acos(dataZ_g)/PI*180; //-------------------------  // HTS221  // 温湿度センサーデータ取得  //-------------------------  dataTemp = (float)smeHumidity.readTemperature(); //温度  dataHumid = (float)smeHumidity.readHumidity(); //湿度  //-------------------------  // 温度と湿度の2点補正  //-------------------------  dataTemp=TM0+(TM1-TM0)*(dataTemp-TL0)/(TL1-TL0); // 温度補正  dataHumid=HM0+(HM1-HM0)*(dataHumid-HL0)/(HL1-HL0); // 湿度補正  //-------------------------  // OPT3001  // 照度センサーデータ取得  //-------------------------  OPT3001 result = light.readResult(); if(result.error == NO_ERROR){ dataLight = result.lux; } //-------------------------  // ADC081C027（ADC)  // 電池リーフ電池電圧取得  //-------------------------  uint8_t adcVal1 = 0; uint8_t adcVal2 = 0; Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); adcVal1 = Wire.read(); adcVal2 = Wire.read(); if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { //測定値がFFならバッテリリーフはつながっていない  adcVal1 = adcVal2 = 0; } //電圧計算　ADC　* （(リファレンス電圧(3.3V)/ ADCの分解能(256)) * 分圧比（２倍））  temp_mv = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; dataBatt = (float)(temp_mv / 1000); //-------------------------  // シリアルモニタ表示  //------------------------- #ifdef SERIAL_MONITOR  Serial.println(\u0026#34;--- sensor data ---\u0026#34;); Serial.println(\u0026#34; Tmp[degC] = \u0026#34; + String(dataTemp)); Serial.println(\u0026#34; Hum[%] = \u0026#34; + String(dataHumid)); Serial.println(\u0026#34; Lum[lx] = \u0026#34; + String(dataLight)); Serial.println(\u0026#34; Ang[arc deg] = \u0026#34; + String(dataTilt)); Serial.println(\u0026#34; Bat[V] = \u0026#34; + String(dataBatt)); #endif } //--------------------------------------- // Disp sensor data // センサーデータを文字列に変換してLCDに表示する //--------------------------------------- void dispSencerData(){ float value; char temp[7], humid[7], light[7], tilt[7], battVolt[7]; char sendData[40]; //-----------------------------------  //センサーデータを文字列に変換  //dtostrf(変換する数字,変換される文字数,小数点以下の桁数,変換した文字の格納先);  //変換される文字数を-にすると変換される文字は左詰め、+なら右詰めとなる  //-----------------------------------  //-------------------------  // Temperature (4Byte)  //-------------------------  value = dataTemp; if(value \u0026gt;= 100){ value = 99.9; } else if(value \u0026lt;= -10){ value = -9.9; } dtostrf(value,4,1,temp); //-------------------------  // Humidity (4Byte)  //-------------------------  value = dataHumid; dtostrf(value,4,1,humid); //-------------------------  // Ambient Light (5Byte)  //-------------------------  value = dataLight; if(value \u0026gt;= 100000){ value = 99999; } dtostrf(value,5,0,light); //-------------------------  // Tilt (4Byte)  //-------------------------  value = dataTilt; if(value \u0026lt; 3){ value = 0; } dtostrf(value,4,0,tilt); //-------------------------  // Battery Voltage (4Byte)  //-------------------------  value = dataBatt; if (value \u0026gt;= 10){ value = 9.99; } dtostrf(value, 4, 2, battVolt); //-------------------------  trim(temp); trim(humid); trim(light); trim(tilt); trim(battVolt); lcd.clear(); switch (lcdSendCount){ case 0: // Tmp XX.X [degC]  lcd.print(\u0026#34;Temp\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(temp) +\u0026#34; C\u0026#34;); break; case 1: // Hum xx.x [%]  lcd.print(\u0026#34;Humidity\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(humid) +\u0026#34; %\u0026#34;); break; case 2: // Lum XXXXX [lx]  lcd.print(\u0026#34;Luminous\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(light) +\u0026#34; lx\u0026#34;); break; case 3: // Ang XXXX [arc deg]  lcd.print(\u0026#34;Angle\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(tilt) +\u0026#34; deg\u0026#34;); break; case 4: // Bat X.XX [V]  lcd.print(\u0026#34;Battery\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(battVolt) +\u0026#34; V\u0026#34;); break; default: break; } if (lcdSendCount \u0026lt; 4){ lcdSendCount++; } else{ lcdSendCount = 0; } } //--------------------------------------- // trim // 文字列配列からSPを削除する //--------------------------------------- void trim(char * data){ int i = 0, j = 0; while (*(data + i) != \u0026#39;\\0\u0026#39;){ if (*(data + i) != \u0026#39; \u0026#39;){ *(data + j) = *(data + i); j++; } i++; } *(data + j) = \u0026#39;\\0\u0026#39;; } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- //I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } 4-Sensors_LCD.ino\nExecution Results The LCD display changes in the following order: Temperature → Humidity → Illuminance → Angle → Remaining battery charge.\n","excerpt":"Overview An AD converter is mounted on the power supply leaf to monitor the battery voltage. It …","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/exten/4-sensors_lcd/","title":"4-sensors LCD"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/basic/","title":"Basic Kit"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/basic/","title":"STM32 MCU + Basic Kit"},{"body":"  \nFeatures This leaf is equipped with a temperature/humidity sensor, an illuminance sensor and an acceleration sensor and is connected to the MCU leaf via I2C.\nSpecification Dimension    Item Description     Dimension  W23×D20.5×H4.7mm    Temperature/Humidity Sensor    Item Description     Part number HTS221TR   Relative Temperature range -40～120℃   Temperature accuracy ±0.5°C (15 to +40°C)   Relative humidity range 0 to 100%   Humidity accuracy 3.5% rH (20 to +80% rH)   Interfaces I2C(Address: 0x5F)    Illuminance Sensor    Item Description     Part number OPT3001   Measurement range 0.01 lux to 83 k lux   IR Rejects \u0026gt; 99% (typ)   Interfaces I2C(Address: 0x44 or 0x45)    Acceleration Sensor    Item Description     Part number LIS2DHTR   Measurement range ±2g/±4g/±8g/±16g (selectable)   Function 6D/4D orientation detection   Freefall detection    Motion detection    Interfaces I2C(Address: 0x49)    Block diagram \nPinassign \nSample App AVR MCU Examples  Temp Humid Sensor Illuminance Sensor Accelerometer Sensor Web Bluetooth IoT Google sheets IoT 4-sensors LCD  ESP32 MCU Examples  Temp/Humid Sensor Illuminance Sensor Accelerometer Sensor  Library Libraries are available for this leaf. Please install the necessary libraries from Environment to use them.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Features This leaf is equipped with a temperature/humidity sensor, an illuminance sensor and an …","ref":"https://docs.leafony.com/en/docs/leaf/io/ai01/","title":"AI01 4-Sensors"},{"body":"  \nFeatures Leaf using the ATmega328P, with 14 digital input and output pins (six of which can be used as PWM outputs), six analog input pins, an 8 MHz oscillator, and a reset button. Connect USB if you are using USB or Shield if you are using ICSP. When using the Arduino IDE, select the Arduino Pro or Pro Mini board and the ATmega328P (3.3V, 8MHz) processor.\nSpecification    Item Description     Part number ATmega328P   Operating voltage 3.3V   Input voltage 1.5-5V   Digital I/O 14   Analog input 6   Flash memory 32 KB   SRAM 2KB   EEPROM 1KB   Clock speed 8MHz   Dimension W23×D20.5×H4.7mm    Block diagram \nPinassign \nTips About LEDs and switches \n   Item Description     Reset switch Reset microcontroller or other devices   LED Control LED by using pin 13 (Same as Arduino UNO)    Sample App  Blink  How to use it with Arduino In order to use this leaf with Arduino, the board must be configured on the Arduino IDE.\nPlease refer to Environment for instructions.\nDocuments  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing Bootloader  Revision history　  Rev A1.0: First edition, August 2019  ","excerpt":"Features Leaf using the ATmega328P, with 14 digital input and output pins (six of which can be used …","ref":"https://docs.leafony.com/en/docs/leaf/processor/ap01/","title":"AP01 AVR MCU"},{"body":"A simple list of sample apps.\n","excerpt":"A simple list of sample apps.","ref":"https://docs.leafony.com/en/docs/examples/beginner/","title":"Beginner Examples"},{"body":"\nOverview A set of ten connectors for the Leafony platform.\nContents    Type Item Q’ty     AZ61 Connector 10    List  AZ61 Connector  The Leafony Platform is based on ACRs (Anisotropic Conductive Rubber), which is an insulating silicone rubber with metal or conductive elastomeric conductive elements arranged at a narrow pitch, which can be compressed to create an electrical connection.\n   Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Overview A set of ten connectors for the Leafony platform.\nContents    Type Item Q’ty     AZ61 …","ref":"https://docs.leafony.com/en/docs/products/conn/","title":"Connector"},{"body":"Overview The Leafony template project for KiCad makes leaf board design a breeze. The template project is configured with the following items\n 2cm x 2cm Leaf outline Leafony bus footprint Design Rules.  \nDownload You can download the template project from the link below.\nGitHub - Leafony/cad-template\nDevelopment environment  KiCad 5.0.0 or later  Usage Create a new project  Launch KiCad. File -\u0026gt; New -\u0026gt; Project -\u0026gt; Create Project from Template. Select the User Templates tab. See the following path from the template project downloaded under the template path.  \\cad-template-master\\KiCad\\Leafony_Template Select Leafony Leaf and click OK.  \nEnter a project name and save the project to any location.  ","excerpt":"Overview The Leafony template project for KiCad makes leaf board design a breeze. The template …","ref":"https://docs.leafony.com/en/docs/pcb/kicad/","title":"KiCad Template Project"},{"body":"  \nFeatures The leaf is equipped with EASEL\u0026rsquo;s technically certified LoRa module ES920LRA1 and is connected to the MCU leaf via UART.\nSpecification    Item Description     Part Number ES920LRA1   SoC MKL16Z128 (ARM Cortex-M0+)   RF Transceiver SX1276 (SEMTECH)   Frequency range 920.6～928.0MHz   Transmission speed 146bps～22kbps   RX sensitivity -118～-142dBm   TX power Max 13dBm（20mW)   RF certification TELEC   Approximate communication distance (wire antenna) Prospect 5km   Flash 128KB   RAM 32KB   Interfaces UART   Dimension W23×D32.8×H4.6mm    Block diagram \nPinassign \nSample App  LoRa  Library Libraries are available for this leaf. Please install the necessary libraries from Environment to use them.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  ","excerpt":"Features The leaf is equipped with EASEL\u0026rsquo;s technically certified LoRa module ES920LRA1 and is …","ref":"https://docs.leafony.com/en/docs/leaf/communication/ac03/","title":"AC03 LoRa Easy"},{"body":"Introduction Instead of the Arduino IDE, you can also use PlatformIO as the Leafony development environment. PlatformIO makes it easy to manage things like library versioning, board configuration, etc., as well as to use. You can take advantage of the powerful plug-ins for Visual Studio Code to make your development more comfortable.\nAdvance preparation PlatformIO is a plug-in for Visual Studio Code (VSCode). You need to install the following software in advance.\n VSCode Python 3  Platformio Installation  Launch VSCode and open the Extensions tab. Enter PlatformIO IDE into the search window. Install the PlatformIO IDE.  Getting Started Create a new project  Press the PlatformIO Home button to display the PlatformIO home. Click on New Project. Name your project and select the appropriate board on Board. Open the main.cpp in the src folder and paste the following code.  #include \u0026lt;Arduino.h\u0026gt; void setup() { // LEDピンを出力ピンに設定  pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); // LEDを点灯  delay(999); // 1秒待つ  digitalWrite(LED_BUILTIN, LOW); // LEDを消灯  delay(999); // 1秒待つ } Press the Build button to build the project. Connect Leafony to your PC. Press the Upload button to write your project to Leafony.  Install the library  Press the PlatformIO Home button to display the PlatformIO home. Open the Libraries tab. Type OPT3001 in the search window to search the library for the illuminance sensor OPT3001. ClosedCube OPT3001をクリック。 Click the Add to Project button and add with Add. Open the PlatformIO.ini. Check that closedcube/ClosedCube OPT3001 @ \u0026lt;version\u0026gt; is added to the lib_deps option. If you paste the code below, you can easily set up the library environment without doing the above.  [env:pro8MHzatmega328] platform = atmelavr board = pro8MHzatmega328 framework = arduino lib_deps = closedcube/ClosedCube OPT3001 @ ^1.1.2 adafruit/Adafruit LIS3DH@1.1.2 https://github.com/ameltech/sme-hts221-library.git https://github.com/Leafony/TBGLib tomozh/ST7032@0.0.0-alpha+sha.501bf64fe6 paulstoffregen/MsTimer2@^1.1 adafruit/RTClib@^1.11.2 adafruit/Adafruit Unified Sensor@^1.1.4 adafruit/Adafruit BusIO@^1.5.0 Write and Serial Monitoring When you press the Serial Port Monitor button, the serial monitor is displayed.\nReference For more information on how to use PlatformIO for VSCode, please refer to the official documentation.\n https://docs.platformio.org/en/latest/integration/ide/vscode.html#ide-vscode  ","excerpt":"Introduction Instead of the Arduino IDE, you can also use PlatformIO as the Leafony development …","ref":"https://docs.leafony.com/en/docs/environment/avr/platformio/","title":"PlatformIO development environment"},{"body":"Introduction Instead of the Arduino IDE, you can also use PlatformIO as the Leafony development environment. PlatformIO makes it easy to manage things like library versioning, board configuration, etc., as well as to use. You can take advantage of the powerful plug-ins for Visual Studio Code to make your development more comfortable.\nAdvance preparation PlatformIO is a plug-in for Visual Studio Code (VSCode). You need to install the following software in advance.\n VSCode Python 3  Platformio Installation  Launch VSCode and open the Extensions tab. Enter PlatformIO IDE into the search window. Install the PlatformIO IDE.  Getting Started Create a new project  Press the PlatformIO Home button to display the PlatformIO home. Click on New Project. Name your project and select the appropriate board on Board. Open the main.cpp in the src folder and paste the following code.  #include \u0026lt;Arduino.h\u0026gt; void setup() { // LEDピンを出力ピンに設定  pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); // LEDを点灯  delay(999); // 1秒待つ  digitalWrite(LED_BUILTIN, LOW); // LEDを消灯  delay(999); // 1秒待つ } Press the Build button to build the project. Connect Leafony to your PC. Press the Upload button to write your project to Leafony. Press the Serial Port Monitor button to display the serial monitor and show the input status of the button.  Install the library  Press the PlatformIO Home button to display the PlatformIO home. Open the Libraries tab. Type OPT3001 in the search window to search the library for the illuminance sensor OPT3001. ClosedCube OPT3001をクリック。 Click the Add to Project button and add with Add. Open the PlatformIO.ini. Check that closedcube/ClosedCube OPT3001 @ \u0026lt;version\u0026gt; is added to the lib_deps option. If you paste the code below, you can easily set up the library environment without doing the above.  [env:pro8MHzatmega328] platform = atmelavr board = pro8MHzatmega328 framework = arduino lib_deps = closedcube/ClosedCube OPT3001 @ ^1.1.2 adafruit/Adafruit LIS3DH@1.1.2 https://github.com/ameltech/sme-hts221-library.git https://github.com/Leafony/TBGLib tomozh/ST7032@0.0.0-alpha+sha.501bf64fe6 paulstoffregen/MsTimer2@^1.1 adafruit/RTClib@^1.11.2 adafruit/Adafruit Unified Sensor@^1.1.4 adafruit/Adafruit BusIO@^1.5.0 Write and Serial Monitoring When you press the Serial Port Monitor button, the serial monitor is displayed.\nReference For more information on how to use PlatformIO for VSCode, please refer to the official documentation.\n https://docs.platformio.org/en/latest/integration/ide/vscode.html#ide-vscode  ","excerpt":"Introduction Instead of the Arduino IDE, you can also use PlatformIO as the Leafony development …","ref":"https://docs.leafony.com/en/docs/environment/esp32/platformio/","title":"PlatformIO development environment"},{"body":"Processor Leaf List\n","excerpt":"Processor Leaf List","ref":"https://docs.leafony.com/en/docs/leaf/processor/","title":"Processor Leaves"},{"body":"  \nFeatures This leaf is equipped with a piezoelectric speaker and a motion sensor. The piezoelectric speaker uses PWM and the motion sensor uses I2C to connect to the MCU leaf. The motion sensor has a built-in proximity detection algorithm and can detect proximity with simple settings and can output an interrupt signal when proximity is detected.\nSpecification Dimension    Item Description     Dimension  W23×D20.5×H5.3mm    Piezoelectric Speaker    Item Description     Part number CMT-1203-SMT   dimensions 12 x 12 x 3mm   rated frequency 4kHz(typ)   sound pressure level 81dB(min) at 10 cm, 5 Vp-p, 4,000 Hz square wave   Current consumption 5mA(max) at 5 Vp-p, 4,000 Hz square wave    IR Sensor    Item Description     Part number AK9754   Sensor Quantum-type IR Sensor   Interfaces I2C(Address: 0x65 or 0x64)    Block diagram \nPinassign \nSample App AVR MCU Examples  Speaker IR Sensor PIR Melody Test  ESP32 MCU Examples  Speaker IR Sensor  Document  Spec sheet Schematic SP\u0026amp;PIR Schematic PIR Component marking  PCBLayout SP＆PIR (Zuken) PCBLayout PIR (Zuken) PCBLayout SP＆PIR (dxf) PCBLayout PIR (dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  ","excerpt":"Features This leaf is equipped with a piezoelectric speaker and a motion sensor. The piezoelectric …","ref":"https://docs.leafony.com/en/docs/leaf/io/ai02/","title":"AI02 SP\u0026PIR"},{"body":"Install the 64-bit version of JAVA. It is necessary to install the 64-bit version of JAVA before installing the STM32CubeIDE. Download it from Java Home Page.\nDownload Click Agree and start free download. Install Double-click the downloaded \u0026ldquo;jxpiinstall.exe\u0026rdquo; to open it and click Install. Click on the Close button. Install the STM32CubeIDE Download the STM32CubeIDE.\nDownload Click on the Get Software.\nPlease click on the \u0026ldquo;Get Software\u0026rdquo; link in the STM32CubeIDE-Win line.\nClick on Agree.\nEnter the First Name, Last name, E-mail address, check\n□I have read and understood the Sales Terms \u0026amp; Conditions, Terms of Use and Privacy Policy , and click Download. The following page will be displayed. You will receive an email at the address you registered, click Download to start downloading.\nInstall Extract the downloaded zip file.\nDouble-click the unzipped file st-stm32cubeide_1.4.0_7511_20200720_0928_x86_64.exe. (The version may change depending on when it was downloaded and the numbers may be different.)\nClick Next.\nClick I Agree.\nClick Install.\nClick Next.\nClick Finish.\nThe installation is now complete.\nJapaneseization of STM32CubeIDE Download from the MargeDoc Project home page.\nDownload Windows.\nInstall Extract the zip file you downloaded. Double-click the unzipped setup.exe. Select.\nSelect C:\\\\StMoStM32CubeIDE_1.4.0\\Stm32cubeIDE\\Stm32cubeIDE.exe and click on Open.\ntranslate into Japanese.\nOK.\nFinish.\nThe installation is now complete.\nAnti-characterization measures To make sure UTF-8 is not garbled when generating code in STM32CubeMX (not sure if this is really necessary) Add the following to the environment variables\nVariable name ：JAVA_TOOL_OPTIONS variable value：-Dfile.encoding=UTF-8\nSelect Control Panel, System, System Advanced Settings, Environment Variables. Click the New button. Enter JAVA_TOOL_OPTIONS in the variable name and -Dfile.encoding=UTF-8 in the variable value. Click OK. ","excerpt":"Install the 64-bit version of JAVA. It is necessary to install the 64-bit version of JAVA before …","ref":"https://docs.leafony.com/en/docs/environment/stm32/stm32cube_ide/","title":"Installation of the STM32CubeIDE"},{"body":"Overview Turns on and off the LEDs on the AVR MCU leaf every second.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n//===================================================================== // Blink // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //=====================================================================  void setup() { // LEDピンを出力ピンに設定  pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); // LEDを点灯  delay(1000); // 1秒待つ  digitalWrite(LED_BUILTIN, LOW); // LEDを消灯  delay(1000); // 1秒待つ } Blink.ino\nExecution Results The LED on the AVR MCU leaf turns on and off every 1 second.\n","excerpt":"Overview Turns on and off the LEDs on the AVR MCU leaf every second.\nLeaf to use Use the following …","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/basic/blink/","title":"Blink"},{"body":"From now on, let\u0026rsquo;s set up a PC environment to develop with Leafony. You can learn how to install the necessary tools and libraries, how to build Leafony, and more here.\nAVR MCU development environment The AVR MCU leaf is a microcontroller leaf included in the Basic Kit.\n Configuring the Arduino IDE PlatformIO Configuration  ESP32 MCU development environment The ESP32 MCU leaf is a microcontroller leaf included in the ESP32Wi-Fi Kit.\n Configuring the Arduino IDE PlatformIO Configuration  STM32 MCU development environment  Configuring the Arduino IDE Installation of the STM32CubeIDE How to connect the debugger  ","excerpt":"From now on, let\u0026rsquo;s set up a PC environment to develop with Leafony. You can learn how to …","ref":"https://docs.leafony.com/en/docs/environment/","title":"Environment Setting"},{"body":"  \nFeatures It is a 32-bit MCU leaf with Espressif Systems' Xtensa Dual-Core 32-bit LX6 microprocessor, ESP32-WROOM-32 with built-in technically certified Wi-Fi and BLE. Radio certifications include FCC, CE-RED, IC, TELEC, KCC, SRRC, and NCC (Espressif Systems Data Sheet V2.9). Can be used as VBUS (5V) power supply with USB power supply. List of Assistants\nSpecification    Item Description     Part number ESP32-WROOM-32   SoC ESP32-D0WDQ6 (CPU:Xtensa LX6)   Operating voltage 3.3V   Input voltage 2.2-3.6V   Digital I/O 14   Analog input 6   TouchSensor I/F 6   Flash Memory 4 MB   SRAM 520 KB   Clock frequency 80M-240MHz   Wi-Fi protocols IEEE 802.11b/g/n   Bluetooth protocols Bluetooth v4.2 BR/EDR and BLE specification   RF certification FCC/CE-RED/IC/TELEC/KCC/SRRC/NCC   Dimension W39.1×D32.7×H5.4mm     Block diagram \nPinassign \nTips About LEDs and switches \n   Item Description     LED RX FT232RQ controlled LED / Flashes on UART TX data transmission.   LED TX FT232RQ controlled LED / Flashes on UART RX data transmission.   Reset switch Resets the ESP32 and other devices.   Boot mode switch Switch to change to boot mode.Press and hold the boot mode switch while writing a sketch.   micro USB It is used for writing a sketch to the MCU and serial monitoring by connecting a PC.This also converts USB’s VBUS(5V) to 3.3V by using step-down power circuit and provide VBUS and 3.3V to each leaf.   Antenna This is a shared antenna for Bluetooth LE and Wi-Fi.    Sample App  Button Wi-Fi touchsensor ESP32 googlesheets  How to use it with Arduino In order to use this leaf with Arduino, the board must be configured on the Arduino IDE.\nPlease refer to Environment for instructions.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, January 2020  ","excerpt":"Features It is a 32-bit MCU leaf with Espressif Systems' Xtensa Dual-Core 32-bit LX6 microprocessor, …","ref":"https://docs.leafony.com/en/docs/leaf/processor/ap02/","title":"AP02 ESP32 MCU"},{"body":"\nOverview A connector cover to protect the Nut Plate and ACR from debris when screwing the leaf in place.\nContents    Type Item Q’ty     AZ63 Nut Plate 10   AZ62 Connector Cover 10    List  AZ63 Nut Plate  The Nut Plate is used to fix the leaf with a screw. Be careful not to use commercially available hex nuts as they may cause a short circuit by touching the electrodes on the board.\n   AZ62 Connector Cover  The Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris.\n   Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Overview A connector cover to protect the Nut Plate and ACR from debris when screwing the leaf in …","ref":"https://docs.leafony.com/en/docs/products/nut/","title":"Nut Plate \u0026 Connector Cover"},{"body":"Overview Read the battery voltage using the AD converter on the CR2032 coin cell leaf.\nThis sample will also work with battery leaves such as the AA BAT leaf and the 2V to 4.5V leaf.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    Assembly Source code Write the following program in the Arduino IDE.\n//===================================================================== // Battery Voltage // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //=====================================================================  #include \u0026lt;Wire.h\u0026gt; const int BATT_ADC_ADDR = 0x50; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize I2C communication at 100kHz:  Wire.begin(); delay(10); } void loop(){ // read ADC registers:  Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); uint8_t adcVal1 = Wire.read(); uint8_t adcVal2 = Wire.read(); // when ADC is not connected, read values are 0xFF:  if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { adcVal1 = adcVal2 = 0; } // voltage mV = adcVal * Vref(3.3V) / resolution(8bit) * Vdiv(2)  double tempMillivolt = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; float dataBatt = (float)(tempMillivolt / 1000); Serial.println(\u0026#34;Batt[V] = \u0026#34; + String(dataBatt)); delay(1000); } Battery_Voltage.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the battery voltage.\n","excerpt":"Overview Read the battery voltage using the AD converter on the CR2032 coin cell leaf.\nThis sample …","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/basic/read_battery/","title":"Read battery"},{"body":"Overview Read the battery voltage using the AD converter on the CR2032 coin cell leaf.\nThis sample will also work with battery leaves such as the AA BAT leaf and the 2V to 4.5V leaf.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    Assembly Source code Write the following program1 in the Arduino IDE.\n//===================================================================== // Battery Voltage // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //=====================================================================  #include \u0026lt;Wire.h\u0026gt; const int BATT_ADC_ADDR = 0x50; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize I2C communication at 100kHz:  Wire.begin(); delay(10); } void loop(){ // read ADC registers:  Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); uint8_t adcVal1 = Wire.read(); uint8_t adcVal2 = Wire.read(); // when ADC is not connected, read values are 0xFF:  if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { adcVal1 = adcVal2 = 0; } // voltage mV = adcVal * Vref(3.3V) / resolution(8bit) * Vdiv(2)  double tempMillivolt = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; float dataBatt = (float)(tempMillivolt / 1000); Serial.println(\u0026#34;Batt[V] = \u0026#34; + String(dataBatt)); delay(1000); } Battery_Voltage.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the battery voltage.\n  The program is the same as AVR MCU Leaf. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview Read the battery voltage using the AD converter on the CR2032 coin cell leaf.\nThis sample …","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/basic/read_battery/","title":"Read battery"},{"body":"Beginner Examples Here are some sample apps for beginners using various types of leaves. Let\u0026rsquo;s learn how to use it by actually moving it around.\nAVR Beginner Examples    Item Basic Extension     Blink ✓    Read battery ✓    Temperature and humidity sensor ✓    Illum sensor ✓    Accelerometer ✓    Speaker ✓ ✓   IR sensor ✓ ✓   Sound level meter ✓ ✓   LCD ✓ ✓    ESP32 Beginner Examples    Item ESP32 Wi-Fi Basic Extension     Button ✓     Real time clock ✓     microSD card ✓     Temperature and humidity sensor ✓ ✓    Illum sensor ✓ ✓    Accelerometer ✓ ✓    Speaker ✓ ✓ ✓   IR sensor ✓ ✓ ✓   Sound level meter ✓ ✓ ✓   LCD ✓ ✓ ✓    STM32 Beginner Examples    Item STM32 MCU Basic Extension     Read battery ✓ ✓    Temperature and humidity sensor ✓ ✓    Illum sensor ✓ ✓    Accelerometer ✓ ✓    Speaker ✓ ✓ ✓   IR sensor ✓ ✓ ✓   Sound level meter ✓ ✓ ✓   LCD ✓ ✓ ✓     Advanced Examples　 Here are some sample apps for advanced users using various types of leaves. Take a look at the sample apps and convert your everyday objects into IoT.\nAVR Advanced Examples    Item Basic Extension LoRa Motor     Simple BLE Characteristic (in progress) ✓      Simple BLE Advertising (in progress) ✓      Web Bluetooth IoT ✓      Google sheets IoT ✓      4-sensors LCD ✓ ✓     4-sensors LCD BLE (in progress) ✓ ✓     PIR melody test ✓ ✓     Distance sensor ✓ ✓     Camera ✓ ✓     LoRa ✓ ✓ ✓    Watering plants with a motor ✓   ✓    ESP32 Advanced Examples    Item ESP32 Wi-Fi Basic     Wi-Fi touchsensor ✓    Google Sheets with ESP32 ✓ ✓   Logger Beacon ✓ ✓    STM32 Advanced Examples    Item STM32 MCU Basic     Web Bluetooth IoT with STM32 ✓ ✓   Simple Ble Beacon ✓ ✓   4-Sensors Ble Beacon (in progress) ✓ ✓   BLE Logger Beacon ✓ ✓    ","excerpt":"Beginner Examples Here are some sample apps for beginners using various types of leaves. Let\u0026rsquo;s …","ref":"https://docs.leafony.com/en/docs/examples/","title":"Sample App"},{"body":"  \nFeatures 32-bit MCU leaf with ARM Cortex-M4 32-bit RISC core with STMicroelectronics FPU; connect USB leaf for USB connection or Shield leaf for SWD use.\nSpecification    Item Description     Part number STM32L452REI6   Core ARM Cortex-M4   Operating voltage 3.3V   Input voltage 3.0-3.6V   Flash Memory 512 KB   SRAM 160 KB   Clock frequency 80MHz   Arduino IDE Board Settings Board: ”Nucleo-64”    Board Part number: \u0026ldquo;NUCLEO L452RE\u0026rdquo;    Upload method: ”STM32CubeProgrammer(Serial)   Dimension W23×D20.5×H4.7mm    Block diagram \nPinassign \nTips About LEDs and switches \n   Item Description     LED Lights up when in write mode.   Reset switch Resets the STM32 and other devices.   Program switch Switch to change to Program mode.    Sample App How to use it with Arduino In order to use this leaf with Arduino, you need to configure the board on Arduino IDE.\nPlease refer to Environment for setting instructions.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A: First edition, November 2020  ","excerpt":"Features 32-bit MCU leaf with ARM Cortex-M4 32-bit RISC core with STMicroelectronics FPU; connect …","ref":"https://docs.leafony.com/en/docs/leaf/processor/ap03/","title":"AP03 STM32 MCU"},{"body":"Template Project for Board CAD You can use Leafony\u0026rsquo;s template projects for various types of circuit CAD to help you design your boards.\n KiCad CR-8000 Design Force  I2C Address Map There are several leaves in the Leafony kit that use I2C communication.\nWhen the same I2C pin is used to communicate with multiple ICs, the same I2C address cannot be used, in principle.\nWhen using I2C communication on your own board, design your board so that the addresses do not overlap.\nThe addresses already in use are shown in the table below.\n   Type Leaf Description Chip I2C Address     AI01 4-Sensors Temperature and humidity sensor HTS221TR 0x5F - -  Illuminance sensor OPT3001 0x45 0x44 -   Accelerometer LIS3DHTR 0x19 - -   AI02 SP\u0026PIR PIR AK9754 0x65 0x66 -   AI03 MIC\u0026VR\u0026LED IO Expander PCA9557RGVR 0x1B - -   AI04 LCD LCD AQM0802A-RN-GBW 0x3E - -  IO Expander PCA9557RGVR 0x1A 0x1E -   AV01-AV04 BAT ADC ADC081C027CIMK 0x50 0x51 0x52   AV05 Solar ADC ADC081C027CIMK 0x52 0x50 0x51   AV06 Grove IO Expander PCA9557RGVR 0x18 - -   AZ02 SD\u0026RTC Real Time Clock Chip 0x68 - -    Leafony bus Pin layout \nBoard Manufacturing Tutorial Installation and removal of chip components These videos show you how to install and remove small chip resistors and capacitance from the leaf.\nHow to install chip components   How to remove chip components  ","excerpt":"Template Project for Board CAD You can use Leafony\u0026rsquo;s template projects for various types of …","ref":"https://docs.leafony.com/en/docs/pcb/","title":"Home-made leaf development"},{"body":"  \nFeatures A 32-bit MCU leaf with an ARM Cortex-M4 32-bit RISC core with STMicroelectronics FPU and two Leafony buses; connect a USB leaf for USB connection or a Shield leaf for SWD use Connect a USB leaf for USB connection or a Shield leaf for SWD use.\nSpecification    Item Description     Part number STM32L452REI6   Core ARM Cortex-M4   Operating voltage 3.3V   Input voltage 3.0-3.6V   Flash Memory 512 KB   SRAM 160 KB   Clock frequency 80MHz   Arduino IDE Board Settings Board: ”Nucleo-64”    Board Part number: \u0026ldquo;NUCLEO L452RE\u0026rdquo;    Upload method: ”STM32CubeProgrammer(Serial)   Dimension W23×D28×H4.7mm    Block diagram \nPinassign \nTips About LEDs and switches \n   Item Description     LED Lights up when in write mode.   Reset switch Resets the STM32 and other devices.   Program switch Switch to change to Program mode.    Sample App How to use it with Arduino In order to use this leaf with Arduino, you need to configure the board on Arduino IDE.\nPlease refer to Environment for setting instructions.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A: First edition, December 2020  ","excerpt":"Features A 32-bit MCU leaf with an ARM Cortex-M4 32-bit RISC core with STMicroelectronics FPU and …","ref":"https://docs.leafony.com/en/docs/leaf/processor/ap04/","title":"AP04 STM32 MCU 2Bus"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/lowpower/","title":"Lowpower (in progress)"},{"body":"A list of sample apps for advanced users.\n","excerpt":"A list of sample apps for advanced users.","ref":"https://docs.leafony.com/en/docs/examples/advanced/","title":"Advanced Examples"},{"body":"Overview The Leafony template design data for the CR-8000 Design Force makes leaf board design easy. The template design data contains the following items.\n 2cm x 2cm Leaf outline Leafony bus footprint Other Parts Footprint Design rule  Download You can download the template design data from the link below.\nGitHub - Leafony/cad-template\nDevelopment Environment  CR-8000 Design Force 2020 or later  Usage  Start the CR-8000 Design Force. File -\u0026gt; Open -\u0026gt; Design Data. Select the template design data you downloaded and click Open.  ","excerpt":"Overview The Leafony template design data for the CR-8000 Design Force makes leaf board design easy. …","ref":"https://docs.leafony.com/en/docs/pcb/cr-8000_design_force/","title":"CR-8000 Design Force Template Design Data"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/exten/4-sensors_lcd_ble/","title":"4-Sensors LCD BLE (in progress)"},{"body":"Overview This sample reads the value of the temperature and humidity sensor on the 4-Sensors Leaf and displays it on a serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Thermo-Hygrometer // // (c) 2021 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // 2点補正用データ //--------------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); Wire.begin(); // I2C 100kHz  // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // 温度補正  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // 湿度補正  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } Thermo-Hygrometer.ino\nTwo-point correction If there is a discrepancy between the temperature (or humidity) you want to display and the 4-Sensors' temperature (or humidity), perform a two-point correction. The following is an example of how to compensate for this, using temperature as an example.\nFirst, measure the temperature at two points with the 4-Sensors and a reference instrument. Then, write the measured values into a sample sketch and execute them, and the temperature of the 4-Sensors will be close to the temperature you want to display.　Execution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the temperature and humidity.\n","excerpt":"Overview This sample reads the value of the temperature and humidity sensor on the 4-Sensors Leaf …","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/basic/temp_humid_sensors/","title":"Temperature and humidity sensor"},{"body":"Overview This sample reads the value of the temperature and humidity sensor on the 4-Sensors Leaf and displays it on a serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program1 in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Thermo-Hygrometer // // (c) 2021 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // 2点補正用データ //--------------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); Wire.begin(); // I2C 100kHz  // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // 温度補正  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // 湿度補正  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } Thermo-Hygrometer.ino\n2 point-to-point correction If there is a discrepancy between the temperature (or humidity) that you want to display and the temperature (or humidity) of the 4-Sensors, perform the correction between the two points. The following is a description of the correction method using temperature as an example.\nFirst, measure the temperatures of the two points with the 4-Sensors and a reference instrument. Then, write the measured values in the sample sketch and run it, and the temperature of the 4-Sensors will be close to the temperature you want to display.　Execution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the temperature and humidity.\n  The program is the same as AVR MCU Leaf. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview This sample reads the value of the temperature and humidity sensor on the 4-Sensors Leaf …","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/basic/temp_humid_sensors/","title":"Temperature and humidity sensor"},{"body":"Communication Leaf List\n","excerpt":"Communication Leaf List","ref":"https://docs.leafony.com/en/docs/leaf/communication/","title":"Communication"},{"body":"A Leafony bus is the name of a common pathway section that connects multiple leaves to each other. It defines the electrical and physical specifications (20mm x 5.5mm) for the electrical signal and power connections.\n20 mm x 5.5 mm substrate dimensions The thickness of the board is t=0.8 and the pad part is gold plated. Please refer to AX02 29pin for the data of the board layout.\n","excerpt":"A Leafony bus is the name of a common pathway section that connects multiple leaves to each other. …","ref":"https://docs.leafony.com/en/docs/leafony-bus/","title":"Leafony-bus"},{"body":"Overview This sample reads the value of the illuminance sensor on the 4-Sensors leaf and displays it on the serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Illuminance meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the illuminance.\n","excerpt":"Overview This sample reads the value of the illuminance sensor on the 4-Sensors leaf and displays it …","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/basic/illum_sensor/","title":"Illum sensor"},{"body":"Overview This sample reads the value of the illuminance sensor on the 4-Sensors leaf and displays it on the serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program1 in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Illuminance meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the illuminance.\n  The program is the same as AVR MCU Leaf. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview This sample reads the value of the illuminance sensor on the 4-Sensors leaf and displays it …","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/basic/illum_sensor/","title":"Illum sensor"},{"body":"Processor  AP01 AVR MCU  This leaf uses the ATmega328P and features 14 digital input and output pins (six of which can be used as PWM outputs), six analog input pins, an 8 MHz oscillator, and a reset button.\nBasic Kit    AP02 ESP32 MCU  Espressif Systems' ESP32-WROOM-32 32-bit MCU leaf with a module ESP32-WROOM-32 with built-in technically certified Wi-Fi and Bluetooth LE, which includes a USB to UART conversion IC and can write sketches. A step-down power supply circuit provides VBUS and 3.3V. It also has a reset button.\nESP32 Wi-Fi Kit    AP03 STM32 MCU  32-bit MCU leaf with ARM Cortex-M4 32-bit RISC core with STMicroelectronics FPU; connect USB leaf for USB connection or Shield leaf for SWD use.\n   Communication  AC02 BLE Sugar  The Leaf is equipped with Silicon Labs' technically certified Bluetooth LE module BGM11S22F256GA-V2.\nBasic Kit    AC03 LoRa Easy  The Leaf is equipped with EASEL\u0026rsquo;s technically certified LoRa module ES920LRA1.\n   IO  AI01 4-Sensors  This leaf is equipped with a temperature/humidity sensor, an illuminance sensor and an acceleration sensor. Equipped with power-saving sensors and suitable for long-term sensing.\nBasic Kit    AI02 SP\u0026amp;PIR  The Leaf is equipped with a piezoelectric speaker and a motion sensor. The motion sensor has a built-in proximity detection algorithm and can detect the approach of an object with simple settings.\nExtension Kit    AI03 MIC\u0026amp;VR\u0026amp;LED  This leaf is equipped with a MEMS microphone, volume and LED. It can be powered off with a load switch by controlling the I2C Expander to achieve low power consumption.\nExtension Kit    AI04 LCD  This leaf is equipped with a character LCD unit and two user switches. It can be powered off with a load switch by controlling the I2C Expander to achieve low power consumption.\nExtension Kit    Power  AV01 CR2032  This power supply leaf contains a CR2032 coin cell battery holder, a power switch, an AD converter for voltage monitoring, and a 3.3 V to 3.3 V step-up circuit. 2cm x 2cm in size, it is capable of supplying 3.3 V power.\nBasic Kit    AV02 CR2450  This power supply leaf contains a CR2450 coin cell battery holder, a power switch, an AD converter for voltage monitoring, and a 3 V to 3.3 V step-up circuit.\n   AV03 AA BAT  This is a power supply leaf with an AA battery holder, a power switch, an AD converter for voltage monitoring, a 3 V to 3.3 V boost circuit, and three Leafony connectors to provide power to more leaves.\nExtension Kit    AV04 2V～4.5V  The power supply leaflet contains a JST SH connector for lithium-ion battery or battery box connection, a power switch, an AD converter for voltage monitoring and a 3.3 V step-up/down circuit.\nESP32 Wi-Fi Kit    Extension  AX01 Shield  An expansion board with an Arduino Shield connector, a SWD connector, an ICSP connector, and three leaf I/Fs mounted on it.\nExtension Kit    AX02 29pin  A leaf with all 29 pins of the leaf I/F connected to a 2.54mm pitch through-hole.\nBasic Kit    AX03 Leaf x2  This connector leaf is used to connect the leafs side-by-side.\nExtension Kit    AX04 Spacer  A spacer leaf that is placed between two stacked leaves. It can be used when parts of the leafs interfere with each other.\nExtension Kit    AX05 I Meas.  This leaf is used to measure the current flowing in the 3.3V and VBUS. Normally, the Leafony bus is electrically connected on both sides, but in this leaf, only the 3.3V and VBUS are disconnected in the front and the back, and they are connected to the through-hole.\nExtension Kit    AX06 Grove\u0026amp;5V  The Grove is a Grove Series compliant leaf from Seeed Studio that operates at 5V with UART, I2C, analog and digital inputs, converted from 3.3V to 5V by a step-up power supply circuit and supplied to the Grove. To achieve low power consumption, it is possible to turn off the 5V power supply by controlling the I2C Expander.\nExtension Kit    AX07 Back to back  A connector leaf that can be connected back to back.\nESP32 Wi-Fi Kit    AX08 29pin header  A leaf with all 29 pins of the leaf I/F connected to a 2.54mm pitch pin header.\nESP32 Wi-Fi Kit    Others  AZ01 USB  A leaf to connect when writing a sketch to an AVR MCU or using a serial monitor. FTDI\u0026rsquo;s FT232RQ is mounted as a USB-UART conversion IC. It converts from USB VBUS (5V) to 3.3V with a step-down power supply circuit and supplies VBUS and 3.3V to each leaf.\nBasic Kit    AZ02 RTC\u0026amp;microSD  This leaf is equipped with NXP\u0026rsquo;s Real-Time Clock PCF8523TK and a microSD card slot. The RTC can output interrupts to the MCU with alarms and timers, while the microSD card is accessible via SPI.\nESP32 Wi-Fi Kit    AZ61 Connector  The Leafony Platform is based on ACRs (Anisotropic Conductive Rubber), which is an insulating silicone rubber with metal or conductive elastomeric conductive elements arranged at a narrow pitch, which can be compressed to create an electrical connection.\nConnector    AZ62 Connector Cover  The Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris.\nNut \u0026 Conn. Cover    AZ63 Nut Plate  The Nut Plate is used to fix the leaf with a screw. Be careful not to use commercially available hex nuts as they may cause a short circuit by touching the electrodes on the board.\nNut \u0026 Conn. Cover    AZ66 Basic kit case  This is a case for the Basic Kit. It can be fixed to the wall with the magnets on the bottom.\nBasic Kit   ","excerpt":"Processor  AP01 AVR MCU  This leaf uses the ATmega328P and features 14 digital input and output pins …","ref":"https://docs.leafony.com/en/docs/leaf/","title":"Leaf Technical Sheets"},{"body":"Overview Using LoRa Easy leaf, sensor data (temperature, humidity, illumination, tilt) can be sent to a distant location and output to a PC terminal.\n\nIf there is a discrepancy between the temperature (or humidity) you want to display and the temperature (or humidity) of the 4-Sensors, perform the correction between the two points. For details, see here.\nDemo Video   Leaf to use Use the following leaves.\nSending side leaf    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AX04 Spacer 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV03 CR2032 1   AZ01 USB 1   AZ61 Connector 2   AZ62 Connector Cover 3   AZ63 Nut Plate 2    AA battery 1    M2*25mm screw 6    Receiving side leaf    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AP01 AVR MCU 1   AX03 Leaf x2 1   AZ01 USB 1   AZ62 Connector Cover 2   AZ63 Nut Plate 2    M2*15mm screw 4    Assembly Assemble the leaves as shown in the figure below.\nSending side Receiving side Source code  4-Sensors and AVR MCU library (timer interrupt) are required for writing. Please include the library beforehand. For details, see here. In the Arduino IDE, write the following program.  Sending side 4-Sensors_LoRa_Tx.ino Receiving side LoRa_Rx_Serial_monitor.ino     Execution result Open the serial monitor in the Arduino IDE and set the baud rate to 9600 bps to display the sensor data (temperature, humidity, illumination, and tilt).\n","excerpt":"Overview Using LoRa Easy leaf, sensor data (temperature, humidity, illumination, tilt) can be sent …","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/lora/lora/","title":"LoRa"},{"body":"Overview This sample reads the value of the accelerometer on the 4-Sensors Leaf and displays it on a serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below. Source code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries. If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Accelerometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the acceleration and tilt.\n","excerpt":"Overview This sample reads the value of the accelerometer on the 4-Sensors Leaf and displays it on a …","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/basic/accelerometer/","title":"Accelemeter"},{"body":"Overview This sample reads the value of the accelerometer on the 4-Sensors Leaf and displays it on a serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program1 in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries. If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Accelerometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the acceleration and tilt.\n  The program is the same as AVR MCU Leaf. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview This sample reads the value of the accelerometer on the 4-Sensors Leaf and displays it on a …","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/basic/accelerometer/","title":"Accelerometer"},{"body":"Overview Using the infrared sensor IC for short range detection (AKM AK9754AE) installed in the SP\u0026amp;PIR leaf, let\u0026rsquo;s create a system that plays a melody when a person approaches.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Assemble the leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n//===================================================================== // Leafony Platform sample sketch // Platform : PIR\u0026amp;SP // Processor : ATmega328P (3.3V /8MHz) // Application : PIR with SP Beep // // Leaf configuration // (1) AI02 SP\u0026amp;PIR // (2) AP01 AVR MCU // (3) AZ01 USB // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //===================================================================== // difinition //===================================================================== #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;Arduino.h\u0026gt;#include \u0026lt;Wire.h\u0026gt;#include \u0026#34;pitches.h\u0026#34; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; #define I2C_RECEIVE_BUF_LENGTH 10 unsigned char i2c_receiveBuf[I2C_RECEIVE_BUF_LENGTH]; unsigned char i2c_receiveLenght; //------------------------------ // buzzer output = 5pin //------------------------------ #define BUZZER_OUT 5  byte readReg; double irData; double tempData; char buf[120]; volatile int state = 0; //===================================================================== // setup //===================================================================== void setup() { //pinMode(2, INPUT);  attachInterrupt(0,catchHuman , FALLING ); //人接近検知割り込み  Wire.begin(); Serial.begin( 115200 ); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); } //===================================================================== // Main loop //===================================================================== void loop() { clearI2CReadbuf(); i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_receiveBuf); sprintf(buf, \u0026#34;REG = %02X , %02X , %02X , %02X , %02X , %02X\u0026#34;, i2c_receiveBuf[0], i2c_receiveBuf[1], i2c_receiveBuf[2], i2c_receiveBuf[3], i2c_receiveBuf[4], i2c_receiveBuf[5]); Serial.println(buf); sprintf(buf, \u0026#34;Human detection = %d\u0026#34;, (i2c_receiveBuf[0] \u0026amp; 0x10) \u0026gt;\u0026gt; 4 ); Serial.println(buf); //IRセンサ測定データ  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); //センサ温度  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); if (state == 1){ //------------------------------  // notes in the melody:  //------------------------------  int melody[] = { NOTE_C5, NOTE_C5, NOTE_G5, NOTE_G5, NOTE_A5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_F5, NOTE_E5, NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5 }; //------------------------------  // note durations: 4 = quarter note, 8 = eighth note, etc.:  //------------------------------  int noteDurations[] = { 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 2 }; //----------------------------------------  // iterate over the notes of the melody:  //----------------------------------------  for (int thisNote = 0; thisNote \u0026lt; 14; thisNote++) { //----------------------------------------  // to calculate the note duration, take one second  // divided by the note type.  //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.  //----------------------------------------  int noteDuration = 1000 / noteDurations[thisNote]; tone(BUZZER_OUT, melody[thisNote], noteDuration); //----------------------------------------  // to distinguish the notes, set a minimum time between them.  // the note\u0026#39;s duration + 30% seems to work well:  //----------------------------------------  float pauseBetweenNotes = noteDuration * 1.30; delay(pauseBetweenNotes); //-----------------------  // stop the tone playing:  //-----------------------  noTone(BUZZER_OUT); } state = 0; } delay(1000); } //===================================================================== void catchHuman(){ state = 1; Serial.println(\u0026#34;!! Interrupt !!\u0026#34;); //人の接近を検知 } //===================================================================== double clacTemp(){ double ret; unsigned short val = (unsigned short)((i2c_receiveBuf[4] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } //===================================================================== double clacIR(){ double ret; unsigned short val = (unsigned short)((i2c_receiveBuf[2] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C スレーブデバイスに1バイト書き込む **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから1バイト読み込む **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C スレーブデバイスに複数バイト書き込む **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから複数バイト読み込む **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C 受信バッファクリア **********************************************/ void clearI2CReadbuf(){ memcpy(i2c_receiveBuf, 0x00, I2C_RECEIVE_BUF_LENGTH); } PIR_Melody_test.ino\nExecution result The melody sounds when someone approaches.\n","excerpt":"Overview Using the infrared sensor IC for short range detection (AKM AK9754AE) installed in the …","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/exten/pir_melody_test/","title":"PIR melody test"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/exten/","title":"Basic Kit + Extension Kit"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/exten/","title":"STM32 MCU + Basic Kit + Extension Kit"},{"body":"IO Leaf List\n","excerpt":"IO Leaf List","ref":"https://docs.leafony.com/en/docs/leaf/io/","title":"IO"},{"body":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AI02 SP\u0026amp;PIR 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Open the Arduino, go to File → Sketch Examples → 02.Digital → toneMelody.\nIn this sample code, the speaker is supposed to be connected to pin number 8.\nBut as the loudspeaker is connected to pin 5 in Leafony, you should fix the following part to make it correct.\n Change the 8 to 5 in line 37.  tone(5, melody[thisNote], noteDuration);  Change 8 to 5 in line 44.  noTone(5); Execution Results The melody sounds only once from the speakers.\n","excerpt":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to …","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/exten/speaker/","title":"Speaker"},{"body":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AI02 SP\u0026amp;PIR 1   AP03 STM32 MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Open the Arduino, go to File → Sketch Examples → 02.Digital → toneMelody.\nIn this sample code, the speaker is supposed to be connected to pin number 8.\nBut as the loudspeaker is connected to pin 5 in Leafony, you should fix the following part to make it correct.1\n Change the 8 to PB4 in line 37.  tone(PB4, melody[thisNote], noteDuration);  Change 8 to PB4 in line 44.  noTone(PB4); Execution Results The melody sounds only once from the speakers.\n  The program differs from the AVR MUC leaf only in the designation of the pins. For more information, here. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to …","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/exten/speaker/","title":"Speaker"},{"body":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR Leaf, let\u0026rsquo;s create a system that makes a sound when a person approaches.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n//===================================================================== // STM32 Human Sensing // // (c) 2021 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/01/26 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; // 人を検出したら呼び出される関数 void onHumanDetected() { Serial.println(\u0026#34;Detect!\u0026#34;); tone(PB4, 262, 300); // ビープ音を鳴らす } void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with AK9754AE:  Wire.begin(); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); //人接近検知割り込み  attachInterrupt(PC7, onHumanDetected, FALLING ); } void loop() { // バッファをクリア  clearI2CReadbuf(); // レジスタ読み出し  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); //IRセンサ  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); //センサ温度  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); delay(1000); } double clacTemp() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } double clacIR() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C スレーブデバイスに1バイト書き込む **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから1バイト読み込む **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C スレーブデバイスに複数バイト書き込む **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから複数バイト読み込む **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C 受信バッファクリア **********************************************/ void clearI2CReadbuf(){ memset(\u0026amp;i2c_recvBuf[0], 0x00, sizeof(i2c_recvBuf)); } Human_Sensing.ino\nExecution Results Sounds as the person approaches.\n","excerpt":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR …","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/exten/ir_sensor/","title":"IR sensor"},{"body":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR Leaf, let\u0026rsquo;s create a system that makes a sound when a person approaches.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program1 in the Arduino IDE.\n//===================================================================== // STM32 Human Sensing // // (c) 2021 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/01/26 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; // 人を検出したら呼び出される関数 void onHumanDetected() { Serial.println(\u0026#34;Detect!\u0026#34;); tone(PB4, 262, 300); // ビープ音を鳴らす } void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with AK9754AE:  Wire.begin(); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); //人接近検知割り込み  attachInterrupt(PC7, onHumanDetected, FALLING ); } void loop() { // バッファをクリア  clearI2CReadbuf(); // レジスタ読み出し  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); //IRセンサ  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); //センサ温度  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); delay(1000); } double clacTemp() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } double clacIR() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C スレーブデバイスに1バイト書き込む **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから1バイト読み込む **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C スレーブデバイスに複数バイト書き込む **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから複数バイト読み込む **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C 受信バッファクリア **********************************************/ void clearI2CReadbuf(){ memset(\u0026amp;i2c_recvBuf[0], 0x00, sizeof(i2c_recvBuf)); } STM32_Human_Sensing.ino\nExecution Results Sounds as the person approaches.\n  The program differs from the AVR MUC leaf only in the designation of the pins. For more information, here. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR …","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/exten/ir_sensor/","title":"IR sensor"},{"body":"  \nFeatures The MEMS microphone and volume are connected to the MCU leaf via analog input pins and the LED is connected to the digital output pins. To achieve low power consumption, the power can be turned off using a load switch controlled by the I2C Expander.\nSpecification Dimension    Item Description     Dimension  W23×D20.5×H4.7mm    Microphone    Item Description     Part number SPW2430HR5H-B   Type MEMS   Direction Omnidirectional   Frequency range 100Hz ～ 10kHz   Gain 0dB   Interfaces Analog    Volume    Item Description     Part number ST-4ETA10kΩ   Nominal resistance 10kΩ   Resistance law Linear law (B)   Effective electrical angle 210° (1 turn)    LED    Item Description     Part number SML-A12Y8TT86   Package type Side-view   Emitting color Yellow    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1B)    Block diagram \nPinassign \nTips About Microphone, Volume and LED \n   Item     Microphone MK500   Volume VR500   LED    Sample App AVR MCU Examples  Sound Level Meter  ESP32 MCU Examples  Sound Level Meter  Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  ","excerpt":"Features The MEMS microphone and volume are connected to the MCU leaf via analog input pins and the …","ref":"https://docs.leafony.com/en/docs/leaf/io/ai03/","title":"AI03 MIC\u0026VR\u0026LED"},{"body":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of rotation. You can also turn on the number of LEDs according to the ambient volume with the microphone.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AI03 MIC\u0026amp;VR\u0026amp;LED 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n//===================================================================== // Sound level meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/17 First release //===================================================================== #define AVR_LED 13 #define LED1 6 #define LED2 7 #define LED3 8 #define LED4 9 #define LED5 10 #define LED6 11  #define MIC 16 #define VR 17  unsigned int dataVR; unsigned int dataMic; //----------------------------------------------- // VRとMICデータを取得する //----------------------------------------------- void getSensorData() { dataVR = analogRead(A3); dataMic = analogRead(A2); Serial.println(\u0026#34;---------------------\u0026#34;); Serial.print(\u0026#34;MIC = \u0026#34;); Serial.println(dataMic,DEC); Serial.print(\u0026#34;VR = \u0026#34;); Serial.println(dataVR,DEC); } //----------------------------------------------- // VRとMICの値にあわせてLEDを点灯、消灯させる //----------------------------------------------- void dispSensorData() { if (dataVR \u0026lt; 400) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 400 \u0026amp;\u0026amp; dataVR \u0026lt; 800) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 800 \u0026amp;\u0026amp; dataVR \u0026lt; 900) { digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else { digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; 700) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= 700 \u0026amp;\u0026amp; dataMic \u0026lt; 800) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= 800 \u0026amp;\u0026amp; dataMic \u0026lt; 850) { digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else { digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup() { Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(AVR_LED, OUTPUT); digitalWrite(AVR_LED, LOW); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); //起動テスト(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); } void loop() { getSensorData(); dispSensorData(); delay(100); } Sound_Level_Meter.ino\nExecution Results As you rotate the volume, the number of LEDs will light up according to the amount of rotation. The number of LEDs will light up according to the ambient volume, depending on the microphone.\n","excerpt":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of …","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/exten/sound_level/","title":"Sound level meter"},{"body":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of rotation. You can also turn on the number of LEDs according to the ambient volume with the microphone.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AI03 MIC\u0026amp;VR\u0026amp;LED 1   AP03 STM32 MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program1 in the Arduino IDE.\n//===================================================================== // STM32 Sound level meter // // (c) 2021 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/01/26 First release //===================================================================== #define LED1 PA8 // D6 #define LED2 PB12 // D7 #define LED3 PA9 // D8 #define LED4 PA10 // D9 #define LED5 PB6 // D10 #define LED6 PA7 // D11  #define MIC PA1 // A2 #define VR PB0 // A3  unsigned int dataVR; unsigned int dataMic; //----------------------------------------------- // VRとMICデータを取得する //----------------------------------------------- void getSensorData() { dataVR = analogRead(VR); dataMic = analogRead(MIC); Serial.println(\u0026#34;---------------------\u0026#34;); Serial.print(\u0026#34;MIC = \u0026#34;); Serial.println(dataMic,DEC); Serial.print(\u0026#34;VR = \u0026#34;); Serial.println(dataVR,DEC); } //----------------------------------------------- // VRとMICの値にあわせてLEDを点灯、消灯させる //----------------------------------------------- void dispSensorData() { if (dataVR \u0026lt; 400) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 400 \u0026amp;\u0026amp; dataVR \u0026lt; 800) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 800 \u0026amp;\u0026amp; dataVR \u0026lt; 900) { digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else { digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; 300) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= 300 \u0026amp;\u0026amp; dataMic \u0026lt; 350) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= 350 \u0026amp;\u0026amp; dataMic \u0026lt; 450) { digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else { digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup() { Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); //起動テスト(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); } void loop() { getSensorData(); dispSensorData(); delay(100); } STM32_Sound_Level_Meter.ino\nExecution Results As you rotate the volume, the number of LEDs will light up according to the amount of rotation. The number of LEDs will light up according to the ambient volume, depending on the microphone.\n  The program differs from the AVR MUC leaf only in the designation of the pins. For more information, here. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of …","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/exten/sound_level/","title":"Sound level meter"},{"body":"The following cautions apply when using ESP32.\nDesignating pins on the Arduino Specify by the ESP32 IO number, not the Arduino pin name. The Arduino pin names A1 and A2 cannot be used as analog inputs when using Wi-Fi (when including WiFi.h).\nArduino pin numbers A0, A3, A4, and A5 cannot be used as outputs.\n   Arduino pin names ESP32 IO number Restrictions     A0 IO36 Effort setting is not possible   A1 IO25 ※1   A2 IO26 ※1   A3 IO39 Effort setting is not possible   A4 IO34 Effort setting is not possible   A5 IO35 Effort setting is not possible    ※1：A1 and A2 cannot be used as analog inputs when Wi-Fi is used (when WiFi.h is included).\nThe following pins are used for bootstrapping and have pull-up and pull-down limitations.\n   Arduino pin names ESP32 IO number Restrictions     D4 IO12 Pull-up prohibition   D7 IO15 pulldown prohibition   D10 IO5 pulldown prohibition    Battery operation The ESP32 MCU does not operate on coin cell batteries.\nUART The ESP32 can use three hardware serial systems: UART0 and UART2 are shown below.\n   UART number Signal name Arduino pin names ESP32 IO number     UART0 RXD0 D0 IO3    TXD0 D1 IO1   UART2 TXD2 D8 IO17    RXD2 D9 IO16    If you want to use UART1, you need to change the pin number. Usually, Arduino pin numbers A1 and A2 are used as UART1. The pin numbers after the change are as follows\n   UART number Signal name Arduino pin names ESP32 IO number     UART1 TXD1 A1 IO25    RXD1 A2 IO26    Example of an Arduino sketch setup\nHardwareSerial Serial1(1); // UART1 (RX=9, TX=10)  void setup() { Serial1.begin(9600, SERIAL_8N1, 26, 25); // ピンを変更 (RX=26, TX=25) } \nTouch sensor ESP32 has the function of a capacitive touch sensor. Since the value changes depending on the capacitance of the wiring, it is necessary to adjust the threshold value.\n   Leafony pin number Arduino pin names ESP32 IO number Touch sensor number Remarks     7 D6 IO14 T6 －   9 D7 IO15 T3 －   22 D2 IO4 T0 －   24 D3 IO27 T7 Cannot be used with ESP32 Wi-Fi Kit   26 D4 IO12 T5 －   28 D5 IO13 T4 －    ","excerpt":"The following cautions apply when using ESP32.\nDesignating pins on the Arduino Specify by the ESP32 …","ref":"https://docs.leafony.com/en/docs/environment/esp32/esp32_notice/","title":"Points to note when using ESP32"},{"body":"  \nFeatures This leaf is equipped with a character LCD unit and two switches. The LCD unit is connected to the MCU leaf via I2C. The switch is connected to the digital input pin of the MCU and the P1 pin of the I2C Expander. To achieve low power consumption, the I2C Expander can be controlled to turn off the power supply with a load switch.\nSpecification Dimension    Item Description     Dimension  W30.8×D30.5×H5.3mm    LCD    Item Description     Part number AQM0802A-RN-GBW   Display format 8x2 Character   Viewing area (WxH) 27x10.5mm   Dot size (WxH) 0.45x0.5mm   Dot pitch (WxH) 0.5x0.55mm   Character size (WxH) 2.45x4.35mm   Character pitch (WxH) 2.95x4.9mm   Viewing direction 6:00 O\u0026rsquo;Clock   Driving method 1/16Duty,1/5Bias   Controller IC ST7032I-0D(Sitronix) or compatible   Display mode STN (Gray)/Positive/Reflective   Interfaces I2C (Address: 0x3E)    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1A or 0x1E)    Block diagram \nPinassign \nTips About the switch \n   Item Description     Switch1 Connected to pin 2   Switch2 Connected to I2C Expander P1 pin    Sample App AVR MCU Examples  LCD 4-Sensors Lcd Distance sensor  ESP32 MCU Examples  LCD  Library Libraries are available for this leaf. Please install the necessary libraries from Environment to use them.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Features This leaf is equipped with a character LCD unit and two switches. The LCD unit is connected …","ref":"https://docs.leafony.com/en/docs/leaf/io/ai04/","title":"AI04 LCD"},{"body":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt also comes with two button switches and can be used as a controller.\nLeaf to use Let\u0026rsquo;s assemble leaves as shown in the figure below.\n   Name Q\u0026rsquo;ty      AZ62 Connector Cover 1   AI04 LCD 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to use MIC\u0026amp;VR\u0026amp;LED Leaf, you need to install the library. If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : ATmega328P (3.3V /8MHz) // // Leaf configuration // (1) AI04 LCD // (2) AP01 AVR MCU // (3) AZ01 USB // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== // use libraries // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IOピンの名前定義 // 接続するリーフに合わせて定義する //----------------------------------------------- #define SW1 2 // PD2 (INT0)  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8文字, 2行  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8文字, 2行  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop(){ char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- //I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } LED-SW_test.ino\nExecution Results On the LCD the screens are displayed in the following order\n The \u0026ldquo;Hello\u0026rdquo; string Moving the cursor Button input status display  ","excerpt":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt …","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/exten/lcd/","title":"LCD"},{"body":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt also comes with two button switches and can be used as a controller.\nLeaf to use    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI04 LCD 1   AP03 STM32 MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE. The Basic Kit differs from the Basic Kit only in the specification of the pins. In order to use MIC\u0026amp;VR\u0026amp;LED Leaf, you need to install the library. If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : STM32L452RE (Nucleo-64/Nucleo L452RE) // // Leaf configuration // (1) AI04 LCD // (2) AP03 STM32 MCU // (3) AZ01 USB // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2021/01/26 First release //===================================================================== // use libraries // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IOピンの名前定義 // 接続するリーフに合わせて定義する //----------------------------------------------- #define SW1 PC7 // D2 (INT0)  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8文字, 2行  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8文字, 2行  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop(){ char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- //I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } STM32_LED-SW_test.ino\nExecution Results On the LCD the screens are displayed in the following order\n The \u0026ldquo;Hello\u0026rdquo; string Moving the cursor Button input status display  ","excerpt":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt …","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/exten/lcd/","title":"LCD"},{"body":"  \nFeatures This leaf is equipped with a motor driver that can connect two DC motors.\nSpecification    Item Description     Part number TB6612FNG   Motor Supply Voltage 2.5V~13.5V   Output current (Vm≧4.5V) 1A   Output current (4.5V\u0026gt;Vm≧2.5V) 0.4A   Dimension W25.6×D30.9×H4.7mm        Block diagram \nPinassign \nTips Harness Connection \n   Pin Description     1 Motor A+   2 Motor A-   3 Motor B-   4 Motor B+   5 GND   6 Motor Supply (Vm)   7 GND   8 3.3V    Sample App AVR MCU Examples  Motor_BLE_demo  Library There is a library that supports this leaf.Please install and use the necessary libraries in Environment.\nDocument  Spec sheet Schematic PCBLayout(KiCad) 3D drawing  Revision history  First edition, December 2020  ","excerpt":"Features This leaf is equipped with a motor driver that can connect two DC motors.\nSpecification …","ref":"https://docs.leafony.com/en/docs/leaf/io/aix1/","title":"AIx1 Motor"},{"body":"Overview The STM32 MCU leaf can be used with STMicroelectronics' STLINK-V3SET and ST-LINK/V2 debuggers. This page explains how to connect to these debuggers.\n STM32 debugger  What to prepare  STM32 MCU、Shield、Screw STLINK-V3SET /ST-LINK/V2＋ARM-JTAG-20-10 USB cable PC (Windows)  Connection method A 1.27mm pitch SWD connector (FTSH-105-01-L-D) is mounted on the Shield leaf, so you can attach an STM32 MCU leaf and connect it to the debugger.\nIn the case of STLINK-V3SET \nIn the case of ST-LINK/V2 + ARM-JTAG-20-10 \n","excerpt":"Overview The STM32 MCU leaf can be used with STMicroelectronics' STLINK-V3SET and ST-LINK/V2 …","ref":"https://docs.leafony.com/en/docs/environment/stm32/stm32_debug/","title":"How to connect the debugger"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/esp32/","title":"ESP32 Wi-Fi Kit"},{"body":"  \nFeatures A CR2032 coin cell battery holder is mounted on this leaf, and the voltage of the 3V battery is converted to 3.3V by a step-up power supply circuit, and 3.3V is supplied to each leaf. A switch for turning on/off the 3.3V is mounted on this leaf. The AD converter for monitoring the battery voltage is mounted in this IC.\nSpecification Dimension    Item Description     Dimension  W24×D20.5×H8.7mm    Power Supply    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    AD Converter    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    Block diagram \nPinassign \nTips About the switch \n   Item Description     Switch Switch for turning on and off the 3.3v power    Sample App  Read Battery  Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Features A CR2032 coin cell battery holder is mounted on this leaf, and the voltage of the 3V …","ref":"https://docs.leafony.com/en/docs/leaf/power/av01/","title":"AV01 CR2032"},{"body":"Power Leaf List\n","excerpt":"Power Leaf List","ref":"https://docs.leafony.com/en/docs/leaf/power/","title":"Power Supply"},{"body":"Overview Displays the status of the boot mode switch on the ESP32 MCU leaf on the serial monitor.\n\nLeaf to use Use the following leaf.\n   Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1    Source code Write the following program in the Arduino IDE.\n//===================================================================== // Button // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/07/02 First release //=====================================================================  int pushButton = 0; void setup() { Serial.begin(115200); pinMode(pushButton, INPUT); } void loop() { int buttonState = digitalRead(pushButton); Serial.println(buttonState); delay(1000); } ESP32_Button.ino\nExecution Results When you press the Boot mode switch, the display on the serial monitor will change from 1 to 0.\n\n","excerpt":"Overview Displays the status of the boot mode switch on the ESP32 MCU leaf on the serial monitor. …","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/esp32/button/","title":"Button"},{"body":"  \nFeatures A CR2450 coin cell battery holder is mounted on this leaf, which converts 3 V battery voltage to 3.3 V using a step-up power supply circuit and supplies 3.3 V to each leaf. A switch for turning on/off the 3.3V is mounted on this leaf. The AD converter for monitoring the battery voltage is mounted in this IC.\nSpecification Dimension    Item Description     Dimension  W25.1×D25.5×H10.5mm    Power Supply    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    AD Converter    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    Block diagram \nPinassign \nTips About the switch \n   Item Description     Switch Switch for turning on and off the 3.3v power    Sample App  Read Battery  Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  ","excerpt":"Features A CR2450 coin cell battery holder is mounted on this leaf, which converts 3 V battery …","ref":"https://docs.leafony.com/en/docs/leaf/power/av02/","title":"AV02 CR2450"},{"body":"Overview The time will be displayed on the serial monitor of the PC.\nLeaf to use Use the following leaf.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AP02 ESP32 MCU 1   AZ02 RTC\u0026amp;microSD 1   AZ63 Nut Plate 1    M2*15mm screw 2    Assembly Source code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n  In the Arduino IDE, go to \u0026ldquo;File\u0026rdquo; -\u0026gt; \u0026ldquo;Sketch Examples\u0026rdquo; -\u0026gt; \u0026ldquo;RTClib\u0026rdquo; -\u0026gt; \u0026ldquo;pcf8523\u0026rdquo; and write it to the microcontroller board.\n  Add 87 lines for low power consumption setting.\n  // Date and time functions using a PCF8523 RTC connected via I2C and Wire lib #include \u0026#34;RTClib.h\u0026#34; RTC_PCF8523 rtc; char daysOfTheWeek[7][12] = {\u0026#34;Sunday\u0026#34;, \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34;}; void setup () { Serial.begin(115200); #ifndef ESP8266  while (!Serial); // wait for serial port to connect. Needed for native USB #endif  if (! rtc.begin()) { Serial.println(\u0026#34;Couldn\u0026#39;t find RTC\u0026#34;); Serial.flush(); abort(); } if (! rtc.initialized() || rtc.lostPower()) { Serial.println(\u0026#34;RTC is NOT initialized, let\u0026#39;s set the time!\u0026#34;); // When time needs to be set on a new device, or after a power loss, the  // following line sets the RTC to the date \u0026amp; time this sketch was compiled  rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); // This line sets the RTC with an explicit date \u0026amp; time, for example to set  // January 21, 2014 at 3am you would call:  // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));  //  // Note: allow 2 seconds after inserting battery or applying external power  // without battery before calling adjust(). This gives the PCF8523\u0026#39;s  // crystal oscillator time to stabilize. If you call adjust() very quickly  // after the RTC is powered, lostPower() may still return true.  } // When time needs to be re-set on a previously configured device, the  // following line sets the RTC to the date \u0026amp; time this sketch was compiled  // rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));  // This line sets the RTC with an explicit date \u0026amp; time, for example to set  // January 21, 2014 at 3am you would call:  // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));  // When the RTC was stopped and stays connected to the battery, it has  // to be restarted by clearing the STOP bit. Let\u0026#39;s do this to ensure  // the RTC is running.  rtc.start(); rtc.writeSqwPinMode(PCF8523_OFF); // 低消費電力化  } void loop () { DateTime now = rtc.now(); Serial.print(now.year(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(now.month(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(now.day(), DEC); Serial.print(\u0026#34; (\u0026#34;); Serial.print(daysOfTheWeek[now.dayOfTheWeek()]); Serial.print(\u0026#34;) \u0026#34;); Serial.print(now.hour(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(now.minute(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(now.second(), DEC); Serial.println(); Serial.print(\u0026#34; since midnight 1/1/1970 = \u0026#34;); Serial.print(now.unixtime()); Serial.print(\u0026#34;s = \u0026#34;); Serial.print(now.unixtime() / 86400L); Serial.println(\u0026#34;d\u0026#34;); // calculate a date which is 7 days, 12 hours and 30 seconds into the future  DateTime future (now + TimeSpan(7,12,30,6)); Serial.print(\u0026#34; now + 7d + 12h + 30m + 6s: \u0026#34;); Serial.print(future.year(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(future.month(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(future.day(), DEC); Serial.print(\u0026#39; \u0026#39;); Serial.print(future.hour(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(future.minute(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(future.second(), DEC); Serial.println(); Serial.println(); delay(3000); } Setting the Time The compiled time is written. When the RTC is initialized due to power loss, etc., it will be initialized to the compiled time.\nExecution Results When you start the serial monitor, the time will be displayed. ","excerpt":"Overview The time will be displayed on the serial monitor of the PC.\nLeaf to use Use the following …","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/esp32/rtc/","title":"Real time clock"},{"body":"  \nFeatures This leaf has an AA battery holder and converts 1.5V battery voltage to 3.3V using a step-up power supply circuit and supplies 3.3V to each leaf. A switch for turning on/off the 3.3V is mounted. The AD converter for monitoring the battery voltage is mounted in this IC.\nSpecification Dimension    Item Description     Dimension  W23×D60×H24.2mm    Power Supply    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    AD Converter    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    Block diagram \nPinassign \nTips About the switch \n   Item Description     Switch Switch for turning on and off the 3.3v power    Sample App  Read Battery  Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D dawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Features This leaf has an AA battery holder and converts 1.5V battery voltage to 3.3V using a …","ref":"https://docs.leafony.com/en/docs/leaf/power/av03/","title":"AV03 AA BAT"},{"body":"Overview The information on the microSD card will be displayed on the serial monitor of the PC.\nLeaf to use    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AP02 ESP32 MCU 1   AZ02 RTC\u0026amp;microSD 1   AZ63 Nut Plate 1    M2*15mm screw 2    Assembly Source code  In the Arduino IDE, go to File -\u0026gt; Sketch Examples -\u0026gt; SD(esp32) -\u0026gt; SD_Test and write it to the microcontroller board.  /* * Connect the SD card to the following pins: * * SD Card | ESP32 * D2 - * D3 SS * CMD MOSI * VSS GND * VDD 3.3V * CLK SCK * VSS GND * D0 MISO * D1 - */ #include \u0026#34;FS.h\u0026#34;#include \u0026#34;SD.h\u0026#34;#include \u0026#34;SPI.h\u0026#34; void listDir(fs::FS \u0026amp;fs, const char * dirname, uint8_t levels){ Serial.printf(\u0026#34;Listing directory: %s\\n\u0026#34;, dirname); File root = fs.open(dirname); if(!root){ Serial.println(\u0026#34;Failed to open directory\u0026#34;); return; } if(!root.isDirectory()){ Serial.println(\u0026#34;Not a directory\u0026#34;); return; } File file = root.openNextFile(); while(file){ if(file.isDirectory()){ Serial.print(\u0026#34; DIR : \u0026#34;); Serial.println(file.name()); if(levels){ listDir(fs, file.name(), levels -1); } } else { Serial.print(\u0026#34; FILE: \u0026#34;); Serial.print(file.name()); Serial.print(\u0026#34; SIZE: \u0026#34;); Serial.println(file.size()); } file = root.openNextFile(); } } void createDir(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Creating Dir: %s\\n\u0026#34;, path); if(fs.mkdir(path)){ Serial.println(\u0026#34;Dir created\u0026#34;); } else { Serial.println(\u0026#34;mkdir failed\u0026#34;); } } void removeDir(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Removing Dir: %s\\n\u0026#34;, path); if(fs.rmdir(path)){ Serial.println(\u0026#34;Dir removed\u0026#34;); } else { Serial.println(\u0026#34;rmdir failed\u0026#34;); } } void readFile(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Reading file: %s\\n\u0026#34;, path); File file = fs.open(path); if(!file){ Serial.println(\u0026#34;Failed to open file for reading\u0026#34;); return; } Serial.print(\u0026#34;Read from file: \u0026#34;); while(file.available()){ Serial.write(file.read()); } file.close(); } void writeFile(fs::FS \u0026amp;fs, const char * path, const char * message){ Serial.printf(\u0026#34;Writing file: %s\\n\u0026#34;, path); File file = fs.open(path, FILE_WRITE); if(!file){ Serial.println(\u0026#34;Failed to open file for writing\u0026#34;); return; } if(file.print(message)){ Serial.println(\u0026#34;File written\u0026#34;); } else { Serial.println(\u0026#34;Write failed\u0026#34;); } file.close(); } void appendFile(fs::FS \u0026amp;fs, const char * path, const char * message){ Serial.printf(\u0026#34;Appending to file: %s\\n\u0026#34;, path); File file = fs.open(path, FILE_APPEND); if(!file){ Serial.println(\u0026#34;Failed to open file for appending\u0026#34;); return; } if(file.print(message)){ Serial.println(\u0026#34;Message appended\u0026#34;); } else { Serial.println(\u0026#34;Append failed\u0026#34;); } file.close(); } void renameFile(fs::FS \u0026amp;fs, const char * path1, const char * path2){ Serial.printf(\u0026#34;Renaming file %s to %s\\n\u0026#34;, path1, path2); if (fs.rename(path1, path2)) { Serial.println(\u0026#34;File renamed\u0026#34;); } else { Serial.println(\u0026#34;Rename failed\u0026#34;); } } void deleteFile(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Deleting file: %s\\n\u0026#34;, path); if(fs.remove(path)){ Serial.println(\u0026#34;File deleted\u0026#34;); } else { Serial.println(\u0026#34;Delete failed\u0026#34;); } } void testFileIO(fs::FS \u0026amp;fs, const char * path){ File file = fs.open(path); static uint8_t buf[512]; size_t len = 0; uint32_t start = millis(); uint32_t end = start; if(file){ len = file.size(); size_t flen = len; start = millis(); while(len){ size_t toRead = len; if(toRead \u0026gt; 512){ toRead = 512; } file.read(buf, toRead); len -= toRead; } end = millis() - start; Serial.printf(\u0026#34;%u bytes read for %u ms\\n\u0026#34;, flen, end); file.close(); } else { Serial.println(\u0026#34;Failed to open file for reading\u0026#34;); } file = fs.open(path, FILE_WRITE); if(!file){ Serial.println(\u0026#34;Failed to open file for writing\u0026#34;); return; } size_t i; start = millis(); for(i=0; i\u0026lt;2048; i++){ file.write(buf, 512); } end = millis() - start; Serial.printf(\u0026#34;%u bytes written for %u ms\\n\u0026#34;, 2048 * 512, end); file.close(); } void setup(){ Serial.begin(115200); if(!SD.begin()){ Serial.println(\u0026#34;Card Mount Failed\u0026#34;); return; } uint8_t cardType = SD.cardType(); if(cardType == CARD_NONE){ Serial.println(\u0026#34;No SD card attached\u0026#34;); return; } Serial.print(\u0026#34;SD Card Type: \u0026#34;); if(cardType == CARD_MMC){ Serial.println(\u0026#34;MMC\u0026#34;); } else if(cardType == CARD_SD){ Serial.println(\u0026#34;SDSC\u0026#34;); } else if(cardType == CARD_SDHC){ Serial.println(\u0026#34;SDHC\u0026#34;); } else { Serial.println(\u0026#34;UNKNOWN\u0026#34;); } uint64_t cardSize = SD.cardSize() / (1024 * 1024); Serial.printf(\u0026#34;SD Card Size: %lluMB\\n\u0026#34;, cardSize); listDir(SD, \u0026#34;/\u0026#34;, 0); createDir(SD, \u0026#34;/mydir\u0026#34;); listDir(SD, \u0026#34;/\u0026#34;, 0); removeDir(SD, \u0026#34;/mydir\u0026#34;); listDir(SD, \u0026#34;/\u0026#34;, 2); writeFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;Hello \u0026#34;); appendFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;World!\\n\u0026#34;); readFile(SD, \u0026#34;/hello.txt\u0026#34;); deleteFile(SD, \u0026#34;/foo.txt\u0026#34;); renameFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;/foo.txt\u0026#34;); readFile(SD, \u0026#34;/foo.txt\u0026#34;); testFileIO(SD, \u0026#34;/test.txt\u0026#34;); Serial.printf(\u0026#34;Total space: %lluMB\\n\u0026#34;, SD.totalBytes() / (1024 * 1024)); Serial.printf(\u0026#34;Used space: %lluMB\\n\u0026#34;, SD.usedBytes() / (1024 * 1024)); } void loop(){ } Execution Results The information on the microSD card will be displayed on the serial monitor of the PC.\n","excerpt":"Overview The information on the microSD card will be displayed on the serial monitor of the PC.\nLeaf …","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/esp32/microsd/","title":"micro SD"},{"body":"  \nFeatures The RTC is equipped with a JST SH connector, which converts 2 to 4.5V battery voltage to 3.3V with a step-up/down power supply circuit and supplies 3.3V to each leaf. A switch to turn on/off the 3.3V is mounted on the IC. It has an AD converter to monitor the battery voltage. The batteries that can be connected to the SH connector are assumed to be two or three dry batteries or Li-Po and Li-ION batteries.\nSpecification Dimension    Item Description     Dimension  W23×D21×H6.2mm    Power Supply    Item Description     Part number RP604K331B-TR   Battery voltage 1.8～5.5V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA (when step down)   Protection circuit Over current protection / Thermal shutdown    AD Converter    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    Block diagram \nPinassign \nTips Switches and Connectors \n   Item Description     Switch Switch for turning on and off the 3.3v power   Connector JST SH connector    Sample App  Read Battery  ドキュメント  Spec sheet Schematic Component marking (Front side) Component marking (reverse side) PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, January 2020  ","excerpt":"Features The RTC is equipped with a JST SH connector, which converts 2 to 4.5V battery voltage to …","ref":"https://docs.leafony.com/en/docs/leaf/power/av04/","title":"AV04A 2V～4.5V"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/basic/","title":"ESP32 Wi-Fi Kit + Basic Kit"},{"body":"Extension Leaf List\n","excerpt":"Extension Leaf List","ref":"https://docs.leafony.com/en/docs/leaf/extension/","title":"Extension"},{"body":"  \nFeatures An expansion board with an Arduino Shield connector, a SWD connector, an ICSP connector, and three leaf I/Fs mounted on it.\nSpecification    Item Description     Dimension  W59.2×D59.8×H11mm    Block diagram \nDocument  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"  \nFeatures An expansion board with an Arduino Shield connector, a SWD connector, an ICSP connector, …","ref":"https://docs.leafony.com/en/docs/leaf/extension/ax01/","title":"AX01 Shield"},{"body":"Overview This sample reads the value of the temperature and humidity sensor mounted on the 4-Sensors leaf and displays it on the serial monitor.\nLeaf to use Use the following leaf.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Thermo-hygrometer ESP32 // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/07/28 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // 2点補正用データ //--------------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  void setup() { // initialize serial communication at 115200 bit per second:  Serial.begin(115200); // I2C 初期化  pinMode(21, OUTPUT); // SDA  digitalWrite(21, 0); Wire.begin(); // I2C 100kHz  // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // 温度補正  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // 湿度補正  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } ESP32_Thermo-Hygrometer.ino\n2 point-to-point correction If there is a discrepancy between the temperature (or humidity) that you want to display and the temperature (or humidity) of the 4-Sensors, perform the correction between the two points. The following is a description of the correction method using temperature as an example.\nFirst, measure the temperatures of the two points with the 4-Sensors and a reference instrument. Then, write the measured values in the sample sketch and run it, and the temperature of the 4-Sensors will be close to the temperature you want to display.　Execution Results Open the serial monitor in the Arduino IDE and set the baud rate to 115200 bps to display the temperature and humidity.\n","excerpt":"Overview This sample reads the value of the temperature and humidity sensor mounted on the 4-Sensors …","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/basic/temp_humid_sensors/","title":"Temperature and humidity sensor"},{"body":"  \nFeatures This is a leaf with all 29 pins of the leaf I/F connected to a through-hole.\nSpecification    Item Description     Dimension  W23×D20.5×H4.7mm    Pinassign \nDocuments  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) PCBLayout(KiCad)1 PCBLayout(EAGLE)1 3D drawing  Revision history  Rev A1.0: First edition, August 2019    The data from KiCad and EAGLE, both of which are widely used by individuals, have been prepared by converting Zuken\u0026rsquo;s CAD data, so the possibility of conversion errors cannot be excluded. Please check the dimensions and other factors carefully before using the data. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Features This is a leaf with all 29 pins of the leaf I/F connected to a through-hole.\nSpecification …","ref":"https://docs.leafony.com/en/docs/leaf/extension/ax02/","title":"AX02 29 pin"},{"body":"Overview This sample reads the value of the illuminance sensor mounted on the 4-Sensors leaf and displays it on the serial monitor.\nLeaf to use Use the following leaf.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Illuminance meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\nExecution Results Open the serial monitor in the Arduino IDE and set the baud rate to 115200 bps, and you will see the illumination.\n","excerpt":"Overview This sample reads the value of the illuminance sensor mounted on the 4-Sensors leaf and …","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/basic/illum_sensor/","title":"Illum sensor"},{"body":"  \nFeatures Leaf for connecting all the leaf I/F terminals to the side.\nSpecification    Item Description     Dimension  W50×D20.5×H4.7mm    Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  ","excerpt":"  \nFeatures Leaf for connecting all the leaf I/F terminals to the side.\nSpecification    Item …","ref":"https://docs.leafony.com/en/docs/leaf/extension/ax03/","title":"AX03 Leaf x2"},{"body":"Overview This sample reads the value of the accelerometer mounted on the 4-Sensors leaf and displays it on the serial monitor.\nLeaf to use Use the following leaf.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Accelerometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\nExecution Results Open the serial monitor in the Arduino IDE and set the baud rate to 115200 bps to display the acceleration and tilt.\n","excerpt":"Overview This sample reads the value of the accelerometer mounted on the 4-Sensors leaf and displays …","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/basic/accelerometer/","title":"Accelerometer"},{"body":"  \nFeatures A spacer leaf that is placed between two stacked leaves. It can be used when parts of the leafs interfere with each other.\nSpecification    Item Description     Dimension  W23×D6×H4.7mm    Document  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  ","excerpt":"  \nFeatures A spacer leaf that is placed between two stacked leaves. It can be used when parts of …","ref":"https://docs.leafony.com/en/docs/leaf/extension/ax04/","title":"AX04 Spacer"},{"body":"  \nFeatures This leaf can measure the current consumption of 3.3V and VBUS. In the current measurement leaf, the pads on the front and back sides of the 3.3V and VBUS are electrically separated, so by connecting an ammeter to each of the following through holes, the total power supply current of a single leaf or a group of leaves located far from the battery leaf can be measured. In the example below, the sensor leaf and the BLE leaf are located on the far side of the battery leaf via the current measurement leaf, so the total current of both leaves can be measured.\nSpecification    Item Description     Dimension  W23×D20.5×H4.7mm    Document  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  ","excerpt":"Features This leaf can measure the current consumption of 3.3V and VBUS. In the current measurement …","ref":"https://docs.leafony.com/en/docs/leaf/extension/ax05/","title":"AX05 I Meas"},{"body":"  \nFeatures Seeed Studio Grove series compliant leafs that operate at 5 V with UART, I2C, analog and digital inputs. 3.3 V to 5 V is converted to 5 V by a step-up power supply circuit and supplied to the Grove. It is possible to turn off the 5V power supply by controlling the I2C Expander to achieve low power consumption.\nSpecification Dimension    Item Description     Dimension  W33.8×D24.7×H4.7mm    Power Supply    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 5V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1B)    Block diagram \nPinassign \nTips About UART, I2C, Analog and Digital \n   Item Description     UART For UART communication   I2C For I2C communication   Analog Analog Signal Inputs   Digital Digital Signal Inputs    Sample App  Distance Sensor Camera  Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  ","excerpt":"Features Seeed Studio Grove series compliant leafs that operate at 5 V with UART, I2C, analog and …","ref":"https://docs.leafony.com/en/docs/leaf/extension/ax06/","title":"AX06 Grove\u00265V"},{"body":"  \nFeatures This leaf is used to invert the leaf with all the leaf I/F terminals connected to it.\nSpecification    Item Description     Dimension  W29×D17×H4.7mm     Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, January 2020  ","excerpt":"  \nFeatures This leaf is used to invert the leaf with all the leaf I/F terminals connected to it. …","ref":"https://docs.leafony.com/en/docs/leaf/extension/ax07/","title":"AX07 Back to back"},{"body":"  \nFeatures This is a leaf with all 29 pins of the leaf I/F connected to the pin headers.\nSpecification    Item Description     Dimension  W30×D20.5×H10.6mm     Pinassign \nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, January 2020  ","excerpt":"  \nFeatures This is a leaf with all 29 pins of the leaf I/F connected to the pin headers. …","ref":"https://docs.leafony.com/en/docs/leaf/extension/ax08/","title":"AX08 29pin header"},{"body":"Overview An example of using Seeed Studio\u0026rsquo;s Grove series of sensors. The distance measured by the ultrasonic sensor is displayed on the LCD. Ultrasonic sensors are usually input to digital pins, but since LCD\u0026rsquo;s Switch1 and Grove\u0026amp;5V\u0026rsquo;s Din1 use the same pins, they are connected to UART pins and UART pins are used as digital pins.\n  Leaf to use    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI04 LCD 1   AX04 Spacer 1   AX06 Grove\u0026amp;5V 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    Grove – Ultrasonic Distance Sensor 1    CR2032 coin cell battery 1    M2*18mm screw 2    Assembly Assemble the leaves as shown in the figure below.\nSource code  The LCD library and ultrasonic control library \u0026ldquo;Ultrasonic.h\u0026rdquo; are required for writing. Please include them beforehand. For more information, see here. Write the following program in the Arduino IDE.  //===================================================================== // Leafony Platform sample sketch // Platform : Grove + Ultrasonic // Processor : ATmega328P (3.3V /8MHz) // Application : Ultrasonic Ranger demo // // Leaf configuration // (1) AI04 LCD // (2) AP01 AVR MCU // (3) AX01 Grove\u0026amp;5V + Grove - Ultrasonic Ranger (UART pinに接続) // ※ Ultrasonic RangerはGrove\u0026amp;5VのUARTに接続する // (4) AZ01 USB // //\t(c) 2019 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //Grove - Ultrasonic Rangerを使用したデモ //LCDに超音波センサーから取得した対象物からの距離を表示 //===================================================================== //use libraries //ST7032 - Arduino LiquidCrystal compatible library //https://github.com/tomozh/arduino_ST7032 //Grove_Ultrasonic_Ranger //https://github.com/Seeed-Studio/Grove_Ultrasonic_Ranger/ //=====================================================================  #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ST7032.h\u0026gt; // LCD ST7032 lcd; char strMessage[8]; #include \u0026#34;Ultrasonic.h\u0026#34;Ultrasonic ultrasonic(A1); void setup() { Serial.begin(115200); //LCD Initialize  lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(1000); lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(500); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++) { lcd.setCursor(i, 0); delay(100); } for (i=0 ; i\u0026lt;8 ;i++) { lcd.setCursor(i, 1); delay(100); } lcd.noBlink(); } void loop() { long RangeInCentimeters; lcd.clear(); lcd.print(\u0026#34;Distance\u0026#34;); RangeInCentimeters = ultrasonic.MeasureInCentimeters(); sprintf(strMessage,\u0026#34;%5d cm\u0026#34;,RangeInCentimeters); lcd.setCursor(0, 1); lcd.print(strMessage); delay(250); } Grove-Ultrasonic_LCD.ino\n","excerpt":"Overview An example of using Seeed Studio\u0026rsquo;s Grove series of sensors. The distance measured by …","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/exten/distance_sensor/","title":"Distance sensor"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/exten/","title":"ESP32 Wi-Fi Kit + Extension Kit"},{"body":"\nFeatures The Leafony Platform is based on ACRs (Anisotropic Conductive Rubber), which is an insulating silicone rubber with metal or conductive elastomeric conductive elements arranged at a narrow pitch, which can be compressed to create an electrical connection.\nTips Installing and removing connectors Attach or remove the connector to the leaf board as shown below.\n\u0026ndash; Installation\n\u0026ndash; Dismantling\nDocument  Connector test results 3D drawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Features The Leafony Platform is based on ACRs (Anisotropic Conductive Rubber), which is an …","ref":"https://docs.leafony.com/en/docs/leaf/others/az61/","title":"AZ61 Connector"},{"body":"Other Leaves\u0026rsquo;List\n","excerpt":"Other Leaves\u0026rsquo;List","ref":"https://docs.leafony.com/en/docs/leaf/others/","title":"Others"},{"body":"  \nFeatures A leaf to connect when writing a sketch to an AVR MCU or using a serial monitor. FTDI\u0026rsquo;s FT232RQ is mounted as a USB-UART conversion IC. It converts from USB VBUS (5V) to 3.3V with a step-down power supply circuit and supplies VBUS and 3.3V to each leaf.\nSpecification Dimension    Item Description     Dimension  W23×D20.9×H4.7mm    USB-UART conversion    Item Description     Part Number FT232RQ   USB USB 2.0 Full Speed   Data transfer rates 300 baud to 3 Mbaud    Power Supply    Item Description     Part number XCL222B331ER-G   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 500mA   Protection circuit Over current protection / thermal shutdown/short-circuit protection    Block diagram \nPinassign \nTips About micro USB and LED \n   Item Description     micro USB It is used for writing a sketch to the MCU and serial monitoring by connecting a PC.This also converts USB’s VBUS(5V) to 3.3V by using step-down power circuit and provide VBUS and 3.3V to each leaf.   LED TX LED which controlled by FT232RQ. Blinks when program is written by UART TX communication.   LED RX LED which controlled by FT232RQ. Blinks when program is written by UART TX communication.    Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"Features A leaf to connect when writing a sketch to an AVR MCU or using a serial monitor. …","ref":"https://docs.leafony.com/en/docs/leaf/others/az01/","title":"AZ01 USB"},{"body":"Overview An example of using Seeed Studio\u0026rsquo;s Grove series sensors. Let\u0026rsquo;s try to save an image taken by the camera once a minute to a microSD card.   Leaf to use    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ02 RTC\u0026amp;microSD 1   AX04 Spacer 1   AX06 Grove\u0026amp;5V 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    Grove-Serial Camera Kit 1    microSD card  1    M2*18mm screw 2    Assembly Source code  4-Sensors and AVR MCU library (timer interrupt) are required for writing. Please include the library beforehand. For details, see here. Write the following program in the Arduino IDE.  //===================================================================== // Leafony Platform sample sketch // Platform : Grove + Camera // Processor : ATmega328P (3.3V /8MHz) // Application : Camera // // Leaf configuration // (1) AP01 AVR MCU // (2) AX01 Grove\u0026amp;5V + Grove Serial Camera Kit // (3) AZ01 USB // (4) AZ02 RTC＆MicroSD // //\t(c) 2019 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //use libraries //=====================================================================  //===================================================================== // difinition //===================================================================== #include \u0026lt;MsTimer2.h\u0026gt;#include \u0026lt;SPI.h\u0026gt;#include \u0026lt;SD.h\u0026gt;#include \u0026lt;SoftwareSerial.h\u0026gt;#include \u0026lt;avr/wdt.h\u0026gt;#include \u0026lt;avr/sleep.h\u0026gt;#include \u0026lt;avr/power.h\u0026gt;//=====================================================================  #define DEBUG  //===================================================================== // SPI CLOCK // SDカードのSPI I/Fのクロック速度4Mでは動作しないので4M以下に設定すること //===================================================================== #define SD_CLCK 2500000  //===================================================================== // 撮影間隔（秒） // //===================================================================== #define SNAP_WAIT 60  //===================================================================== // IOピンの名前定義 // 接続するリーフに合わせて定義する //===================================================================== // -------------------------------------------- // PD port // digital 0: PD0 = PCRX (HW UART) // digital 1: PD1 = PCTX (HW UART) // digital 2: PD2 = INT0# // digital 3: PD3 = INT1# // digital 4: PD4 = RSV // digital 5: PD5 = RSV // digital 6: PD6 = RSV // digital 7: PD7 = RSV // -------------------------------------------- #define PCTX 0 #define PCRX 1 #define INT0 2 #define INT1 3 #define RSV_D4 4 #define RSV_D5 5 #define SD_EN 6 #define RSV_D7 7  // -------------------------------------------- // PB port // digital 8: PB0 = UART2_RX (software UART) /* not use */ // digital 9: PB1 = UART2_TX (software UART) /* not use */ // digital 10:PB2 = CS# // digital 11:PB3 = MOSI // digital 12:PB4 = MISO // digital 13:PB5 = SCK (AVR LED) // PB6 = XTAL1 // PB7 = XTAL2 //--------------------------------------------- #define UART2_RX 8 #define UART2_TX 9 #define SD_CS 10 #define MOSI 11 #define MISO 12 #define LED_PIN 13  // -------------------------------------------- // PC port // digital 14/ Analog0: PC0 = RSV // digital 15/ Analog1: PC1 = CAMERA TX (software UART) // digital 16/ Analog2: PC2 = CAMERA RX (software UART) // digital 17/ Analog3: PC3 = RSV // digital 18/ SDA : PC4 = SDA (I2C) // digital 19/ SCL : PC5 = SCL (I2C) // RESET : PC6 = RESET# //----------------------------------------------- #define RSV_D14 14 #define UART3_TX 15 #define UART3_RX 16 #define RSV_D17 17 #define SDA 18 #define SCL 19 //=====================================================================  //===================================================================== // camera //===================================================================== //Color Setting #define COLOR_2BIT_GRAY 0x01 #define COLOR_4BIT_GRAY 0x02 #define COLOR_8BIT_GRAY 0x03 #define COLOR_2BIT_COLOR 0x05 #define COLOR_4BIT_COLOR 0x06 #define COLOR_JPEG 0x07 //Preview Resolution #define PRE_RES_80_60 0x01 #define PRE_RES_160_120 0x03 //JPEG Resolution #define JPEG_RES_80_60 0x01 #define JPEG_RES_QQVGA 0x03 #define JPEG_RES_QVGA 0x05 #define JPEG_RES_VGA 0x07 //Get Setting #define GET_SNAPCHOT 0x01 #define GET_PRE_PIC 0x02 #define GET_PRE_JPEG 0x03 //Snapshot Setting #define COMPRESSED 0x00 #define UNCOMPRESSED 0x01 //data length #define PIC_PKT_LEN 128  //===================================================================== // SD //===================================================================== File myFile; SoftwareSerial CameraSerial(UART3_RX, UART3_TX); //===================================================================== // 変数定義 //===================================================================== unsigned long picTotalLen = 0; // picture length int picNameNum = 0; char fname[16]; //--------------------------- // interval Timer2 interrupt //--------------------------- volatile bool bInterval = false; volatile int intcnt = 0; //===================================================================== // setup //===================================================================== //----------------------------------------------- // port //----------------------------------------------- //===================================================================== // IOピンの入出力設定 // 接続するリーフに合わせて設定する //===================================================================== void setupPort(){ //---------------------  // PD port  //---------------------  // PD0 : digital 0 = RX  // PD1 : digital 1 = TX  pinMode(INT0, INPUT); // PD2 : digital 2 = INT0#  pinMode(INT1, INPUT); // PD3 : digital 3 = INT1#  pinMode(RSV_D4, OUTPUT); // PD4 : digital 4 = LED  digitalWrite(RSV_D4, LOW); pinMode(RSV_D5, OUTPUT); // PD5 : digital 5 = not used  digitalWrite(RSV_D5, LOW); pinMode(SD_EN, OUTPUT); // PD6 : digital 6 = BLE reset active-low  digitalWrite(SD_EN, HIGH); pinMode(RSV_D7, OUTPUT); // PD7 : digital 7 = BLE sleep  digitalWrite(RSV_D7, HIGH); //---------------------  // PB port  //---------------------  pinMode(UART2_RX, OUTPUT); // PB0 : digital 8 = software UART2  digitalWrite(UART2_RX, LOW); pinMode(UART2_TX, OUTPUT); // PB1 : digital 9 = software UART2  digitalWrite(UART2_TX, LOW); //---------------------  // PC port  //---------------------  pinMode(RSV_D14, OUTPUT); // PC0 : digital 14 = not used  digitalWrite(RSV_D14, LOW); // PC1 : digital 15 = Camera RX  // PC2 : digital 16 = Camera TX  pinMode(RSV_D17, OUTPUT); // PC3 : digital 17 = not used  digitalWrite(RSV_D17, LOW); // PC4 : digital 18 = I2C SDA  // PC5 : digital 19 = I2C SCL } //===================================================================== // 割り込み処理 // //===================================================================== //----------------------------------------------- // timer2 interrupt (interval=1000ms, int=overflow) // メインループのタイマー割り込み設定 //----------------------------------------------- void setupTC2Int(){ MsTimer2::set(1000, intTimer2);} //---------------------------------------------- // Timer2 INT // タイマー割り込み関数 //---------------------------------------------- void intTimer2(){ intcnt++; if (intcnt \u0026gt; SNAP_WAIT) { intcnt = 0; bInterval = true; } } //==================================================================== // camera //==================================================================== //---------------------------------------------- // clearReadBuf // カメラデータの受信バッファクリア //---------------------------------------------- void clearReadBuf() { while (CameraSerial.available()) { CameraSerial.read(); } } //---------------------------------------------- // sendCmd // カメラへのコマンド送信 //---------------------------------------------- void sendCmd(char cmd[], int cmd_len) { for (char i = 0; i \u0026lt; cmd_len; i++) CameraSerial.write(cmd[i]); } //---------------------------------------------- // readRespons // カメラからのデータ受信 //---------------------------------------------- int readRespons(char *dest, int len, unsigned int timeout) { int read_len = 0; unsigned long t = millis(); while (read_len \u0026lt; len) { while (CameraSerial.available()\u0026lt;1) { if ((millis() - t) \u0026gt; timeout) { //Serial.println(\u0026#34;timeout\u0026#34;);  return read_len; } } *(dest+read_len) = CameraSerial.read(); #ifdef DEBUG  //Serial.write(*(dest+read_len),); //debug #endif  read_len++; } return read_len; } //---------------------------------------------- // initialize // カメラとの通信確立 //---------------------------------------------- void initialize() { char cmd[] = {0xaa,0x0d,0x00,0x00,0x00,0x00} ; unsigned char resp[6]; Serial.print(\u0026#34;initializing camera...\u0026#34;); while (1) { sendCmd(cmd,6); if (readRespons((char *)resp, 6,1000) != 6) { Serial.print(\u0026#34;.\u0026#34;); continue; } if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x0d \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) { if (readRespons((char *)resp, 6, 500) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0d \u0026amp;\u0026amp; resp[2] == 0 \u0026amp;\u0026amp; resp[3] == 0 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } } cmd[1] = 0x0e; cmd[2] = 0x0d; sendCmd(cmd, 6); Serial.println(\u0026#34; done.\\r\\n\u0026#34;); } //---------------------------------------------- // preCapture // カメラの初期設定 //---------------------------------------------- void preCapture() { char cmd[] = { 0xaa, 0x01, 0x00, COLOR_JPEG, PRE_RES_80_60, JPEG_RES_VGA }; unsigned char resp[6]; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x01 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } } //---------------------------------------------- // Capture // カメラの撮影実施 //---------------------------------------------- void Capture() { char cmd[] = { 0xaa, 0x06 , 0x08, PIC_PKT_LEN \u0026amp; 0xff, (PIC_PKT_LEN\u0026gt;\u0026gt;8) \u0026amp; 0xff ,0}; unsigned char resp[6]; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x06 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } cmd[1] = 0x05; cmd[2] = 0; cmd[3] = 0; cmd[4] = 0; cmd[5] = 0; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x05 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } cmd[1] = 0x04; cmd[2] = GET_SNAPCHOT; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x04 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) { if (readRespons((char *)resp, 6, 1000) != 6) { continue; } if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0a \u0026amp;\u0026amp; resp[2] == 0x01) { picTotalLen = (resp[3]) | (resp[4] \u0026lt;\u0026lt; 8) | (resp[5] \u0026lt;\u0026lt; 16); //Serial.print(\u0026#34;picTotalLen:\u0026#34;);  //Serial.println(picTotalLen);  break; } } } } //---------------------------------------------- // GetData // カメラからデータを取得しSDに書き込む //---------------------------------------------- void GetData() { char cmd[] = { 0xaa, 0x0e , 0x00, 0x00, 0x00, 0x00 }; unsigned char pkt[PIC_PKT_LEN]; unsigned int pktCnt = (picTotalLen) / (PIC_PKT_LEN - 6); if ((picTotalLen % (PIC_PKT_LEN-6)) != 0) pktCnt += 1; set_filename(); if (SD.exists(fname)) { SD.remove(fname); } myFile = SD.open(fname, FILE_WRITE); if(!myFile){ Serial.println(\u0026#34;myFile open fail...\u0026#34;); } else{ Serial.print(\u0026#34;Saving \u0026#34;);Serial.print(fname); Serial.print(\u0026#34;..... \u0026#34;); for (unsigned int i = 0; i \u0026lt; pktCnt; i++) { cmd[4] = i \u0026amp; 0xff; cmd[5] = (i \u0026gt;\u0026gt; 8) \u0026amp; 0xff; int retry_cnt = 0; retry: delay(10); clearReadBuf(); sendCmd(cmd, 6); uint16_t cnt = readRespons((char *)pkt, PIC_PKT_LEN, 200); unsigned char sum = 0; for (int y = 0; y \u0026lt; cnt - 2; y++) { sum += pkt[y]; } if (sum != pkt[cnt-2]) { if (++retry_cnt \u0026lt; 100) goto retry; else break; } myFile.write((const uint8_t *)\u0026amp;pkt[4], cnt-6); //if (cnt != PIC_PKT_LEN) break;  } cmd[4] = 0xf0; cmd[5] = 0xf0; sendCmd(cmd, 6); } myFile.close(); Serial.println(\u0026#34;end!!\u0026#34;); } //---------------------------------------------- // set_filename // SDに書き込みファイ名を作成IMGxxxx.JPG //---------------------------------------------- void set_filename(){ sprintf(fname, \u0026#34;IMG%04d.JPG\u0026#34;, picNameNum); picNameNum ++; if( picNameNum \u0026gt; 100 ){ picNameNum = 0; // Overwrite  } } //==================================================================== // setup //==================================================================== void setup() { //WDT disable  wdt_disable(); //内部の各モジュールの電源OFF  //power_all_disable();  //power_timer0_enable();  //power_timer2_enable();  //power_spi_enable();  //power_usart0_enable();  delay(10); Serial.begin(115200); CameraSerial.begin(9600); #ifdef DEBUG  Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;setup start\u0026#34;); #endif  setupPort(); delay(10); setupTC2Int(); if (!SD.begin(SD_CLCK,SD_CS)) { Serial.print(\u0026#34;sd init failed\u0026#34;); return; } Serial.print(\u0026#34;sd init finish\\r\\n\u0026#34;); initialize(); delay(1); preCapture(); delay(1000); Capture(); GetData(); MsTimer2::start(); } //==================================================================== // loop //==================================================================== void loop() { if (bInterval == true) { bInterval = false; Capture(); GetData(); } } Grove-Camera_microSD.ino\n","excerpt":"Overview An example of using Seeed Studio\u0026rsquo;s Grove series sensors. Let\u0026rsquo;s try to save an …","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/exten/camera/","title":"Camera"},{"body":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI02 SP\u0026amp;PIR 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n#define LEDC_CHANNEL_0 0 // use first channel of 16 channels (started from zero) #define LEDC_TIMER_13_BIT 13 // use 13 bit precission for LEDC timer #define LEDC_BASE_FREQ 5000 // use 5000 Hz as a LEDC base frequency  //------------------------------ // buzzer output = 13pin //------------------------------ #define BUZZER_OUT 13  const int NOTE_NONE = NOTE_MAX; // notes in the melody: int melody[] = { NOTE_C, NOTE_C, NOTE_G, NOTE_G, NOTE_A, NOTE_A, NOTE_G, NOTE_F, NOTE_F, NOTE_E, NOTE_E,NOTE_D,NOTE_D,NOTE_C }; int noteOctaves[] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }; // note durations: 4 = quarter note, 8 = eighth note, etc.: int noteDurations[] = { 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 2 }; //===================================================================== // setup //===================================================================== void setup() { ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); ledcAttachPin(BUZZER_OUT, LEDC_CHANNEL_0); // iterate over the notes of the melody:  for (int thisNote = 0; thisNote \u0026lt; 14; thisNote++) { // to calculate the note duration, take one second divided by the note type.  //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.  ledcWriteNote(LEDC_CHANNEL_0, (note_t)melody[thisNote], noteOctaves[thisNote]); // to distinguish the notes, set a minimum time between them.  // the note\u0026#39;s duration + 30% seems to work well:  int pauseBetweenNotes = 1000 / noteDurations[thisNote] * 1.30; delay(pauseBetweenNotes); // stop the tone playing:  ledcWriteTone(LEDC_CHANNEL_0, 0); delay(30); } } //===================================================================== // Main loop //===================================================================== void loop() { // no need to repeat the melody. } ESP32_toneMelody_Twinkle.ino\nExecution Results The melody sounds only once from the speakers.\n","excerpt":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to …","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/exten/speaker/","title":"Speaker"},{"body":"\nFeatures The Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris.\nDimension \nDocument  3D drawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"\nFeatures The Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris. …","ref":"https://docs.leafony.com/en/docs/leaf/others/az62/","title":"AZ62 Connector Cover"},{"body":"  \nFeatures This leaf is equipped with NXP\u0026rsquo;s Real-Time Clock PCF8523TK and a microSD card slot. The RTC can output interrupts to the MCU with alarms and timers, while the microSD card is accessible via SPI.\nSpecification    Item Description     Part number PCF8523TK   Type Real-Time Clock (RTC) and calendar   Interrupt Alarm and timer   Quartz crystal unit FC-12M 32.768000kHz 7.0 +20.0-20.0   Interfaces I2C(Address: 0x68)   Dimension W23×D20.5×H4.7mm     Block diagram \nPinassign \nSample App  Real Time Clock microSD Card Camera  Library Libraries are available for this leaf. Please install and use the necessary libraries at Environment.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, January 2020  ","excerpt":"Features This leaf is equipped with NXP\u0026rsquo;s Real-Time Clock PCF8523TK and a microSD card slot. …","ref":"https://docs.leafony.com/en/docs/leaf/others/az02/","title":"AZ02 RTC\u0026microSD"},{"body":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR Leaf, let\u0026rsquo;s create a system that makes a sound when a person approaches.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI02 SP\u0026amp;PIR 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n For beep sound  //===================================================================== // Leafony Platform sample sketch // Application : Human_Sensing (Beep) // Processor : ESP32-WROOM-32 (ESP32 Dev Module) // Arduino IDE : 1.8.13 // Arduino ESP32: 1.0.4 // // Leaf configuration // (1) AI02 SP\u0026amp;PIR // (2) AP02 ESP32 MCU // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2020/08/20 First release //===================================================================== //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C //----------------------------------------------- // IOピン一覧 //----------------------------------------------- // D0 IO3 (RXD) // D1 IO1 (TXD) // D2 IO4 (INT0) // D3 IO27 (INT1) // D4 IO12 (H-MISO) // D5 IO13 (H-MOSI) // D6 IO14 (H-SCK) // D7 IO15 (H-SS) // D8 IO17 (UART_TX) // D9 IO16 (UART_RX) // D10 IO5 (SS) // D11 IO23 (MOSI) // D12 IO19 (MISO) // D13 IO18 (SCK) // D14 IO21 (SDA) // D15 IO22 (SCL) // A0 IO36 // A1 IO25 (UART_TX) // A2 IO26 (UART_RX) // A3 IO39 // A4 IO34 // A5 IO35  //----------------------------------------------- // IOピンの名前定義 // 接続するリーフに合わせて定義する //----------------------------------------------- #define PIR_INT 4 // D2 IO4 #define BUZZER_OUT 13 // D5 IO13 buzzer output  //------------------------------ // Tone設定 //------------------------------ #define LEDC_CHANNEL_0 0 // use first channel of 16 channels (started from zero) #define LEDC_TIMER_13_BIT 13 // use 13 bit precission for LEDC timer #define LEDC_BASE_FREQ 5000 // use 5000 Hz as a LEDC base frequency  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; volatile int HumanDetected = 0; //===================================================================== // setup //===================================================================== void setup(){ // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication:  Wire.begin(); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); // Beep  ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); ledcAttachPin(BUZZER_OUT, LEDC_CHANNEL_0); // 人接近検知割り込み  attachInterrupt(PIR_INT,onHumanDetected , FALLING ); } //--------------------------------------------------------------------- // 割り込み設定 //--------------------------------------------------------------------- //---------------------------------------------- // 人を検出したら呼び出される関数 //---------------------------------------------- void onHumanDetected(){ HumanDetected = 1; } //===================================================================== // Main loop //===================================================================== void loop(){ // レジスタ読み出し  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); // IRセンサ  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); // センサ温度  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); if (HumanDetected == 1){ // 人の接近を検知  Serial.println(\u0026#34;Detect!\u0026#34;); // Beep  ledcWriteNote(LEDC_CHANNEL_0, NOTE_C, 5); int pauseBetweenNotes = 1000 / 4 * 1.30; delay(pauseBetweenNotes); // stop the tone  ledcWriteTone(LEDC_CHANNEL_0, 0); HumanDetected = 0; } delay(1000); } //===================================================================== double clacTemp(){ double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000){ val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else{ ret = (double)val * 0.0019837; } return ret + 25; } //===================================================================== double clacIR(){ double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ((val \u0026amp; 0x8000) == 0x8000){ val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else{ ret = (double)(val * 0.4578 ); } return ret; } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- // I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- // I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } //----------------------------------------------- // I2C スレーブデバイスに複数バイト書き込む //----------------------------------------------- void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } //----------------------------------------------- // I2C スレーブデバイスから複数バイト読み込む //----------------------------------------------- void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } ESP32_Human_Sensing.ino\nExecution Results It makes a sound when someone approaches.\n","excerpt":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR …","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/exten/ir_sensor/","title":"IR sensor"},{"body":"\nFeatures The Nut Plate is used to fix the leaf with a screw. Be careful not to use commercially available hex nuts as they may cause a short circuit by touching the electrodes on the board.\nDimnnsion \nDocument  3D drawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"\nFeatures The Nut Plate is used to fix the leaf with a screw. Be careful not to use commercially …","ref":"https://docs.leafony.com/en/docs/leaf/others/az63/","title":"AZ63 Nut Plate"},{"body":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of rotation. You can also turn on the number of LEDs according to the ambient volume with the microphone.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI03 MIC\u0026amp;VR\u0026amp;LED 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n//===================================================================== // ESP32 Sound level meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/08/20 First release //=====================================================================  // LED4-6:VRのレベル表示 // LED1-3:MICの音圧レベル表示  #define LED1 14 // D6 IO14 #define LED2 15 // D7 IO15 #define LED3 17 // D8 IO17 #define LED4 16 // D9 IO16 #define LED5 5 // D10 IO5 #define LED6 23 // D11 IO23 #define MIC 26 // A2 IO26 #define VR 39 // A3 IO39  unsigned int dataVR; unsigned int dataMic; //----------------------------------------------- // VRとMICデータを取得する //----------------------------------------------- void getSensorData(){ dataVR = analogRead(VR); dataMic = analogRead(MIC); Serial.println(\u0026#34;---------------------\u0026#34;); Serial.print(\u0026#34;MIC = \u0026#34;); Serial.println(dataMic,DEC); Serial.print(\u0026#34;VR = \u0026#34;); Serial.println(dataVR,DEC); } //----------------------------------------------- // VRとMICの値にあわせてLEDを点灯、消灯させる //----------------------------------------------- void dispSensorData(){ if (dataVR \u0026lt; 1500){ digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 1500 \u0026amp;\u0026amp; dataVR \u0026lt; 2600){ digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 2600 \u0026amp;\u0026amp; dataVR \u0026lt; 3600){ digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else{ digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; 400){ digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= 400 \u0026amp;\u0026amp; dataMic \u0026lt; 600){ digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= 600 \u0026amp;\u0026amp; dataMic \u0026lt; 950){ digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else{ digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup(){ Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); //起動テスト(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); } void loop() { getSensorData(); dispSensorData(); delay(100); } ESP32_Sound_Level_Meter.ino\nExecution Results When the volume is rotated, a number of LEDs will light up according to the amount of rotation. When the microphone is turned on, a number of LEDs will light up according to the ambient volume.\n","excerpt":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of …","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/exten/sound_level/","title":"Sound level meter"},{"body":"\nFeatures This is a case for the Basic Kit. It can be fixed to the wall with the magnets on the bottom.\nDimnnsion \nDocument  3D drawing  Revision history  Rev A1.0: First edition, August 2019  ","excerpt":"\nFeatures This is a case for the Basic Kit. It can be fixed to the wall with the magnets on the …","ref":"https://docs.leafony.com/en/docs/leaf/others/az66/","title":"AZ66 Basic kit case"},{"body":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt also comes with two button switches and can be used as a controller.\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI04 LCD 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : ESP32-WROOM-32 (ESP32 Dev Module) // Arduino IDE : 1.8.13 // Arduino ESP32: 1.0.4 // // Leaf configuration // (1) AI04 LCD // (2) AP02 ESP32 MCU // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2020/08/20 First release //===================================================================== //use libraries //ST7032 - Arduino LiquidCrystal compatible library //https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IOピン一覧 //----------------------------------------------- // D0 IO3 (RXD) // D1 IO1 (TXD) // D2 IO4 (INT0) // D3 IO27 (INT1) // D4 IO12 (H-MISO) // D5 IO13 (H-MOSI) // D6 IO14 (H-SCK) // D7 IO15 (H-SS) // D8 IO17 (UART_TX) // D9 IO16 (UART_RX) // D10 IO5 (SS) // D11 IO23 (MOSI) // D12 IO19 (MISO) // D13 IO18 (SCK) // D14 IO21 (SDA) // D15 IO22 (SCL) // A0 IO36 // A1 IO25 (UART_TX) // A2 IO26 (UART_RX) // A3 IO39 // A4 IO34 // A5 IO35  //----------------------------------------------- // IOピンの名前定義 // 接続するリーフに合わせて定義する //----------------------------------------------- #define SW1 4 // D2 IO4  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8文字, 2行  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8文字, 2行  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop() { char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- //I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } ESP32_LCD-SW_test.ino\nExecution Results On the LCD the screens are displayed in the following order\n The \u0026ldquo;Hello\u0026rdquo; string Moving the cursor Button input status display  ","excerpt":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt …","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/exten/lcd/","title":"LCD"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/basic/","title":"Basic Kit"},{"body":"in progress\nOverview Minimum configuration project for creating a Beacon.\nWhat to prepare Sample application code Leafony Configuration    Type Name Q\u0026rsquo;ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Assembly ","excerpt":"in progress\nOverview Minimum configuration project for creating a Beacon.\nWhat to prepare Sample …","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/basic/simple_ble_advertising/","title":"Simple BLE Advertising"},{"body":"This sample is the same as the one introduced in Basic Kit Getting Started Guide. Let\u0026rsquo;s read the source code to understand how it works.\nIntroduction Leafony is designed to make it easy to develop small, power-saving IoT devices, and each leaf is designed to save power. Since it runs on battery for a long time, it can be placed in various locations to perform fixed-point observations with sensors.\nSo how can data such as temperature, humidity, and illumination measured by sensors be collected? In general, wireless communication such as Wi-Fi, Bluetooth, and LoRa is used. Leafony has a leaf equipped with Bluetooth, one of the most power-efficient wireless communication standards.\nThe Basic Kit is a kit that makes it easy to develop long battery-powered IoT sensors using the 4-Sensor Leaf, which is equipped with multiple power-saving sensors, and the BLE Leaf, which is equipped with Bluetooth LE (hereinafter referred to as BLE), a power-saving Bluetooth standard.\nSo what do we need to do in order to receive the BLE sent by Leafony? There are many different environments for PCs, smartphones, and tablets: PCs running Windows, PCs running MacOS, Android, iPhone, and so on. In order to use Bluetooth in these environments, it is normal to develop in a programming language tailored to each environment. For PC, you can develop using languages such as C and Python, but for Android and iPhone, you need to use Android Studio, Xcode, etc. to create software in yet another programming language.\nHow can we easily develop something that is used by many people in many different environments? In this sample application, one way to do this is to use a web browser to communicate via Bluetooth and display the data on the screen.\nThe languages used are HTML and Java Script. A program written in these two languages will work equally well in any environment on a web browser.\nPoints  The Web Bluetooth library allows you to write software for Bluetooth connection in a web application. If it is a web application, the same source code will work on any device that runs a browser. GUIs such as tables and graphs can be easily developed using HTML and CSS.   What to prepare  Leafony Basic Kit Windows1, Mac2, or Linux3 PC (for development) Android4, iPhone5, iPad5 smartphone or tablet (does not have to be for testing) Google Chrome (Version 70.0.3526.0 or later) Arduino IDE  Sample app source code Please download both in advance.\n Arduino Sketch Web Bluetooth App  Leafony Configuration In this sample, you can try the following leaf configurations.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nPin assignment Refer to the figure below for the pin assignment of each leaf.\n\nExecution method  Write 4-Sensors_BLE.ino in Arduino IDE. Open the downloaded index.html of Web Bluetooth App with Google Chrome.\nFor details on how to use the web app, refer to the Basic Kit Getting Started Guide.  Sending data Let\u0026rsquo;s see how to send and receive data with BLE.\nLeafony side In 4-Sensors_BLE.ino, around lAny data can be sent by changing this text.ine 1020, we generate the text data to be sent via Bluetooth. Any data can be sent by changing this text.\nsendLen = sprintf(sendData, \u0026#34;%04s,%04s,%04s,%04s,%04s,%01s\\n\u0026#34;, temp, humid, light, tilt, battVolt, pips) In the above, comma-separated data like \u0026lt;temperature\u0026gt;,\u0026lt;humidity\u0026gt;,\u0026lt;illuminance\u0026gt;,\u0026lt;slope\u0026gt;,\u0026lt;battery voltage\u0026gt;,\u0026lt;dice\u0026gt; is sent.\nThe following is the part that actually sends this text data. (Around line 1085)\nble112.ble_cmd_gatt_server_send_characteristic_notification( 1, 0x000C, sendLen, (const uint8 *)sendData ); Web app side On the web app side, the process for receiving data is written in leafony.js.\nIn line 75 of leafony.js, we specify the function to be called when data is received. Here, the function handleData() is called.\nchar.read.addEventListener( \u0026#39;characteristicvaluechanged\u0026#39;, handleData ); The handleData() function is also described in leafony.js.\nThe data received by the BLE is contained in event.target.value.\nOnce the values are copied into the variable data, the received data is decoded in utf-8, the newline code (\\r\\n) is removed, and then the data is made into an array separated by commas ,.\nThese data are stored in a variable called state with an arbitrary name. (state.temp, state.humid, etc.)\nIf the data sent by the Leafony side is changed, it can be decoded by modifying the handleData() function.\n/** * Characteristicの値が変化した時に呼び出される関数 * @param {*} event */ function handleData( event ) { // 受信したデータの文字コードを変換して、カンマでデータを分けている  // このサンプルではLeafonyは  // 温度,湿度,傾き,電池の電圧  // のようにカンマ区切りのテキストを送信している。  let data = event.target.value; let decoder = new TextDecoder( \u0026#39;utf-8\u0026#39; ); data = decoder.decode( data ); data = data.replace( /\\r?\\n/g, \u0026#39;\u0026#39; ); data = data.split( \u0026#39;,\u0026#39; ); state.devn = deviceName; state.unin = uniqueName; state.temp = data[0]; state.humd = data[1]; state.illm = data[2]; state.tilt = data[3]; state.batt = data[4]; state.dice = data[5]; // ここで updateTable() が実行されている  onStateChangeCallback( state ); // 省略  } Receiving data Web app side By pressing the \u0026ldquo;LED+\u0026rdquo; and \u0026ldquo;LED-\u0026rdquo; buttons on the web app screen, you can change the blinking speed of Leafony\u0026rsquo;s LEDs. The process for when the buttons are pressed is described in the following part of app.js.\nbuttonLedPls.addEventListener ( \u0026#39;click\u0026#39;, function () { console.log( \u0026#39;LED Plus Button Clicked\u0026#39; ); leafony.sendCommand( \u0026#39;PLS\u0026#39; ); }); leafony.sendCommand( 'string' ); to send an arbitrary string to Leafony.\nLeafony side When Leafony receives a string sent from the web app side, the my_evt_gatt_server_attribute_value() function in 4-Sensors.ino will be called. The decoded string is copied to a variable named rcv_data and processed according to the content of the string.\nvoid my_evt_gatt_server_attribute_value( const struct ble_msg_gatt_server_attribute_value_evt_t *msg ) { uint16 attribute = (uint16)msg -\u0026gt; attribute; uint16 offset = 0; uint8 value_len = msg -\u0026gt; value.len; uint8 value_data[20]; String rcv_data; rcv_data = \u0026#34;\u0026#34;; for (uint8_t i = 0; i \u0026lt; value_len; i++) { rcv_data += (char)(msg -\u0026gt; value.data[i]); } // 中略  if( rcv_data.indexOf(\u0026#34;SND\u0026#34;) == 0 ){ bBLEsendData = true; iToggle = 8; } else if( rcv_data.indexOf(\u0026#34;STP\u0026#34;) == 0 ){ bBLEsendData = false; bLCDchange = true; lcd_view_sts = 1; } else if(rcv_data.indexOf(\u0026#34;PLS\u0026#34;) == 0){ if(iToggle \u0026lt; 16){ iToggle += 2; } } else if(rcv_data.indexOf(\u0026#34;MNS\u0026#34;) == 0){ if(iToggle \u0026gt; 2){ iToggle -= 2; } } } You can easily send and receive data by modifying the above sections.\nStructure  Peripheral and Central Advertisement GATT Characteristic  Web app side It consists of three files: index.html, app.js, and leafony.js.\nThe index.html is simple enough to place buttons and tables, and load two other javascript files.\napp.js contains the main processing, such as what happens when a button is pressed.\nleafony.js describes the specific process of connecting to Leafony using Web Bluetooth.\nNotes on Web Bluetooth As of June 2020, Web Bluetooth will need to take the following points into account.\n It does not work with Chrome on iPhone.It is available by using a paid application called WebBLE. The development status of Web Bluetooth and supported browsers can be found at implementation-status.md.  Reference https://qiita.com/s_nkg/items/bdb235388eaeb567b54d\n  Windows 10 version 1703 or later \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite or later \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow or later \u0026#x21a9;\u0026#xfe0e;\n For iPhone or iPad, WebBLE(paid) is required.This is because Web Bluetooth is not implemented in the iPhone and iPad versions of Chrome. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"This sample is the same as the one introduced in Basic Kit Getting Started Guide. Let\u0026rsquo;s read …","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/basic/webbluetooth_iot/","title":"Web Bluetooth IoT"},{"body":"This sample app is a combination of the one introduced in the Basic Kit Web Bluetooth IoT and Motorleaf. Using Bluetooth, you can control the electric pump to turn on and off, water plants, and send sensor information to a smartphone or PC. For details, please refer to Web Bluetooth IoT in Basic Kit.\nWhat to prepare  STM32 MCU, BLE Sugar, 4-Sensors, CR2032, and USB A Windows1, Mac2, or Linux3 PC (for development) Android4, iPhone5, iPad5 smartphone or tablet Google Chrome (Version 70.0.3526.0 or later) Arduino IDE, STM32CubeProgrammer software V2.4.0  Sample app source code Please download both in advance.\n Arduino Sketching Web Bluetooth App  Leafony Configuration In this sample, you can try the following leaf configurations.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AI  Motor 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AZ01 USB 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Assembly Assemble the leaves as shown in the figure below.\nPin assignment Refer to the figure below for the pin assignment of each leaf.\n\nExecution result  Write Motor_BLE_demo.ino in Arduino IDE. Open the downloaded index.html of Web Bluetooth App with Google Chrome.\nFor details on how to use the web app, refer to the Basic Kit Getting Started Guide.    Windows 10 version 1703 or later \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite or later \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow or later \u0026#x21a9;\u0026#xfe0e;\n For iPhone or iPad, WebBLE(paid) is required because Web Bluetooth is not implemented in Chrome for iPhone and iPad. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"This sample app is a combination of the one introduced in the Basic Kit Web Bluetooth IoT and …","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/motor/motor_demo/","title":"Watering plants with a motor"},{"body":"This sample is an STM32 implementation of the one introduced in the Basic Kit Web Bluetooth IoT. The Web Bluetooth application uses the same one as the Basic Kit. For more details, please refer to Web Bluetooth IoT in Basic Kit.\nWhat to prepare  STM32 MCU, BLE Sugar, 4-Sensors, CR2032, USB Windows1, Mac2, or Linux3 PC (for development) Android4, iPhone5, iPad5 smartphone or tablet Google Chrome (version 70.0.3526.0 or later) Arduino IDE, STM32CubeProgrammer software V2.4.0  Sample app source code Please download both in advance.\n Arduino Sketching Web Bluetooth App  Leafony Configuration In this sample, you can try the following leaf configurations.\n   Type Name Q\u0026rsquo;ty     [AZ62]/en/docs/leaf/others/az62) Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Assembly Assemble the leaves as shown in the figure below.\nPin assignment Refer to the figure below for the pin assignment of each leaf.\n\nExecution method  Write STM32_4-Sensors_BLE.ino in Arduino IDE Open the downloaded index.html of Web Bluetooth App with Google Chrome.\nFor details on how to use the web app, refer to Basic Kit Getting Started Guide.    Windows 10 version 1703 or later \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite or later \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow or later \u0026#x21a9;\u0026#xfe0e;\n For iPhone or iPad, WebBLE(paid) is required because Web Bluetooth is not implemented in Chrome for iPhone and iPad. This is because Web Bluetooth is not implemented in Chrome for iPhone and iPad. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"This sample is an STM32 implementation of the one introduced in the Basic Kit Web Bluetooth IoT. The …","ref":"https://docs.leafony.com/en/docs/examples/advanced/3_p/stm32/stm32_webbluetooth_iot/","title":"Web Bluetooth IoT with STM32"},{"body":"Overview We will create an IoT environment sensor using Leafony Beacon1) and Raspberry Pi, and visualize the sensor data using Google Spreadsheet.\n Beacon is a facility for acquiring various information including location by receiving radio waves on the ground with a specific device. in the case of Bluetooth Beacon devices, a module equipped with sensors such as temperature and air pressure can be installed at any location to observe the environment of that location.  What to prepare  Leafony Basic Kit Raspberry Pi (3, 4, zero, etc.) PC or smartphone with browser access Arduino IDE  Sample app code  Github - Leafony/leafony-beacon  Preparing the Raspberry Pi  If you are new to Raspberry Pi, the Raspberry Pi 3 B+ Starter Kit (https://www.switch-science.com/catalog/3880/) is useful. The microSD containing the Raspbian OS image is included, but the display, keyboard, and mouse are not. The display, keyboard, and mouse are not included. The Raspberry Pi will be connected to the Internet via a wireless LAN. Please prepare this in advance as well.  Leafony Configuration    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Assembly Writing sketches  The BLE and 4-Sensors libraries are required for writing. Please include the libraries beforehand. See here for details. In the Arduino IDE, write the following sketch on the microcontroller board. ・leafony_beacon.ino We have confirmed that it works with Arduino IDE 1.8.9. If you get a write error, please check your IDE version.  Building the Raspberry Pi environment We will use a Raspberry Pi as the receiver for the BLE Beacon. In the sample code we will be using, we use Node.js to receive the BLE Beacon using noble. The received data is written to a Google spreadsheet via Google API.\nExecute the following script (6 items) to build the environment. https://github.com/Leafony/leafony-beacon/tree/master/spreadsheet-logger\nsudo apt update sudo apt upgrade sudo apt install -y bluetooth libbluetooth-dev libudev-dev git git clone https://github.com/Leafony/leafony-beacon cd leafony-beacon/spreadsheet-logger npm install Note: WARNING will be displayed, but please continue.\nGetting the Google Sheets API In order to manipulate Google Spreadsheets in Node.js, we need to obtain an API. First, in Step 1 of Node.js Quick Start below, click Enable the Google Sheets API, and download credentials.json. Next, copy the credentials.json to the leafony-beacon/spreadsheet-logger directory.\nNode.js Quickstart | Sheets API | Google Developers : https://developers.google.com/sheets/api/quickstart/nodejs\nSetting Google Sheets ID and sheet name to index.js Open the Google Spreadsheet and check the \u0026ldquo;Sheet ID\u0026rdquo; and \u0026ldquo;Sheet Name\u0026rdquo; in the red line of the URL.\nleafony-beacon/spreadsheet-loggerディレクトリ「index.js」があります。「index.js」の18, 19行目にある「spreadsheetId」と「sheetName」に、上記の「シートID」と「シート名」を貼り付けることで、データが書き込まれます。\nアプリの実行 Raspberry piのターミナルに「sudo node .」と入力してEnterをクリックしてください。\n上記URLにブラウザでアクセスすると、Googleアカウントに移動し、ご自身のアカウントを選択します。\n「詳細」をクリックしてください。\n「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。\n「詳細」をクリックしてください。\n「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。\n「許可」をクリックしてください。以下のコードをコピーしてください。ターミナル内に貼り付けると、「token.json」というファイルが生成されたあとに、beaconのスキャンが始まります。\nBeaconが見つかるとログが表示されると同時に、スプレッドシートに同じ内容が追記されるので、スプレッドシートを開いてデータを確認してください。\n","excerpt":"Overview We will create an IoT environment sensor using Leafony Beacon1) and Raspberry Pi, and …","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/basic/google_sheets_iot/","title":"Google Sheets IoT"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/exten/","title":"Basic Kit + Extension Kit"},{"body":"These are sample applications using AVR MCUs.\n","excerpt":"These are sample applications using AVR MCUs.","ref":"https://docs.leafony.com/en/docs/examples/beginner/1_p/","title":"AVR MCU Examples"},{"body":"These are sample applications using AVR MCUs.\n","excerpt":"These are sample applications using AVR MCUs.","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/","title":"AVR MCU Examples"},{"body":"These are sample applications using ESP32 MCUs.\n","excerpt":"These are sample applications using ESP32 MCUs.","ref":"https://docs.leafony.com/en/docs/examples/beginner/2_p/","title":"ESP32 MCU Examples"},{"body":"These are sample applications using ESP32 MCUs.\n","excerpt":"These are sample applications using ESP32 MCUs.","ref":"https://docs.leafony.com/en/docs/examples/advanced/2_p/","title":"ESP32 MCU Examples"},{"body":"These are sample applications using STM32 MCUs.\n","excerpt":"These are sample applications using STM32 MCUs.","ref":"https://docs.leafony.com/en/docs/examples/advanced/3_p/","title":"STM32 MCU Examples"},{"body":"STM32 MCUを使ったサンプルアプリです。\n","excerpt":"STM32 MCUを使ったサンプルアプリです。","ref":"https://docs.leafony.com/en/docs/examples/beginner/3_p/","title":"STM32 MCU Examples"},{"body":"LoRaリーフを使ったサンプルアプリです。\n","excerpt":"LoRaリーフを使ったサンプルアプリです。","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/lora/","title":"Basic Kit + LoRa"},{"body":"Motorリーフを使ったサンプルアプリです。\n","excerpt":"Motorリーフを使ったサンプルアプリです。","ref":"https://docs.leafony.com/en/docs/examples/advanced/1_p/motor/","title":"Basic Kit + Motor"},{"body":"ESP32 MCUリーフを使ったサンプルアプリです。\n","excerpt":"ESP32 MCUリーフを使ったサンプルアプリです。","ref":"https://docs.leafony.com/en/docs/examples/advanced/2_p/esp32/","title":"ESP32W-iFi Kit"},{"body":"STM32 MCUリーフを使ったサンプルアプリです。\n","excerpt":"STM32 MCUリーフを使ったサンプルアプリです。","ref":"https://docs.leafony.com/en/docs/examples/advanced/3_p/stm32/","title":"STM32"},{"body":"Overview Using only an ESP32 MCU leaf and 4-Sensors leaf, you can build an IoT environmental sensor and visualize the sensor data using Google Spreadsheet.\nPreparing Google Sheets Introducing an IoT service that displays sensor data sent by the ESP32 MCU Leaf in Google Sheets. You can check the data anywhere, if you have a PC or smartphone with browser access.\nFirst, let\u0026rsquo;s configure the settings for displaying data in Google Sheets as follows.  Sign in to your Google account and create a new spreadsheet. If you do not have an account, please create one.  \n You can change the title of Google Sheets (default: Untitled Spreadsheet) as you like. You can also change the sheet number (default: sheet 1) as you like also.\n  The symbol sequence in the red frame in the Google Sheets URL section below will be used later to specify the Google Sheet, so please copy it to an appropriate location.\n Here, 1o0cogc3aomAj58CRdMZARNJtoEmf8dB9ebY02jKV9tA.    \n Open the Script Editor from Tools and copy and paste the source code from Github.\n Leafony/Sample-Sketches/ESP32_GoogleSheets/google_scripts_code.js - GitHub    \nEnter the information of the Google Sheets that you just created in the following variables.  google_sheets_id：The symbol string of the URL of Google Sheets that you just copied. sheet_name：Name of the sheet to write to (default: Sheet 1)    \nThis section describes the procedure for publishing Google Sheets.\nClick Publish-\u0026gt;Deploy as a web application.  \nThen, change the access permissions to Anyone, even anonymous, so that anyone can view it.  \nClick the Deploy button to confirm the access permission from Script App to Google Sheets. Click Confirm Permissions.  \nClick on Details at the bottom left.  \nNext you will get a warning, click on Go to (insecure page).  \nFinally, allow the script to request access to the spreadsheet.  \nThe following pop-up window will appear, and a URL specific to the web app you have created will be issued, so copy the URL and click OK.  \n（App-specific URLs ）\nhttps://script.google.com/macros/s/AKfycbw-8Wx8Zf0alULuD3aLQdwnyVM8hSHAiDsrj49wA17ZqE7y-tP8/exec Checking the operation of Google Sheets   This time, we will try to write Datetime, UniqueID=Leafony_AP02-1, Temperature=100, Humidity=100, Illumination=100 in Google Sheets.\n  If you add ?UniqueID=Leafony_AP02-1\u0026amp;temperature=100\u0026amp;humidity=100\u0026amp;illumination=100 to the app-specific URL, you will get the following\n  https://script.google.com/macros/s/AKfycbw-8Wx8Zf0alULuD3aLQdwnyVM8hSHAiDsrj49wA17ZqE7y-tP8/exec?UniqueID=Leafony_AP02-1\u0026amp;temperature=100\u0026amp;humidity=100\u0026amp;illumination=100 \nPaste the above URL into your browser and access it, and the data will be written to the configured Google Sheets.  The column names listed in the first line of Google Sheets are not automatically displayed, so please provide them in advance. \nIf there is a mistake in the script  Modify the script. Click Publish-\u0026gt;`Deploy as a web application``. If you deploy with the exact same settings as the first time, the modified code may not be reflected properly, so when you deploy again, set Project version to New and click Update. The URL of the web app running at that time can be found below.  \nNext ","excerpt":"Overview Using only an ESP32 MCU leaf and 4-Sensors leaf, you can build an IoT environmental sensor …","ref":"https://docs.leafony.com/en/docs/examples/advanced/2_p/esp32/esp32_googlesheets_1/","title":"Google Sheets with ESP32"},{"body":"IoT services using Google Sheets ESP32 configuration Assemble the leaves, write a sketch, and make sure the data is written to Google Sheets.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover  2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Stack the ESP32 MCU leaf and the 4-Sensors leaf on top of each other and screw them together as shown below.\nSource code Write the program in the Arduino IDE.\n ESP32_GoogleSheets.ino  Note the following bullets in the Github source code, modify it, and write it to ESP32 leaf.\n Substitute the following constants for the information of the WiFi to be accessed.  const char* SSID = \u0026quot;wifi_ssid\u0026quot;; // WiFi SSID const char* PASSWORD = \u0026quot;wifi_password\u0026quot;; // WiFi Password Substitute the following constants for the web app information you just created.  From the app-specific URL：const char* KEY = AKfycbxbxoqWzuN8Eztplnhf3ywC-0QpWc8utkIY1QLngj4fHJFRvZKh    const char* KEY = \u0026quot;google_scripts_key\u0026quot;; If you want to adjust the time interval for writing sensor data, substitute the following constants.  Units are in seconds.    uint64_t DEEP_SLEEP_TIME_SEC = 60; #include \u0026lt;Arduino.h\u0026gt;#include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTTPClient.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; // Unique ID String UniqueID = \u0026#34;Leafony_AP02\u0026#34;; // Connecting WiFi Settings const char* SSID = \u0026#34;wifi_ssid\u0026#34;; // WiFi SSID const char* PASSWORD = \u0026#34;wifi_password\u0026#34;; // WiFi Password // Accessed Google Script Settings const char* APP_SERVER = \u0026#34;script.google.com\u0026#34;; const char* KEY = \u0026#34;google_scripts_key\u0026#34;; // Device sleep time (sec) to reduce Joule heat uint64_t DEEP_SLEEP_TIME_SEC = 60; // 省略 Execution result Run Arduino and sequential sensor data will be written to Google Sheets.\n\n前のページに戻る ","excerpt":"IoT services using Google Sheets ESP32 configuration Assemble the leaves, write a sketch, and make …","ref":"https://docs.leafony.com/en/docs/examples/advanced/2_p/esp32/esp32_googlesheets_1/esp32_googlesheets_2/","title":" "},{"body":"Overview When shipped from the factory, Arduino sketches are written on the ESP32 MCU leaf, so the touch sensor values can be sent via Wi-Fi from a smartphone or PC, and the display will appear.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AX07 Back to back 1   AX08 29pin header 1   AZ62 Connector Cover  2   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*15mm screw 4    φ10x2mm magnet 1    Assembly Assemble the leaves as shown in the figure below.\nPin assignment Refer to the figure below for the pin assignment of each leaf.\n\nSource code The sketch to be used can be found in the GitHub repository below.\nLeafony/Sample-Sketches/ESP32_AP_Touch - GitHub\nExecution method  Insert the batteries into the AAA battery box and turn on the ESP32 leaf power switch. Connect to the following Wi-Fi with your PC or smartphone  SSID: Leafony_ESP32-AP Password: password   Launch a web browser on your PC or smartphone and go to http://192.168.4.1. Pins 7, 9, 22, 24, 26, and 28 of the 29-pin header are assigned to the touch sensor.\nWhen the pin is touched, the capacitance decreases and the value decreases. When the value falls below the threshold of 20, \u0026ldquo;Touch detected\u0026rdquo; is displayed.\n(Pin 24 is hidden in the sample sketch because it interferes with the RTC \u0026amp; microSD. The detection threshold can be changed in the sketch. In the following picture, I am touching pin 26 with my fingertip.)  When you touch pin 26, the browser display will change as shown below.　  ","excerpt":"Overview When shipped from the factory, Arduino sketches are written on the ESP32 MCU leaf, so the …","ref":"https://docs.leafony.com/en/docs/examples/advanced/2_p/esp32/wifi_touchsensor/","title":"Wi-Fi touch sensor"},{"body":"Introduction This is an example of a BLE Beacon type environmental sensor application using ESP32. By adding sensor data to the Attribute of the GATT Server, it can act as a beacon that broadcasts the data. When a connection request is received from the outside, the GATT Server will communicate with the server client and exchange log data with the Characteristic.\nThe loss of data due to packet reception failure that occurs in the Beacon type is prevented by leaving the sensor data in the non-volatile memory in the ESP32. Users can connect and read log data at any time, and the system will immediately switch to Beacon mode after data transfer is completed, greatly reducing power consumption.\nSample app\u0026rsquo;s source code The source code for the sketches and tools used can be viewed in the repository below.\nSample-Sketches/ESP32_BLE_Beacon at master · Leafony/Sample-Sketches\nWhat to prepare  Leafony ESP32 Wi-Fi Kit Leafony Basic Kit Raspberry Pi Android Smartphone USB micro cable  Leaf to use    Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1   AI01 4-Sensors 1    M2 screw 2    Action Method This section describes the steps to run the sample project. If you want to understand how each source code works, please refer to Mechanism described below.\n1. Writing a sketch to an ESP32 leaf Connect the ESP32 leaf to the PC via USB and write the ino file using the Arduino IDE.\nThe sample code uses the ESP32 Logging Library. The sample code uses the ESP32 Logging Library.\nBy setting the Tools → Code Debug Level in the Arduino IDE to the desired level, debug messages will be displayed on the serial monitor.\n2. Run the beacon scanner app. For scanning Advertising packets, use an app that runs on Node.js.\nAny environment can be used as long as it runs Node.js, but this time we will assume that it will be a Beacon receiver set up at a fixed point outdoors, and we will explain how to run the application using a Raspberry Pi 4. In this article, we will explain how to run the application using a Raspberry Pi 4.\nInstall the necessary packages and run the application.\ncd ./tools/node-scanner npm install npm start 3. Run the logging application. A web application is used to retrieve log data and display graphs.\nESP32 Sensors Logger\nStructure How BLE Beacon works GATT Advertising Characteristic ","excerpt":"Introduction This is an example of a BLE Beacon type environmental sensor application using ESP32. …","ref":"https://docs.leafony.com/en/docs/examples/advanced/2_p/esp32/esp32_ble_beacon/","title":"ESP32 BLE Beacon"},{"body":"Introduction This is a sample design of a BLE Beacon that can record temperature, humidity and measurement time using the Flash memory in the STM32 leaf.\nThe temperature/humidity measurement method using Beacon can only provide the temperature/humidity at the current time, and in order to know the measured values up to now, it was necessary to constantly receive Beacon radio waves with a separately installed receiver.\nSince Beacon\u0026rsquo;s radio wave is very weak and its transmission time is short, it is often missed during reception, which is insufficient for stable measurement.\nHowever, in this sample, the measurement record can be kept in the non-volatile memory installed in the STM32, so even if the Beacon signal is not received, the data recorded in the non-volatile memory can be retrieved later by connecting to Leafony.\nThis sample also includes a web application sample that can both receive Beacon and read data written to STM32 Flash memory.\nSample source code The source code for the sketches and tools used can be viewed in the repository below.\nSample-Sketches/STM32_Logger_Beacon at master · Leafony/Sample-Sketches\nSTM32 Sensors Logger Web Application\nWhat to prepare  Leafony Android smartphone  Laef to use    Type Name Q\u0026rsquo;ty     AI01 4-Sensors 1   AP03 STM32 MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    How it works Write a sample sketch on the STM32 leaf.\nOpen the web app on your Android smartphone, and once it is connected to Leafony, the current time on your smartphone will be registered. After that, once the connection with Lefaony is disconnected, it will shift to Beacon operation.\nThe web app side receives the Beacon signal and displays the current temperature.\nWhen you connect Leafony again and press the Log button, the STM32\u0026rsquo;s Flash memory will be read out and a graph of the past temperature and humidity will be displayed.\nOperation Description ","excerpt":"Introduction This is a sample design of a BLE Beacon that can record temperature, humidity and …","ref":"https://docs.leafony.com/en/docs/examples/advanced/3_p/stm32/stm32_logger_ble_beacon/","title":"STM32 Logger Beacon"},{"body":"Introduction This is a simple BLE Beacon sample design using STM32 Leaf. Send the string \u0026ldquo;HELLO BEACON\u0026rdquo; for a period of time, then repeat the sleep cycle.\nSample source code The source code for the sketches and tools used can be viewed in the repository below.\nSample-Sketches/STM32_Simple_Beacon at master · Leafony/Sample-Sketches\nWhat to prepare Leaf to use How it works Explanation of the sketch Flowchart As shown in the figure below, the loop() function of STM32_Simple_Beacon.ino works by sending Beacon packets (Advertising data) while the STM32 leaf and BLE leaf alternately repeat the sleep state and active state for a certain period of time. We have achieved a power-saving system.\nWhen the STM32 leaf executes StartAdvData(), it sets the Advertising data it wants to broadcast on the BLE leaf and sends a command to start sending it.\nSince the STM32 leaf does not do anything while the BLE leaf is Advertising, it enters the deep sleep mode with the LowPower.deepSleep() function, and returns to the active state after the time set with WAKE_INTERVAL has passed. During this time, the STM32 leaf operates in a very power-saving state by turning off the power of unnecessary circuit blocks, etc. so that it can operate with the minimum necessary power.\nSince the STM32 leaf does not do anything while the BLE leaf is Advertising, it enters the deep sleep mode with the LowPower.deepSleep() function, and returns to the active state after the time set with WAKE_INTERVAL has passed. During this time, the STM32 leaf operates in a very power-saving state by turning off the power of unnecessary circuit blocks, etc. so that it can operate with the minimum necessary power.\nAfter the STM32 leaf comes back from deep sleep, we immediately wake up the BLE leaf and run StartAdvData() again to return to the initial process.\nAdvertising data specifications In the StartAdvData() function of STM32_Simple_Beacon.ino, we set the BLE leaf to Advertising data, set the device name to \u0026ldquo;Leaf_A\u0026rdquo; that will be displayed when the BLE Client (PC, smartphone, Raspberry Pi, or other device connected to BLE with Leafony) detects Leafony and sends the string \u0026ldquo;HELLO BEACON\u0026rdquo; as user data.\nThe adv_data[] array is the Advertising data. As described in the comments, this array is the data that connects the chunks of data AD Structure 1 to AD Structure 3. The contents of these data will be described later.\nRegister adv_data to the BLE leaf with ble112.ble_cmd_le_gap_set_adv_data() and run ble112.checkActivity() to wait for the signal from the BLE leaf side that the registration is completed.\nBy running ble112.ble_cmd_le_gap_start_advertising(), BLE will start Advertising and start broadcasting the Advertising data that you just set. By setting LE_GA_SCANNABLE_NON_CONNECTALBE, the BLE Client side can scan the Advertising data, but it is not allowed to establish a connection with this device. This setting is to save power by reducing the processing of the events that occur when a connection request comes in.\nvoid StartAdvData() { // Advertising data; 25byte MAX  uint8_t adv_data[] = { // AD Structure 1: Flag  (2), //0: field length  BGLIB_GAP_AD_TYPE_FLAGS, //1: field type (0x01)  (6), //2: data  // AD Structure 2: Complete local name  (7), //3: field length  BGLIB_GAP_AD_TYPE_LOCALNAME_COMPLETE, //4: field type (0x09)  (\u0026#39;L\u0026#39;), //5:  (\u0026#39;e\u0026#39;), //6:  (\u0026#39;a\u0026#39;), //7:  (\u0026#39;f\u0026#39;), //8:  (\u0026#39;_\u0026#39;), //9:  (\u0026#39;A\u0026#39;), //10:  // AD Structure 3: Manufacture specific  (13), //11: field length  (0xff), //12: field type (0xff)  (\u0026#39;H\u0026#39;), //13:  (\u0026#39;E\u0026#39;), //14:  (\u0026#39;L\u0026#39;), //15:  (\u0026#39;L\u0026#39;), //16:  (\u0026#39;O\u0026#39;), //17:  (\u0026#39; \u0026#39;), //18:  (\u0026#39;B\u0026#39;), //19:  (\u0026#39;E\u0026#39;), //20:  (\u0026#39;A\u0026#39;), //21:  (\u0026#39;C\u0026#39;), //22:  (\u0026#39;O\u0026#39;), //23:  (\u0026#39;N\u0026#39;), //24:  }; // Register advertising packet  uint8_t stLen = sizeof(adv_data); ble112.ble_cmd_le_gap_set_adv_data(SCAN_RSP_ADVERTISING_PACKETS, stLen, adv_data); while (ble112.checkActivity(1000)); // index = 0 LE_GAP_SCANNABLE_NON_CONNECTABLE / LE_GAP_UNDIRECTED_CONNECTABLE  ble112.ble_cmd_le_gap_start_advertising(0, LE_GAP_USER_DATA, LE_GAP_SCANNABLE_NON_CONNECTABLE); while (ble112.checkActivity(1000)); } The figure below shows the format of the Advertising data used in BLE Advertising.\nAdvertising data is composed of multiple chunks of data called AD Structure. The content of each AD Structure is divided into Length and Data, and the number of octets (bytes) of Data is registered in Length.\nThe contents of Data are further divided into AD Type and AD Data, with AD Type telling you what kind of data this AD Structure is.\nFor example, in the above code, AD Structure 2 has a Length of 7, the AD Type is BGLIB_GAP_AD_TYPE_LOCALNAME_COMPLETE (0x09) which is the local name of the device, and Leaf_A is registered in Data.\nThe AD Type of AD Structure 3 is 0xff, and any data can be registered in this AD Structure. The Data is the text \u0026ldquo;HELLO BEACON\u0026rdquo;, and you can broadcast any data on Advertising data by changing this data.\nBLEリーフの動作  Various settings Event handler  ","excerpt":"Introduction This is a simple BLE Beacon sample design using STM32 Leaf. Send the string …","ref":"https://docs.leafony.com/en/docs/examples/advanced/3_p/stm32/stm32_simple_ble_beacon/","title":"STM32 Simple BLE Beacon"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/index.json","title":""},{"body":"Overview  Introduction Our Products Terms Licecnse Contacts  System  Getting-Started Environment Settings Sample App Home-made leaf development  Leaf  Leafony-bus Individual Leaf Technical Data  ","excerpt":"Overview  Introduction Our Products Terms Licecnse Contacts  System  Getting-Started Environment …","ref":"https://docs.leafony.com/en/docs/","title":"Documentation"},{"body":"  #td-cover-block-0 { background-image: url(/en/featured-background_hubf9a9d0a00ddac7fb58721d040adf027_267411_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/en/featured-background_hubf9a9d0a00ddac7fb58721d040adf027_267411_1920x1080_fill_q75_catmullrom_top.jpg); } }  Leafony Documentation   An open innovation platform\n        Enjoy IoT with the Leafony       Easy Circuit Development Leafony makes the circuit design easy. Stack each module and make new circuits.\n   Open Source Hardware Leafony is an OSS project. All codes, circuits and designes are available on GitHub. Free for both personal and commercial use.\nRead more …\n   News Check the latest news\nRead more …\n    -- ","excerpt":"#td-cover-block-0 { background-image: …","ref":"https://docs.leafony.com/en/","title":"Leafony"},{"body":"","excerpt":"","ref":"https://docs.leafony.com/en/search/","title":"Search Results"},{"body":"          Leafony https://leafony.com   　　 　      DAIWA corporation http://daiwa-leafony.jp/   　 　     日昭無線ネットショップPOWERED https://www.powered.jp/SHOP/list.php?Search=leafony   　 　     Chip One Stop https://www.chip1stop.com/sp/products/leafony?cid=top_Features_bn_leafony   　 　     Meico Electronic Co.,Ltd. https://eee.meicodenshi.com/Trend/leafony   　 　   ","excerpt":"          Leafony https://leafony.com   　　 　      DAIWA corporation http://daiwa-leafony.jp/ …","ref":"https://docs.leafony.com/en/shop/","title":"Shop"}]