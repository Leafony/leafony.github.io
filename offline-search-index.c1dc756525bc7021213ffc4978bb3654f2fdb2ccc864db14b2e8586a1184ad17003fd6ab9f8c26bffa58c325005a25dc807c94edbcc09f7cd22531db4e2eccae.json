[{"body":"Leafony only works when you write a program. For example, in Quick Start, a program has been written to read the four sensors and send data via Bluetooth LE.\nIf you are starting to use Leafony, you can make it work the way you want it to by writing a program that describes what you want it to do.\nNext\rInstall the software needed to write a program in Leafony\r\rWhat to prepare  Basic Kit USB cable PC (Windows, Mac OS X or Linux)  Installing Arduino IDE The Arduino IDE is a development environment for the Arduino, an open source hardware platform for electronics. The development environment allows you to write programs, write programs to the Arduino board, and display the data coming from the board. Leafony can be developed with the Arduino IDE.\nLet\u0026rsquo;s download the Arduino IDE right away.\n From the Arduino website, go to SOFTWARE and then DOWNLOADS to get to the Arduino IDE download page. Download the installer for your OS at the place where it says Download the Arduino IDE. Run the downloaded installer and follow the on-screen instructions to install the Arduino IDE.  How to download old versions of Arduino IDE and check and change Arduino AVR Boards Refer to Version of the Arduino IDE.\nNext\rLet’s write a program in Leafony and make it work!\r\rConnecting to PC Connect to your PC with a USB cable.\nConfiguration of the microcontroller board To develop Leafony in the Arduino IDE, let\u0026rsquo;s follow the steps below to configure the IDE.\n Go to Tools → Board and select Arduino Pro or Pro Mini and ATmega328P (3.3V, 8MHz) for Processor.  \nGo to Tools → Serial Port and select the serial port that Leafony is connected to  Checking the operation of the microcontroller board  In the Arduino IDE, click on File → Sketch Examples → 01.Basics → Blink to open the sample app. The program is written to Leafony by pressing the write to microcontroller button. If you can confirm that the LED on the AVR MCU leaf is blinking, you are done.  Specifying pins for a sketch The pin should be specified by its name.\n\nInstalling Libraries To use some of the leaves, you will need to install additional libraries. Follow the steps below to install all libraries in advance.\n1. Library to use The libraries used in each Kit are as follows.\n\r\rLeaf\rRequired Library\rRecommended version\rDescription\r\r\r\r\rBLE\rTBGLib\r\rBluetooth Library\r\r\r4-Sensors\rAdafruit_Sensor.h\r\rUnified Sensor Driver\r\r\rAdafruit_BusIO_Register.h\r\rBus IO Library\r\r\rHTS221.h\r\rTemperature and humidity sensor library\r\r\rClosedCube_OPT3001.h\r\rIlluminance sensor library\r\r\rAdafruit_LIS3DH.h\r1.1.2\rAccelerometer Library\r\r\rLCD\rST7032.h\r\rLCD Library\r\r\rAVR MCU\rMsTimer2.h\r\rTimer interrupt library\r\r\rRTC\u0026MicroSD\rRTClib.h\r\rRTC Library\r\r\r\r2. Download Library Clicking on the links in the table above will take you to the library\u0026rsquo;s GitHub repository. Click Code → Download ZIP to download the library.\n3. Include Library Launch the Arduino and choose Sketch → Include Library → Install ZIP Library to load the zip file you just downloaded.\nWhen in doubt. If it doesn\u0026rsquo;t work, go to \u0026ldquo;If it doesn\u0026rsquo;t work\u0026hellip;\u0026rdquo; to find a solution.\nNext\rA number of programs are available in Sample App. To make development easier, install the library and get started.\r\rBack to previous page\r","excerpt":"Leafony only works when you write a program. For example, in Quick Start, a program has been written …","ref":"/en/docs/environment/avr/arduino/","title":"Arduino IDE Settings for AVR MCU"},{"body":"Follow the steps below to set up the ESP32 Wi-Fi Kit development environment.\nNext\rInstall the software needed to write a program in Leafony.\r\rWhat to prepare  ESP32 Wi-Fi Kit USB cable PC (Windows, Mac OS X or Linux)  Installing Arduino IDE For instructions on how to install the Arduino IDE, please see here.\nNext\rLet’s write a program in Leafony and make it work!\r\rConnecting to PC Connect to your PC with a USB cable.\nConfiguration of the microcontroller board To use the ESP32 MCU leaf with the Arduino IDE, you need to install Arduino core for the ESP32.\n Open the File → Preferences in the Arduino IDE and enter the following URL in the Additional Board Manager URL: field.  　https://dl.espressif.com/dl/package_esp32_index.json\n\nSelect Tools -\u0026gt; Board -\u0026gt; Board Manager, search for esp32 by Espressif Systems and press the Install button.  \nChoose Tools → Board → ESP32 Dev Module to get your ESP32 MCU working.  Checking the operation of the microcontroller board Let\u0026rsquo;s write a Sample App and get the ESP32 Wi-Fi Kit running.\n Launch the Arduino. Paste the following sample code into your code editor.  //***************************** // ボタン入力の状態をシリアルモニタに表示するサンプル //***************************** int pushButton = 0; void setup() { Serial.begin(115200); pinMode(pushButton, INPUT); } void loop() { int buttonState = digitalRead(pushButton); Serial.println(buttonState); delay(1); } Select the COM port to which the ESP32 leaf is connected. Push the write to microcomputer board button to write a sketch. Press and hold the Boot mode switch on the ESP32 leaf when the following message appears during the writing process.  \nOpen the serial monitor and set the communication speed to 115200bps. Press the Boot mode switch (IO0) and see if the input state of the switch changes.  \nSpecifying pins for a sketch **Pin should be specified by Port, not Name.** \n制限事項 ※1：Output cannot be set ※2：①For UART1, the pin number is set to RX=26 and TX=25. For UART0 and UART2, the pin number is not specified.\nHardwareSerial Serial1(1); // UART1 (RX=9, TX=10)  void setup() { Serial1.begin(9600, SERIAL_8N1, 26, 25); // ピンを変更 (RX=26, TX=25) } 　②Cannot be used as analog input if WiFi.h is included\n※3: Pull-up prohibited because it is used for bootstrapping\nInstalling Libraries To use some of the leaves, you will need to install additional libraries. Here to install all libraries in advance.\nWhen in doubt. If it doesn\u0026rsquo;t work, go to \u0026ldquo;If it doesn\u0026rsquo;t work\u0026hellip;\u0026rdquo; to find a solution.\nNext\rA number of programs are available in Sample App. To make development easier, install the library and get started.\r\rBack to previous page\r","excerpt":"Follow the steps below to set up the ESP32 Wi-Fi Kit development environment.\nNext\rInstall the …","ref":"/en/docs/environment/esp32/arduino/","title":"Arduino IDE Settings for ESP32 MCU"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/environment/avr/","title":"AVR MCU Development Environment Settings Manual"},{"body":"","excerpt":"","ref":"/docs/environment/avr/","title":"AVR MCU 開発環境設定マニュアル"},{"body":"The Basic Kit is a small, coin cell powered development kit that includes a 4-Sensors leaf with temperature, humidity, illuminance and acceleration sensors, an AVR MCU leaf and a Bluetooth LE leaf.\nIt\u0026rsquo;s easy to send sensor information to a smartphone or computer via Bluetooth and to control the LEDs in the Basic Kit.\nThe Basic Kit has this program written into it that you can use right out of the box.\nOn the smartphone or computer side, an app called \u0026ldquo;Web Bluetooth\u0026rdquo; can be used to connect to the Basic Kit on any platform, with no installation required.\nWhat to prepare  Basic Kit Windows1, Mac2, Linux3, PC with Chrome OS or Android4, iPhone5, iPad5 smartphone or tablet Google Chrome (Since version 70.0.3526.0)6  Demo Video \r\rSetup  Insert the CR2032 coin cell battery into the Basic Kit and turn on the power switch.    Usage  For Android For iPhone or iPad On Windows or macOS On Linux  For Android  Open Google Chrome. Open web app. Press the Connect button of the web app, select Leafony_AC02 and press the Pair button.\n   Connection complete.\n  The sample app used in this article is \u0026ldquo;Introduction to IoT Apps using Web Bluetooth\u0026rdquo;. You can see the source code and how it works here.\n  Next Steps\rEnvironment Settings and write the program in the Basic Kit.\r\rFor iPhone or iPad  Download WebBLE (paid) from the App Store5 Copy the following URL, launch WebBLE and paste it into the address bar.   https://docs.leafony.com/WebBluetooth_for_Leafony_app/\r Press the Connect button of the web app, select Leafony_AC02 and press the Pair button.\n  Connection complete.\nThere is a \u0026ldquo;Download CSV\u0026rdquo; button on the screen, but it is not available on the iPhone.\n  The sample app I used this time is \u0026ldquo;Web Bluetooth IoT\u0026rdquo;. You can see the source code and how it works here.\n  Next Steps\rEnvironment Settings and write the program in the Basic Kit.\r\rOn Windows or macOS   Open Google Chrome.\n  Open web app.\n  Press the Connect button of the web app, select Leafony_AC02 and press the Pair button.\n  Connection complete.\n  The sample app used in this article is \u0026ldquo;Web Bluetooth IoT\u0026rdquo;. You can see the source code and how it works here.\n  Next Steps\rEnvironment Settings and write the program in the Basic Kit.\r\rOn Linux   To enable Web Bluetooth on Linux, please refer to the following articles to set up your environment.\n\u0026quot;How to get Chrome Web Bluetooth working on Linux\u0026quot;\n  Open Google Chrome.\n  Open web app.\n  Press the Connect button of the web app, select Leafony_AC02 and press the Pair button.\n  Connection complete.\n  The sample app used in this article is \u0026ldquo;Web Bluetooth IoT\u0026rdquo;. You can see the source code and how it works here.\n  Next Steps\rEnvironment Settings and write the program in the Basic Kit.\r\rBack to previous page\r  Windows 10 version 1703 or later \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite or later \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow or later \u0026#x21a9;\u0026#xfe0e;\n For iPhone or iPad, WebBLE (paid) is required. This is because Web Bluetooth is not implemented in the iPhone and iPad versions of Chrome. \u0026#x21a9;\u0026#xfe0e;\n If you have Chrome less than version 79, Web Bluetooth is not enabled by default.\nEnter the following URL in Chrome\u0026rsquo;s address bar and set the Experimental Web Platform features to Enable.\nchrome://flags/#enable-experimental-web-platform-features \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"The Basic Kit is a small, coin cell powered development kit that includes a 4-Sensors leaf with …","ref":"/en/docs/getting-started/basic/","title":"Basic Kit Getting Started Guide"},{"body":"\nOverview The kit includes an AVR microcontroller (Atmega328P), Bluetooth LE, temperature/humidity sensor, illuminance sensor, accelerometer, and a leaf with a magnetic plastic case, and is suitable for ultra-compact, low power consumption systems that can be powered by coin cell batteries. You can create a sensor device.\nContents    Type Item Q’ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AX02 29pin 1   AZ01 USB 1   AZ62 Connector Cover 1   AZ66 Basic Kit Case 1    Caution note 1    CR2032 coin cell battery 1    M2*15mm screw 2    Screw driver 1    Leaf List \rAC02 BLE Sugar\r\rThe Leaf is equipped with Silicon Labs\u0026rsquo; technically certified Bluetooth LE module BGM11S22F256GA-V2.\n\r\r\rAI01 4-Sensors\r\rThis leaf is equipped with a temperature/humidity sensor, an illuminance sensor and an acceleration sensor. Equipped with power-saving sensors and suitable for long-term sensing.\n\r \rAP01 AVR MCU\r\rThis leaf uses the ATmega328P and features 14 digital input and output pins (six of which can be used as PWM outputs), six analog input pins, an 8 MHz oscillator, and a reset button.\n\r \rAV01 CR2032\r\rThis power supply leaf contains a CR2032 coin cell battery holder, a power switch, an AD converter for voltage monitoring, and a 3.3 V to 3.3 V step-up circuit. 2cm x 2cm in size, it is capable of supplying 3.3 V power.\n\r \rAX02 29pin\r\rThis is a leaf with all 29 pins of the leaf I/F connected to a 2.54mm pitch through-hole.\n\r \rAZ01 USB\r\rFTDI\u0026rsquo;s FT232RQ is mounted as a USB-UART conversion IC. It converts from USB VBUS (5V) to 3.3V with a step-down power supply circuit and supplies VBUS and 3.3V to each leaf.\n\r \rAZ62 Connector Cover\r\rThe Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris.\n\r \rAZ66 Basic kit case\r\rThis is a case for the Basic Kit. It can be fixed to the wall with the magnets on the bottom.\n\r \rSample App Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Overview The kit includes an AVR microcontroller (Atmega328P), Bluetooth LE, temperature/humidity …","ref":"/en/docs/products/basic/","title":"Basic Kit"},{"body":"Basic Kitは、温湿度、照度、加速度センサを搭載した4-Sensorsリーフ、AVR MCUリーフ、Bluetoothリーフを搭載した小型でコイン電池で駆動可能な開発キットです。スマートフォンやパソコンに、Bluetoothを使って、センサの情報を送信出来る「Web Bluetooth」というアプリが、プレインストールされています。\n用意するもの  Basic Kit Android1、Mac2、Windows3、iPhoneまたはiPad4、Linux5のスマートフォンやパソコン Google Chrome (バージョン70.0.3526.0以降)  デモ動画 \r\rセットアップ  Leafonyに、CR2032コイン電池を入れ、電源スイッチをONにします。    使い方  Android、Mac、Windowの場合 iPhoneまたはiPadの場合 Linuxの場合  Android、Mac、Windowsの場合  Google Chromeを開きます。 Webアプリを開きます。 WebアプリのConnectボタンを押して、Leafony_AC02を選択し、Pairボタンを押すと、接続が完了です。    画面には温湿度や照度等のデータが表示され、またLeafonyにはLEDが点滅していることが、確認出来ます。\n  ソースコードや動作の仕組みは、Web Bluetoothを使ったIoTアプリ入門に記載しています。\n  次のステップ\rプログラミングのためのパソコンの設定の仕方は、開発環境設定に記載しています。\r\riPhoneまたはiPadの場合  App StoreからBluefy をダウンロードします。 Bluefyを立ち上げて、以下のURLをアドレスバーに貼り付けてください。   https://docs.leafony.com/WebBluetooth_for_Leafony_app/\r iPhoneまたはipadの位置情報を共有をオンにします。位置情報共有設定は、設定 → 自分の名前 → 探すを選択して変更します。\n  WebアプリのConnectボタンを押して、Leafony_AC02を選択し、Pairボタンを押すと、接続が完了です。\n  画面には温湿度や照度等のデータが表示され、またLeafonyにはLEDが点滅していることが、確認出来ます。画面上に「Download CSV」のボタンはありますが使用で出来ません。\n  ソースコードや動作の仕組みは、Web Bluetoothを使ったIoTアプリ入門に記載しています。\n  次のステップ\rプログラミングのためのパソコンの設定の仕方は、開発環境設定に記載しています。\r\rLinuxの場合   Linux上でWeb Bluetoothを有効にするために、How to get Chrome Web Bluetooth working on Linuxを参考に環境設定してください。\n  Google Chromeを開きます。\n  Webアプリを開きます。\n  WebアプリのConnectボタンを押して、Leafony_AC02を選択し、Pairボタンを押すと、接続が完了です。\n  画面には温湿度や照度等のデータが表示され、またLeafonyにはLEDが点滅していることが、確認出来ます。\n  ソースコードや動作の仕組みは、Web Bluetoothを使ったIoTアプリ入門に記載しています。\n  次のステップ\rプログラミングのためのパソコンの設定の仕方は、開発環境設定に記載しています。\r\r前のページに戻る\r  Android 6.0 Marshmallow以降 \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite以降 \u0026#x21a9;\u0026#xfe0e;\n Windows 10 version 1703以降 \u0026#x21a9;\u0026#xfe0e;\n iPhone、またはiPadは、Bluefyのアプリが必要です。 \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Basic Kitは、温湿度、照度、加速度センサを搭載した4-Sensorsリーフ、AVR MCUリーフ、Bluetoothリーフを搭載した小型でコイン電池で駆動可能な開発キットです。スマートフォンや …","ref":"/docs/getting-started/basic/","title":"Basic Kit スタートガイド"},{"body":"  \nFeatures A leaf containing Silicon Labs\u0026rsquo; technically certified BLE module BGM11S22F256GA-V2, which is connected to the MCU leaf via UART. Radio certifications include CE, FCC, ISED Canada, TELEC, KC South-Korea, and NCC Taiwan (SLICON LABS Module Data Sheet Revision 1.2).\nSpecification    Item　 Description     Part number BGM11S22F256GA-V2　   SoC EFR32BG1 (ARM Cortex-M4)　   Bluetooth version 4.2   Frequency range 2400M ~ 2483.5MHz   RX sensitivity -90 dBm @ 1 Mbit/s GFSK   TX power +8dBm以下   RF certification CE, full FCC, ISED Canada, Japan and South-Korea   Flash 256KB   RAM 32KB   Interfaces UART   Dimension W23×D20.5×H4.7mm    Block diagram \nPinassign \nSample App  Simple BLE Characteristic (in progress) Simple BLE Advertisement (in progress） Web Bluetooth IoT  Google Sheets IoT  Library Libraries are available for this leaf. Please install the necessary libraries from Environment to use them.\nDocument  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features A leaf containing Silicon Labs\u0026rsquo; technically certified BLE module BGM11S22F256GA-V2, …","ref":"/en/docs/leaf/communication/ac02/","title":"AC02 BLE Sugar"},{"body":"About Leafony Leafony is an ultra-compact, low-power, easy to use open innovation platform. It makes it easy to prototype new IT services, IoT edge nodes, etc. The Trillion Node Engine Project1 is driving the research and development of this platform, and the finalized version is called \u0026ldquo;Leafony\u0026rdquo;. The company that manufactures and sells this Leafony is called Leafony Systems, Inc.\nIt is said that in the future, many IT nodes such as IoT/CPS2 will be used in society. Professor Emeritus Sakurai of the University of Tokyo has launched the Trillion Node Study Group in order to discuss such future and share information. He is using Leafony as a base for concrete thinking, and is working hard to promote Leafony for the development of the IoT/CPS. We also provide a place to connect related companies with needs and seeds.\nLeafony, a word coined by Leaf and Symphony, aims at the harmony of the individual and the whole, just as Symphony represents the wish for a harmony of tones to play a great piece of music, and for the Leaf to come together to create a great value.\nUsage scenario Enterprise\r\r・Proof of Concept (PoC) of IoT ・R\u0026amp;D and demonstration tests ・IoT system prototype service ・Creation of a reference model\n・Sales tools for our parts and technologies\n・Reuse and transfer of technology\n\r\rPersonal\r\r・New App\n・Service Exploration\n・Easy gadget making\n\r Education and University\r\r・IoT Education\n・Research/Experiment ・Research results are demonstrated to accelerate practical application\n\r \rOverview Video \r\rFor more information, please refer to the following.\nleafony general document EN\rLet\u0026rsquo;s get started. Let\u0026rsquo;s start using Leafony right away.\n Quick start Development Environment Settings Sample App  Back to previous page\r  The Trillion Node Engine Project is a research and development project commissioned and subsidized by the New Energy and Industrial Technology Development Organization (NEDO). \u0026#x21a9;\u0026#xfe0e;\n IoT stands for Internet of Things and CPS stands for Cyber-Physical Systems. In particular, CPS is a system that connects real physical space and digital space without being connected to the Internet. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"About Leafony Leafony is an ultra-compact, low-power, easy to use open innovation platform. It makes …","ref":"/en/docs/overview/","title":"Introduction"},{"body":"Leafonyとは Leafonyは、超小型、低消費電力、簡単に出来るオープンイノベーション・プラットフォームです。新しいITサービスやIoTのエッジノードなどの試作開発が、簡単に出来ます。トリリオンノード・エンジン・プロジェクト1が、このプラットフォームの研究開発を推進し、仕様などが確定したものを「Leafony」と呼びます。また、このLeafonyを製造・販売する会社をLEAFONY SYSTEMS社と言います。\nIoT/CPS2など将来非常に多くのITノードが社会で使われるようになると言われています。東京大学 桜井名誉教授は、そのような未来を議論し情報を共有するため、トリリオンノード研究会を立ち上げました。具体的に考えるベースとして、Leafonyを使っており、IoT/CPSの発展のため、Leafonyの普及に力を入れています。また、ニーズとシーズを持った関連企業をつなぐ場も提供しています。\nLeafonyは、LeafとSymphonyの造語で、個と全体の調和を目指しています。Symphonyは音色が調和して、素晴らしい楽曲を奏でるように、Leafが集まって、素晴らしい価値を創造して欲しいという願いが込められています。\n利用シーン 企業\r\r・IoTのProof of Concept (PoC)\n・R\u0026amp;D、実証実験\n・IoTシステム試作サービス\n・リファレンスモデルの作製\n・自社部品／技術の販売ツール\n・技術の再利用や伝承\n\r\r個人\r\r・新しいアプリ\n・サービスの探査\n・手軽なガジェット創り\n\r 教育・大学\r\r・IoT教育\n・研究／実験\n・研究成果をデモし実用化加速\n\r \r概要動画 \r\r詳しくは、以下を参照してください。 leafony general document JP\nleafony general document EN\rはじめてみよう さっそくLeafonyを使ってみましょう。\n クイックスタート 開発環境設定 サンプルアプリ  前のページに戻る\r  トリリオンノード・エンジン・プロジェクトは、国立研究開発法人新エネルギー・産業技術総合開発機構（ＮＥＤＯ）の委託・助成事業による研究開発プロジェクトです。 \u0026#x21a9;\u0026#xfe0e;\n IoTはInternet of Things、CPSはCyber-Physical Systemsの略です。特に、CPSはネットにつながらずとも、リアルな物理的空間とデジタル空間をつなぐような システムです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Leafonyとは Leafonyは、超小型、低消費電力、簡単に出来るオープンイノベーション・プラットフォームです。新しいITサービスやIoTのエッジノードなどの試作開発が、簡単に出来ます。トリリオン …","ref":"/docs/overview/","title":"はじめに"},{"body":"Basic Kit 2には、Leafony block(AVR MCU等のリーフをネジ止め)、STM32 MCU、29pin、ケース、ドライバーが入っており、AVR MCUとSTM32 MCUには、予めスケッチが書き込まれています。出荷時はAVR MCUがLeafony blockに組み込まれています。\n まずは、Basic Kit スタートガイドをお試し下さい。センサのデータをBLEのコネクションモードを使ってスマートフォン等に送信するアプリで動作確認ができます。 次に、以下のスタートガイドに従って、Leafony blockのマイコンをAVR MCU からSTM32MCUに変更し、最新技術に触れてみて下さい。出荷時に書き込まれているプログラムはセンサのデータをBLEのビーコンモードを使ってスマートフォン等に送信するもので、コイン電池でも数か月動作する低電力動作を実現しています。   \nSTM32リーフにあらかじめ書き込まれているスケッチでは、IoT応用に良く出てくるような次の動作を確認できます。\n センサのデータを一定時間間隔で取得し、 そのデータをSTM32のマイコン内部のEEPROMに書き込むとともに、 Bluetooth無線通信でデータを送信する  これらの動作を超低電力で行えるように、上図のように双方向通信ができるconnection modeと超低電力なbeacon modeの2つのモードを使っています。一定時間間隔（デフォルト10秒、変更可能）でセンサデータを取得し、EEPROMにデータを蓄積するとともに、beacon modeでデータを一方的に送信します。Connection mode を使ってEEPROM内のセンサ蓄積データをPCやAndroidスマホに一括ダウンロードすることもできます。 それでは、ビデオとwebを見ながら、新しいSTM32リーフをお試しください。\nWeb Bluetooth Web Bluetoothは、Leafony blockのデータ(最大169サンプル)をグラフにしたり、センシングしたデータを表示させることが出来ます。ただし、対応のブラウザに制限がありますので、注意して下さい。\nWeb Bluetoothの注意点 2022年9月時点ではWeb Bluetoothは以下の点に注意しなければいけません。\n  センシングデータを表示出来るのは、Andoroid のみです。Google Chromeを開き、アドレスバーに、下記URLを入力し、Enabledにして下さい。 chrome://flags/#enable-experimental-web-platform-features\n  iPhoneにはBluefyのアプリが必要です。また、画面上に「Download CSV」のボタンはありますが使用で出来ません。\n  Web Bluetoothの開発状況と対応ブラウザについてはimplementation-status.mdで確認できます。\n  用意するもの  Basic Kit Android1、Mac2、Windows3、Linux4、iPhone5のスマートフォンやパソコン Google Chrome (バージョン70.0.3526.0以降)  デモ動画 \r\rセットアップ   STM32 MCUの Conector Coverを外し、Leafomny blockのAVC MCUとUSBリーフを取り外し、STM32 MCUリーフを付けます。    Leafony blockに、CR2032コイン電池を入れ、電源スイッチをONにします。    STM32 MCUリーフのプログラムスイッチを、Runにします。 \n  使い方   Google Chromeを開きます。\n  Webアプリを開き、画面に従って操作を進めて頂くと、センサが測定開始し、センシングデータをグラフにしたり、データをスマホ(Androidのみ)で確認することが出来ます。\n  最後に センサデータの取得間隔の変更は次の初期設定の変更を押して、行ってください。デフォルトは10秒になっています。計算値ではありますが、データ取得の時間間隔が数分以上であれば、CR2032コイン電池でも電力的には数か月動作すると考えられます。 センサデータがダウンロードできれば、正常動作しています。Quickstartはここまでです。 詳しくは、STM32 Logger Beaconに記載しています。\n次のステップ\rプログラミングのためのパソコンの設定の仕方は、開発環境設定に記載しています。\r\r前のページに戻る\r  Android 6.0 Marshmallow以降 \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite以降 \u0026#x21a9;\u0026#xfe0e;\n Windows 10 version 1703以降 \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n iPhoneにはBluefyのアプリが必要です。iPhoneのChromeではWeb Bluetoothが実装されていないためです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Basic Kit 2には、Leafony block(AVR MCU等のリーフをネジ止め)、STM32 MCU、29pin、ケース、ドライバーが入っており、AVR MCUとSTM32 MCUには、予 …","ref":"/docs/getting-started/basic2/","title":"Basic Kit 2 スタートガイド"},{"body":"  --\r概要 コイン電池でも駆動可能な超小型・低消費電力システム向きの開発キットです。AVRマイコン(Atmega328P)、STM32マイコン(STM32L452REI6)、Bluetooth LE、温湿度センサ、照度センサ、加速度センサを搭載したリーフとマグネット付きプラスチックケースが含まれており、簡単にIoTセンサデバイスを作ることが出来ます。\n内容物    Type Item Description Q’ty     AC02 BLE Sugar Silicon Labs社のBluetooth LEモジュールを搭載したリーフ 1   AI01 4-Sensors 温度、湿度、照度、加速度センサを搭載したリーフ  1   AP01 AVR MCU ATmega328Pを使用した8bit MCUリーフ 1   AP03 STM32 MCU STM32L452REシリーズを使用した32bit MCUリーフ 1   AV01 CR2032 CR2032コイン電池ホルダと昇圧回路を搭載したリーフ 1   AX02 29pin 29pin I/Fのリーフ 1   AZ01 USB MCU への書き込みやシリアルモニタに接続するリーフ  1   AZ62 Connector Cover コネクタカバー 1   AZ66 Basic Kit Case Basic Kitのケース 1    Product sheet 製品シート 1    Product label 製品ラベル 1    CR2032 coin cell battery コイン電池CR2032 1    M2* 18mm screw M2×18mm 2    Screw driver ドライバー  1    リーフ一覧 \rAC02 BLE Sugar\r\rSilicon Labsの技的認証済みBluetooth LEモジュールBGM11S22F256GA-V2を搭載したリーフです。\n\r\r\rAI01 4-Sensors\r\r温湿度センサ、照度センサ、加速度センサを搭載したリーフです。省電力なセンサを搭載し長時間のセンシングに適しています。\n\r \rAP01 AVR MCU\r\rATmega328Pを使用したリーフです。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。\n\r \rAP03 STM32 MCU\r\rSTM32L452REシリーズを使用した32bit MCUリーフです。USBを使用する場合はUSBリーフを、SWDを使用する場合はShieldリーフを使用します。\n\r \rAV01 CR2032\r\rCR2032コイン電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。2cm x 2cmのサイズで3.3Vの電源を供給可能です。\n\r \rAX02 29pin\r\rリーフI/Fの29ピン全てを2.54mmピッチのスルーホールに接続したリーフです。\n\r \rAZ01 USB\r\rAVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\n\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \rAZ66 Basic kit case\r\rBasic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\n\r \rサンプルアプリ・応用例 変更履歴  Rev A1.0: 2021年5月初版  前のページに戻る\r","excerpt":"--\r概要 コイン電池でも駆動可能な超小型・低消費電力システム向きの開発キットです。AVRマイコン(Atmega328P)、STM32マイコン(STM32L452REI6)、Bluetooth LE、 …","ref":"/docs/products/basic2/","title":"Basic Kit 2"},{"body":"","excerpt":"","ref":"/docs/environment/esp32/","title":"ESP32 MCU 開発環境設定マニュアル"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/environment/esp32/","title":"ESP32 MCU Development Environment Settings Manual"},{"body":"The ESP32 Wi-Fi Kit is a development kit with the ESP32-WROOM-32 with built-in Wi-Fi and Bluetooth LE, which can be powered by batteries or lithium batteries.\nIt\u0026rsquo;s easy to send touch sensor values to your smartphone or computer via Wi-Fi.\nThe ESP32 Wi-Fi Kit comes with this program written and ready to use right out of the box.\nWhat to prepare  ESP32 Wi-Fi Kit A Wi-Fi-enabled PC, smartphone or tablet Your preferred web browser  Usage  Insert three AAA batteries into the ESP32 Wi-Fi Kit and turn on the power switch.\n Use your PC, smartphone or tablet to search for Wi-Fi in the area and connect to the Wi-Fi of the following SSID.  SSID: Leafony_ESP32-AP Password: password   Copy the following URL, launch WebBLE and paste it into the address bar.   http://192.168.4.1\r Pins 7, 9, 22, 24, 26 and 28 of the 29pin header are assigned to the touch sensor.\nTouching the pins increases the capacitance and decreases the value. If the value falls below the threshold of 20, \u0026ldquo;Touch detected\u0026rdquo; is displayed.\n(Pin 24 is hidden in the sample sketch due to interference with the RTC \u0026amp; microSD. The detection threshold can be changed in the sketch. In the picture below, I am touching pin 26 with my fingertip.)\n   When the 26-pin is touched, your web browser will change its display as shown below.　   There is a magnet on the Nut Plate part of the ESP32 Wi-Fi Kit. Let\u0026rsquo;s install it on a metal wall.\n  The sample app we used this time is \u0026ldquo;Wi-Fi Touchsensor\u0026rdquo;. The source code and how it works can be found here.  Next Steps\rEnvironment Settings and write the program to the ESP32 Wi-Fi Kit.\r\rBack to previous page\r","excerpt":"The ESP32 Wi-Fi Kit is a development kit with the ESP32-WROOM-32 with built-in Wi-Fi and Bluetooth …","ref":"/en/docs/getting-started/esp32/","title":"ESP32 Wi-Fi Kit Getting Started Guide"},{"body":"Try using a leaf equipped with a motion sensor, MEMS microphone, etc.!\n\nThe Extenston Kit is a development kit that can be used in conjunction with the Basic Kit and the ESP32 Wi-Fi Kit and contains a leaf with a motion sensor and MEMS microphone.\nTo drive the Extenston Kit, you must write a program to the MCU leaf of the Basic Kit or the ESP32 Wi-Fi Kit.\nWhat to prepare  Extenston Kit Basic Kit, or ESP32 Wi-Fi Kit PC (Windows, Mac OS X, or Linux)　  How to write a program If you haven\u0026rsquo;t prepared the PC environment yet, please refer to Basic Kit Development Environment Settings Manual or ESP32 Wi-Fi Kit Development Environment Settings Manual to prepare.\nNext step\rLet’s write the program in Sample app.\r\rBack to previous page\r","excerpt":"Try using a leaf equipped with a motion sensor, MEMS microphone, etc.!\n\nThe Extenston Kit is a …","ref":"/en/docs/getting-started/extension/","title":"Extension Kit Getting Started Guide"},{"body":"\nOverview The Extension Kit contains a variety of useful and easy-to-use leafs that can be used in conjunction with the Basic Kit and the ESP32 Wi-Fi Kit for a wider range of applications. It does not include a microcontroller leaf, so you will need the Basic Kit or the ESP32 Wi-Fi Kit to run the software.\nContents    Type Item Q’ty     AI02 SP \u0026amp; PIR 1   AI03 MIC \u0026amp; VR \u0026amp; LED 1   AI04 LCD 1   AV03 AA BAT 1   AX01 Shield 1   AX03 Leafx2 1   AX04 Spacer 1   AX05 I Meas. 1   AX06 Grove \u0026amp; 5V 1    Caution note 1    Leaf List \rAI02 SP\u0026amp;PIR\r\rThe Leaf is equipped with a piezoelectric speaker and a motion sensor. The motion sensor has a built-in proximity detection algorithm and can detect the approach of an object with simple settings.\n\r \rAI03 MIC\u0026amp;VR\u0026amp;LED\r\rThis leaf is equipped with a MEMS microphone, volume and LED. It can be powered off with a load switch by controlling the I2C Expander to achieve low power consumption.\n\r \rAI04 LCD\r\rThis leaf is equipped with a character LCD unit and two user switches. It can be powered off with a load switch by controlling the I2C Expander to achieve low power consumption.\n\r \rAV03 AA BAT\r\rThis is a power supply leaf with an AA battery holder, a power switch, an AD converter for voltage monitoring, a 3 V to 3.3 V boost circuit, and three Leafony connectors to provide power to more leaves.\n\r \rAX01 Shield\r\rAn expansion board with an Arduino Shield connector, a SWD connector, an ICSP connector, and three leaf I/Fs mounted on it.\n\r \rAX03 Leaf x2\r\rThis connector leaf is used to connect the leafs side-by-side.\n\r \rAX04 Spacer\r\rA spacer leaf that is placed between two stacked leaves. It can be used when parts of the leafs interfere with each other.\n\r \rAX05 I Meas.\r\rThis leaf is used to measure the current flowing in the 3.3V and VBUS. Normally, the Leafony bus is electrically connected on both sides, but in this leaf, only the 3.3V and VBUS are disconnected in the front and the back, and they are connected to the through-hole.\n\r \rAX06 Grove\u0026amp;5V\r\rIt is a UART, I2C, analog input and digital input leaf that operates at 3.3V and 5V in accordance with the Grove series from VBUSSeeed Studio. 3.3V is converted to 5V by a step-up power supply circuit and supplied to Grove. To achieve low power consumption, it is possible to turn off the 5V power supply by controlling the I2C Expander.\n\r \rRevision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Overview The Extension Kit contains a variety of useful and easy-to-use leafs that can be used in …","ref":"/en/docs/products/extension/","title":"Extension Kit"},{"body":"Kits \rBasic Kit\r\rBluetooth LE and 4 sensors. Compact and coin cell powered development kit.\n\r\r\rESP32 Wi-Fi Kit\r\rThe ESP32-WROOM-32 with built-in Wi-Fi and Bluetooth LE. Development kit that can be powered by dry batteries or lithium batteries.\n\r \rExtension Kit\r\rThe kit contains a leaf with a motion sensor and MEMS microphone for use with the Basic Kit and ESP32 Wi-Fi Kit.\n\r \rOthers \rConnector\r\rA set of 10 Connectors for the Leafony platform.\n\r\r\rNut Plate \u0026amp; Connector Cover\r\rA connector cover to protect the Nut Plate and ACR from debris when screwing the leaf in place.\n\r \rThird party In progress.\nBack to previous page\r","excerpt":"Kits \rBasic Kit\r\rBluetooth LE and 4 sensors. Compact and coin cell powered development kit.\n\r\r\rESP32 …","ref":"/en/docs/products/","title":"Our Products"},{"body":"キット \rBasic Kit 2\r\rBluetooth LE、4つのセンサ、AVRマイコンとSTM32マイコンを搭載。小型でコイン電池駆動可能な開発キット。\n\r\r\rESP32 Wi-Fi Kit 2\r\rWi-FiとBluetooth LE内蔵のESP32-WROOM-32を搭載。乾電池やリチウムバッテリで駆動可能な開発キット。\n\r \rExtension Kit\r\rBasic KitやESP32 Wi-Fi Kitと組み合わせて使える、人感センサや MEMS マイクなどを搭載したリーフが入っているキット。\n\r \rその他 \rConnector\r\rLeafonyプラットフォーム用のConnector10個セット。\n\r\r\rNut Plate \u0026amp; Connector Cover\r\rリーフをねじで固定する時に使用するNut Plate と ACR に付着するゴミを防御するコネクタカバー。\n\r \r前のページに戻る\r","excerpt":"キット \rBasic Kit 2\r\rBluetooth LE、4つのセンサ、AVRマイコンとSTM32マイコンを搭載。小型でコイン電池駆動可能な開発キット。\n\r\r\rESP32 Wi-Fi Kit 2 …","ref":"/docs/products/","title":"製品一覧"},{"body":"\nOverview Based on the popular ESP32 microcontroller, this kit includes Wi-Fi wireless communication, microSD, and a real-time clock function. It doesn\u0026rsquo;t run on coin cell batteries, but it runs on a slightly larger battery. As is, you can send the value of the touch sensor to your smartphone or PC via Wi-Fi for easy display.\nContents    Type Item Q’ty     AP02 ESP32 MCU 1   AV04 2V～4.5V 1   AX07 Back to back 1   AX08 29 pin header 1   AZ02 RTC \u0026amp; micro SD 1   AZ62 Connector Cover 2   AZ63 Nut Plate 2    AAA battery holder 1    Caution note 1    M2*12mm screw 2    φ10x2mm magnet 1    Leaf list \rAP02 ESP32 MCU\r\rEspressif Systems\u0026rsquo; 32-bit MCU leaf featuring the ESP32-WROOM-32 module with integrated Wi-Fi and Bluetooth LE, which is technically certified.\n\r \rAV04 2V～4.5V\r\rThe power supply leaflet contains a JST SH connector for lithium-ion battery or battery box connection, a power switch, an AD converter for voltage monitoring and a 3.3 V step-up/down circuit.\n\r \rAX07 Back to back\r\rA connector leaf that can be connected back to back.\n\r \rAX08 29pin header\r\rA leaf with all 29 pins of the leaf I/F connected to a 2.54mm pitch pin header.\n\r \rAZ02 RTC\u0026amp;microSD\r\rThe RTC can output interrupts to the MCU with alarms and timers, while the microSD card is accessible via SPI.\n\r \rAZ62 Connector Cover\r\rThe Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris.\n\r \rAZ63 Nut Plate\r\rThe Nut Plate is used to fix the leaf with a screw. Be careful not to use commercially available hex nuts as they may cause a short circuit by touching the electrodes on the board.\n\r \rRevision history  Rev A1.0: First edition, January 2020  Back to previous page\r","excerpt":"Overview Based on the popular ESP32 microcontroller, this kit includes Wi-Fi wireless communication, …","ref":"/en/docs/products/esp32/","title":"ESP32 Wi-Fi Kit"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/environment/stm32/","title":"STM32 MCU Development Environment Settings Manual"},{"body":"","excerpt":"","ref":"/docs/environment/stm32/","title":"STM32 MCU 開発環境設定マニュアル"},{"body":"Terms（alphabetical order） IoT/CPS IoT stands for Internet of Things and CPS stands for Cyber-Physical Systems. In particular, CPS is a system that connects real physical and digital spaces without being connected to the internet.\nLeaf It is the basis of the Leafony project, a 2 cm square electronic board/electronic module. We call it a leaf because it is small and green. You can easily make your own leaf.\nLeafony or the Leafony platform Leafony is an open hardware and software platform built from leafs. Its ultra-compact size and low power consumption make it easy to create IoT/CPS systems, which is ideal to increase the development efficiency for the future digital transformation. Software development is easy. Of course, you can also develop software outside of the Arduino environment.\nLeafony, a word coined from Leaf and Symphony, aims at the harmony between the individual and the whole, and Symphony represents the desire for the Leaf to come together to create great values, just as the sounds of the various instruments work in harmony to create a great piece of music.\nThe technical information on Leafony is basically free to use for commercial purposes. You can find more information about the license in the License section. User-specific leafs are sold by many companies, individuals, etc., under the guise of being Leafony bus compliant, and we encourage such activities. However, since Leafony is a registered trademark, we ask that you refrain from using the Leafony name on the leaf itself to avoid market confusion.\nLeafony block It is an electronic device that is made up of multiple leaves. Normally, stacked leaves form a block, so it is called a leaf block. An electronic device made by combining leaves, even if the structure is flat and spread out, is called a leaf block.\nLeafony bus A common pathway that connects multiple leaves to each other is called a Leafony bus. It defines the electrical and physical specifications for the electrical signal and power connections. A Leafony bus-compliant leaf will be able to communicate with other leaves, but since it depends on the software and so on whether the Leafony platform is completely safe to connect to, Leafony bus-compliance just means that it is possible to connect close to the physical level.\nThe Leafony bus artwork is copyrighted and published under the CC-BY License, so you can use it for commercial purposes as well as It is free to use as long as you state that it is Leafony compliant. Therefore, you are free to develop and sell your own leafs. However, since Leafony is a registered trademark, you should not label your leaf as Leafony on it itself; a leaf with the label Leafony will show you that the product quality has been verified, and you will avoid confusion.\nLeafony connector Newly developed anisotropic conductive rubber connectors for interconnecting the leaf. It is both a male and female connector. Although it is possible to connect the leaves with solder and other thermal compression techniques, the Leafony connector is more convenient.\nLEAFONY SYSTEMS Co.,Ltd. Leaf is the only company that manufactures and sells Leafony, which was researched and developed by the Trillion Node Engine Project, and is the only company that displays Leafony on Leaf by LEAFONY SYSTEMS. It has been identified by the Trillion Node Engine Project.\nLeafony bus-compliant reefs will be sold by many other companies, individuals, etc., and although we encourage such activities, there is no Leafony label on the reef itself.\nTrillion-node engine This is the electronics platform developed by the Trillion Node Engine Project. It is available to the public under the name Leafony, after organizing the hardware and software that are no longer under development.\nTrillion-node engine project The Trillion Node Engine Project is a research and development project commissioned and subsidized by the New Energy and Industrial Technology Development Organization (NEDO).\nTrillion-node study-group It is said that in the future, many IT nodes such as IoT/CPS will be used in society. The purpose of this workshop is to discuss such future and share information. We are using Leafony as a concrete basis for thinking, and we are trying to promote Leafony for the development of IoT/CPS. We also provide a place to connect related companies that have needs and seeds.\nHarness Electrical connections between a Leafony block and the outside world may require some wiring. Such a wiring is called a harness.\nBack to previous page\r","excerpt":"Terms（alphabetical order） IoT/CPS IoT stands for Internet of Things and CPS stands for …","ref":"/en/docs/terms/","title":"Terms"},{"body":"用語の説明（ABC順） IoT/CPS IoTはInternet of Things、CPSはCyber-Physical Systemsの略です。特に、CPSはネットにつながらずとも、リアルな物理的空間とデジタル空間をつなぐようなシステムです。\nLeaf（リーフ） Leafonyの基礎となる2cm角程度の電子基板／電子モジュールのことです。小さくて緑色なのでリーフ（木の葉）と呼んでいます。厳密には、リーフとはLeafonyバスを有する電子基板のことです。使用者独自のオリジナル・リーフも容易に作れ、「Leafony準拠」と表示すれば商業的にも自由に販売できます。\nLeafony（リーフォニー） または、Leafony platform（リーフォニー・プラットフォーム） リーフを組み合わせて作り上げるオープンなハードウェアとソフトウェアのプラットフォームです。超小型、低消費電力なので、IoT/CPSのシステムを簡単に作れますので、今後のデジタル・トランスフォーメーションのための開発効率アップに適しています。LeafonyはArduinoのソフトウェアでも動きますので、多くのソフトウェアがウェブからダウンロードでき、ソフトウェア開発も簡単です。もちろん、Arduinoの環境以外でも開発可能です。\nLeafonyはLeafとSymphonyの造語ですが、個と全体の調和を目指した造語です。Symphonyでは、さまざまな楽器の出す音色が調和して素晴らしい楽曲を奏でるようにLeafが集まって素晴らしい価値を創造して欲しいという願いが込められています。\nLeafonyの技術情報は、基本的に商用でも自由に無償で使用できます。ライセンスの詳しい情報は、ライセンスの項をご覧ください。使用者独自のリーフは「Leafony準拠」と表示して、企業や個人などから多数販売されますし、そのような活動を推奨しています。しかしながら、Leafonyは登録商標ですので、市場の混乱を避けるため、商品名称にLeafonyの表示はお控えください。\nLeafony block（リーフォニー・ブロック） 複数のリーフを組み合わせてでき上がった電子機器のことです。通常、リーフをスタックするとブロック状になるので、リーフブロックと呼びます。平面的に広がった構造であっても、リーフを組み合わせて作った電子機器はリーフブロックと呼ばれます。\nLeafony bus（リーフォニー・バス） 複数のリーフ間を相互に接続する共通経路部をLeafonyバスと呼びます。電気信号および電源接続を行うための電気的および物理的な仕様が定義されています。典型的にはリーフの20mm x 5.5mmの領域となります。Leafonyバス準拠のリーフは他のリーフと交信可能になりますが、Leafonyプラットフォームと完全に問題なく繋がるかはソフトウェアなどにもよるため、Leafonyバス準拠というのはあくまでも物理レベルに近いところで接続可能といっているに過ぎません。\nLeafonyバスのアートワークには著作権があり、CC-BYライセンスで公開していますので、商用でもLeafony準拠と明記すれば自由に無償で使用できます。従って、自由に独自のリーフを開発や販売ができます。ただし、Leafonyは登録商標ですので、独自に作ったリーフそのものにはLeafonyとは表示しないでください。Leafonyと表示のあるリーフは製品品質が確かめられていることがわかり、混乱を避けられます。\nLeafony connector（リーフォニー・コネクタ） リーフを相互接続するために新規開発された、異方性導電ゴムを使用したコネクタです。オス・メスを兼ねています。リーフの接続は、ハンダを使った熱圧着技術などでも可能ですが、Leafonyコネクタを使うのが簡便です。\nＬＥＡＦＯＮＹ　ＳＹＳＴＥＭＳ株式会社（リーフォニー・システムズ 株式会社） トリリオンノード・エンジン・プロジェクトが研究開発したLeafonyを、リーフにLeafonyの登録商標をつけて製造、販売する唯一の会社です。Leafonyと表示されたリーフは、相互接続などがトリリオンノード・エンジン・プロジェクトによって確認されています。\nLeafonyバス準拠のリーフは、Leafony準拠と表示して他の企業や個人などから多数販売されますし、そのような活動を推奨していますが、商品名称にLeafonyの表示はされません。\nTrillion-node engine(トリリオンノード・エンジン) トリリオンノード・エンジン・プロジェクトで研究開発された、エレクトロニクス・プラットフォームのことです。研究開発が終了したハードウェアやソフトウェアに関して整理した上で、Leafonyという名称で一般公開しています。\nTrillion-node engine project(トリリオンノード・エンジン・プロジェクト) トリリオンノード・エンジン・プロジェクトは、国立研究開発法人新エネルギー・産業技術総合開発機構（ＮＥＤＯ）の委託・助成事業による研究開発プロジェクトです。\nTrillion-node study-group (トリリオンノード研究会) IoT/CPSなど将来非常に多くのITノードが社会で使われるようになると言われています。そのような未来を議論し情報を共有するための研究会です。具体的に考えるベースとして、Leafonyを使っており、IoT/CPSの発展のため、Leafonyの普及に力を入れています。また、ニーズとシーズを持った関連企業をつなぐ場も提供しています。\nハーネス Leafonyブロックと外部との電気的接続には配線が必要な場合があります。そのような配線をハーネスと呼びます。\n前のページに戻る\r","excerpt":"用語の説明（ABC順） IoT/CPS IoTはInternet of Things、CPSはCyber-Physical Systemsの略です。特に、CPSはネットにつながらずとも、リアルな物理的 …","ref":"/docs/terms/","title":"用語の説明"},{"body":"Let\u0026rsquo;s start using Leafony when it arrives!\nThe kit comes with an app installed that you can use as soon as you turn it on.\nTake a look at this page to experience the world of IoT.\nBack to previous page\r","excerpt":"Let\u0026rsquo;s start using Leafony when it arrives!\nThe kit comes with an app installed that you can …","ref":"/en/docs/getting-started/","title":"Getting Started"},{"body":"Software Since the Trillion-node engine project, or software developed and released by the Trillion-node study-group, is Licensed by MIT, you can use the You are free to use it. Other software, such as the library, that you may use when using Leafony, is under the licensing conditions of the respective code. The license terms are usually written in the respective program code.\nHardware The Leafony bus board layout (artwork) is copyrighted and published under the \u0026lt;a href=\u0026quot;https:// Since it is available under CC-BY License, you can use it freely for commercial purposes as long as you specify \u0026ldquo;Leafony compliant\u0026rdquo;. Therefore, you can develop and sell your own leafs freely. We do not claim the copyright of the other parts of the artwork.\nOn the other hand, \u0026ldquo;Leafony\u0026rdquo; is a registered trademark of Leafy Systems, Inc. Please refrain from using the name \u0026ldquo;Leafony\u0026rdquo; in the product name of your self-made leaf, as it may lead to confusion with the LEAFONY SYSTEMS Corporation\u0026rsquo;s product line and confuse the market.\nOther Leafony is a registered trademark of LEAFONY SYSTEMS Corporation.\nBack to previous page\r","excerpt":"Software Since the Trillion-node engine project, or software developed and released by the …","ref":"/en/docs/license/","title":"License"},{"body":"You can easily develop in the Arduino environment, just like the AVR MCU leaf. We have prepared sample applications for STM32 MCU Leaf, so you can try them out.\nWhat to prepare  STM32 MCU Basic Kit, Extenston Kit or ESP32 Wi-Fi Kit PC (Windows、Mac OS X , or Linux)　  How to write a program If your PC environment is not ready yet, please refer to the \u0026ldquo;Arduino IDE configuration for STM32 MCU\u0026rdquo; for preparation. Next step\rLet’s write the program in Sample app.\r\rBack to previous page\r","excerpt":"You can easily develop in the Arduino environment, just like the AVR MCU leaf. We have prepared …","ref":"/en/docs/getting-started/stm32/","title":"STM32 MCU Getting Started Guide"},{"body":"ソフトウェア トリリオンノード・エンジン・プロジェクト、あるいはトリリオンノード研究会が独自に開発し公開したソフトウェアはMITライセンスですので、自由に使用可能です。その他、Leafonyを使用するときに一緒に使う場合のあるライブラリーなどのソフトウェアは、それぞれのコードのライセンス条件になります。ライセンス条件などは、通常それぞれのプログラムコードに記載されています。\nハードウェア Leafony 「バス」の基板レイアウト（アートワーク）には著作権があり、CC-BYライセンスで公開していますので、商用でも「Leafony準拠」と明記すれば、自由に無償で使用できます。従って、自作リーフの開発や販売が自由にできます。Leafony「バス」以外のすべてのリーフのアートワークの著作権は主張致しません。Leafony「バス」の基板レイアウトの著作権はLEAFONY SYSTEMS株式会社に帰属します。\n一方、「Leafony」は、LEAFONY SYSTEMS株式会社の登録商標です。自作リーフには、「Leafony」 の名前を商品名称に付けることは、LEAFONY SYSTEMS株式会社の製品ラインナップと混同する可能性があり、市場が混乱しますので、お控え下さい。自作リーフまた はLeafonyの回路やレイアウトを使用した電子基板を「Leafony準拠」と表示して販売するのは自由です。\nその他 「Leafony」は、LEAFONY SYSTEMS株式会社の登録商標です。\n前のページに戻る\r","excerpt":"ソフトウェア トリリオンノード・エンジン・プロジェクト、あるいはトリリオンノード研究会が独自に開発し公開したソフトウェアはMITライセンスですので、自由に使用可能です。その他、Leafonyを使用する …","ref":"/docs/license/","title":"ライセンス"},{"body":"For inquiries about product technology and applications, please use the stack overflow Q\u0026amp;A site. When you post a question in the stack overflow, please make sure to include \u0026ldquo;Leafony\u0026rdquo; in the title. You must be a registered user to post on the stack overflow.\n stack overflow  Back to previous page\r","excerpt":"For inquiries about product technology and applications, please use the stack overflow Q\u0026amp;A site. …","ref":"/en/docs/contacts/","title":"Contacts"},{"body":" How the board works Board design procedure Design tools Parts selection Circuit design Layout design Spacing Manufacturing order Component mounting Test  Back to previous page\r","excerpt":" How the board works Board design procedure Design tools Parts selection Circuit design Layout …","ref":"/en/docs/pcb/pcb-tutorial/","title":"Board Development Tutorial"},{"body":"ESP32 Wi-Fi Kit/Kit 2は、Wi-FiとBluetooth内蔵のESP32-WROOM-32を搭載した乾電池やリチウムバッテリーで駆動可能な開発キットです。Wi-Fiでパソコンやスマートフォンにタッチセンサの値を送信することができるプログラムが、プレインストールされています。 また、単4形 アルカリ乾電池、リチウムイオン充電池対応の18650電池ホルダを各々ご用意しました。 18650電池ホルダを使用する場合は、こちらを参考にして下さい。\n用意するもの  ESP32 Wi-Fi Kit/Kit 2 パソコンやスマートフォン  使い方  ESP32 Wi-Fi Kit/Kit 2に単4電池3本入れ、電源スイッチをONにして下さい。\n パソコンやスマートフォンで周辺のWi-Fiを検索し、以下のSSIDのWi-Fiに接続します。  SSID: Leafony_ESP32-AP Password: password   Webブラウザを立ち上げて、以下のURLをアドレスバーに貼り付けてください。   http://192.168.4.1\r 29pin headerの7、9、22、24、26、28ピンがタッチセンサに割り当てられています。ただし、24ピンは、RTC\u0026amp;microSDと干渉しているため、サンプルスケッチでは非表示にしています。ピンに触れると静電容量が増えるため、値が減少します。閾値20以下になると”Touch detected”と表示される設定にしています。検出閾値は、スケッチで変更することが出来ます。\n   26ピンに触れると、以下のようにWebブラウザの表示が変化します。　   ESP32 Wi-Fi Kit/Kit 2のNut Plate部分にマグネットが付いているので、金属の壁などに取付られます。\n  ソースコードや動作の仕組みは、 Wi-Fi タッチセンサに記載されています。  次のステップ\rプログラミングのためのパソコンの設定の仕方は、開発環境設定に記載しています。\r\r前のページに戻る\r","excerpt":"ESP32 Wi-Fi Kit/Kit 2は、Wi-FiとBluetooth内蔵のESP32-WROOM-32を搭載した乾電池やリチウムバッテリーで駆動可能な開発キットです。Wi-Fiでパソコンやス …","ref":"/docs/getting-started/esp32/","title":"ESP32 Wi-Fi Kit/Kit 2 スタートガイド"},{"body":"製品の技術や応用に関するお問い合わせは、Q\u0026amp;Aサイトの スタック・オーバーフローをご利用下さい。 スタック・オーバーフローで質問を投稿する場合には、必ずタイトルに\u0026quot;leafony\u0026quot;を含めて記載して下さい。スタック・オーバーフローに投稿する場合にはユーザ登録が必要です。\n スタック・オーバーフロー  前のページに戻る\r","excerpt":"製品の技術や応用に関するお問い合わせは、Q\u0026amp;Aサイトの スタック・オーバーフローをご利用下さい。 スタック・オーバーフローで質問を投稿する場合には、必ずタイトル …","ref":"/docs/contacts/","title":"お問い合わせ"},{"body":" 基板の仕組み 基板の設計手順 設計ツール 部品選び 回路設計 レイアウト設計 面付け 製造発注 部品実装 テスト  前のページに戻る\r","excerpt":" 基板の仕組み 基板の設計手順 設計ツール 部品選び 回路設計 レイアウト設計 面付け 製造発注 部品実装 テスト  前のページに戻る\r","ref":"/docs/pcb/pcb-tutorial/","title":"基板開発チュートリアル"},{"body":"If you can\u0026rsquo;t find the serial port\u0026hellip; If you can\u0026rsquo;t find a Leafony serial port in the Arduino IDE, you can install a USB serial converter IC (FT232) driver. For more information, here.\nIf it doesn\u0026rsquo;t turn on\u0026hellip; If Leafony won\u0026rsquo;t turn on, you should check the following\n Is there enough remaining battery power? Is the button battery inserted in the correct direction? Is the power switch turned on? Are the connectors clean? If it is dirty, wipe it lightly with a paper rag moistened with anhydrous ethanol. If the problem persists, replace the connector. For more information, please visit here. Are the screws tight enough? Tighten the screws properly, alternately.\n  Back to previous page\r","excerpt":"If you can\u0026rsquo;t find the serial port\u0026hellip; If you can\u0026rsquo;t find a Leafony serial port in the …","ref":"/en/docs/getting-started/solution/","title":"If it doesn't work..."},{"body":"Follow these steps to set up your STM32 MCU development environment.\nNext\rInstall the software needed to write programs to Leafony\r\rWhat to prepare  STM32 MCU Leaf Basic Kit PC (Windows, Mac OS X or Linux)  Installing the Arduino IDE For instructions on how to install the Arduino IDE, please here.\nConnect to PC Connect it to your PC with a USB cable.\nConfiguration of the microcontroller board To use the STM32 MCU leaf with the Arduino IDE, the STM32 Cores must be installed. Please follow the steps below to configure the settings. (For more information about STM32 Cores, see here).\n Open the File → Preferences in the Arduino IDE and enter the following URL in the Additional Board Manager URL: field.  https://github.com/stm32duino/BoardManagerFiles/raw/master/STM32/package_stm_index.json\n\n Select Tools -\u0026gt; Board -\u0026gt; Board Manager, search for STM32 Cores and press the Install button.\n\n  Go to Tools → Board→ STM32 Boards (Selected from submenu)→ Nucleo-64 . \n  Go to Tools → Board part number: *****→ Nucleo L452RE . \n  Go to Tools → Upload method: ***** → STM32CubeProgrammer(Serial) . \n  Go to Tools → Serial Port and select the serial port to which Leafony is connected.   Installing the STM32CubeProg To be able to write programs to the STM32 MCU leaf, you need to install STM32CubeProg 1.The STM32CubeProg can be downloaded and installed on your PC here.\nChecking the operation of the microcontroller board   When the program switch on the STM32 MCU leaf is set to the program side, the LED will light up. \n  Next, refer to the sample application \u0026ldquo;Temperature and humidity sensor\u0026rdquo; and write the program. If it is written successfully, the message Start operation achieved successfully will be displayed.If it is not displayed 2, be careful. \n  When writing is complete, turn the STM32 MCU leaf\u0026rsquo;s Program switch to the Run side to turn off the LED.\n  Press the Reset switch on the STM32 MCU leaf.\n  Specifying pins for a sketch Since the pin layout of the STM32 MCU is different from that of the Nucleo L452RE, it is not possible to use names when specifying pins. For STM32 MCU leaf, specify pins by port (Port)。\n\nInstalling libraries To use some of the leaves, you will need to install additional libraries. Here to install all libraries in advance. However, you cannot use the timer interrupt library (MsTimer2.h) because it is an AVR MCU library. Please refer to the following HardwareTimer.\nHardwareTimer An example of use is given below. For more information here. Initialization\nHardwareTimer *timer2 = new HardwareTimer (TIM2); timer2-\u0026gt;setOverflow(LOOP_INTERVAL, MICROSEC_FORMAT); // 125ms  timer2-\u0026gt;attachInterrupt(intTimer); timer2-\u0026gt;resume(); Interrupt routine\nvoid intTimer(void){ bInterval = true; ： ： } When in doubt You can find the solution in \u0026ldquo;If it doesn\u0026rsquo;t work\u0026hellip;\u0026rdquo;.\nNext step\rSample app has several programs.\nTo make development easier, please install the library before you begin.\r\rBack to previous page\r  We have confirmed that V2.6.0 and V2.4.0 work on Windows 64bit. However, please note that V2.5.0 will not work. \u0026#x21a9;\u0026#xfe0e;\n When writing without the program switch on the program side, the message Writing to the board is complete is also displayed, but the bottom of the screen shows Timeout error occured while waiting for acknowledgement.  \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Follow these steps to set up your STM32 MCU development environment.\nNext\rInstall the software …","ref":"/en/docs/environment/stm32/arduino_ide/","title":"Arduino IDE settings for STM32 MCU"},{"body":"Overview An AD converter is mounted on the power supply leaf to monitor the battery voltage. It measures not only temperature, humidity, illumination, and tilt, but also battery voltage and displays it on the LCD.\nHow to compensate for temperature (or humidity) If there is a discrepancy between the temperature (or humidity) you want to display and the temperature (or humidity) of the 4-Sensors, perform the correction between the two points. For details, see here.\n\nLeaf to use    Type Name Q\u0026rsquo;ty     AI04 LCD 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AZ01 USB 1   AX03 Leaf×2 1   AV01 CR2032 1   AZ62 Connector Cover 2   AZ63 Nut Plate 1    CR2032 coin cell battery 1    M2*15mm screw 4    Assembly Source code  4-Sensors, LCD, and AVR MCU library(timer interrupt) are required for writing. Please include the libraries beforehand. For details, see here. In the Arduino IDE, write the following sketch on the microcontroller board.  //===================================================================== // Leafony Platform sample sketch // Application : 4-Sensors with LCD // Processor : ATmega328P (3.3V /8MHz) // Arduino IDE : 1.8.13 // // Leaf configuration // (1) AI01 4-Sensors // (2) AI04 LCD // (3) AP01 AVR MCU // (4) AZ01 USB // //\t(c)2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/20 First release // Rev.01 2020/07/29 不要部分削除等体裁修正 //===================================================================== // use libraries // Adafruit Unified Sensor Driver // https://github.com/adafruit/Adafruit_Sensor // Adafruit Bus IO Library // https://github.com/adafruit/Adafruit_BusIO // Adafruit LIS3DH // https://github.com/adafruit/Adafruit_LIS3DH // SmartEverything ST HTS221 Humidity Sensor // https://github.com/ameltech/sme-hts221-library // ClosedCube Arduino Library for ClosedCube OPT3001 // https://github.com/closedcube/ClosedCube_OPT3001_Arduino // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;MsTimer2.h\u0026gt; // Timer#include \u0026lt;Wire.h\u0026gt; // I2C #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; // 3-axis accelerometer#include \u0026lt;HTS221.h\u0026gt; // humidity and temperature sensor#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; // Ambient Light Sensor#include \u0026lt;ST7032.h\u0026gt; // LCD //=====================================================================  //=============================================== // シリアルモニタへの出力 // #define SERIAL_MONITOR = 出力あり //\t//#define SERIAL_MONITOR = 出力なし（コメントアウトする） //=============================================== #define SERIAL_MONITOR  //----------------------------------------------- // IOピン一覧 //----------------------------------------------- // D0 0 // PD0 (RXD) // D1 1 // PD1 (TXD) // D2 2 // PD2 (INT0) // D3 3 // PD3 (INT1) // D4 4 // PD4 // D5 5 // PD5 // D6 6 // PD6 // D7 7 // PD7 // D8 8 // PB0 (S-UART2_RX) // D9 9 // PB1 (S-UART2_TX) // D10 10 // PB2 (SS) // D11 11 // PB3 (MOSI) // D12 12 // PB4 (MISO) // D13 13 // PB5 (SCK/LED)  // D14 14 // [A0] PC0 // D15 15 // [A1] PC1 // D16 16 // [A2] PC2 // D17 17 // [A3] PC3  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- //------------------------------ // I2Cアドレス //------------------------------ #define LIS2DH_ADDRESS 0x19 // Accelerometer (SD0/SA0 pin = VCC) #define OPT3001_ADDRESS 0x45 // Ambient Light Sensor (ADDR pin = VCC) #define LCD_I2C_EXPANDER_ADDR 0x1A // LCD I2C Expander #define BATT_ADC_ADDR 0x50 // Battery ADC  //----------------------------------------------- // loop interval // MsTimer2のタイマー割り込み発生間隔(ms) //----------------------------------------------- #define LOOP_INTERVAL 125 // 125ms interval  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------  ST7032 lcd; //------------------------------ // Sensor //------------------------------ Adafruit_LIS3DH accel = Adafruit_LIS3DH(); ClosedCube_OPT3001 light; //--------------------------------------------------------------------- // プログラムで使用する変数定義 //--------------------------------------------------------------------- //--------------------------- // LCD //--------------------------- int8_t lcdSendCount = 0; //------------------------------ // Loop counter //------------------------------ uint8_t iLoop1s = 0; //------------------------------ // Event //------------------------------ bool event1s = false; //------------------------------ // interval Timer interrupt //------------------------------ volatile bool bInterval = false; //------------------------------ // LIS2DH : Accelerometer //------------------------------ float dataX_g, dataY_g, dataZ_g; float dataTilt; //------------------------------ // HTS221 : Humidity and Temperature sensor //------------------------------ float dataTemp; float dataHumid; //-------------------- // 2点補正用データ //-------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  //------------------------------ // OPT3001 : Ambient Light Sensor //------------------------------ float dataLight; //--------------------------- // Battery //--------------------------- float dataBatt = 0; //===================================================================== // setup //===================================================================== void setup(){ Wire.begin(); // I2C 100kHz #ifdef SERIAL_MONITOR  Serial.begin(115200); // UART 115200bps  Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;setup start\u0026#34;); #endif  i2c_write_byte(LCD_I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(LCD_I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD 電源ON  // LCD設定  lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;NOW\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;BOOTING!\u0026#34;); setupPort(); delay(10); noInterrupts(); setupTCInt(); interrupts(); setupSensor(); MsTimer2::start(); // Timer inverval start  #ifdef SERIAL_MONITOR  Serial.println(\u0026#34;\u0026#34;); Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;loop start\u0026#34;); Serial.println(\u0026#34;\u0026#34;); #endif } //----------------------------------------------- // IOピンの入出力設定 // 接続するリーフに合わせて設定する //----------------------------------------------- void setupPort(){ } //--------------------------------------------------------------------- // 各デバイスの初期設定 //--------------------------------------------------------------------- //------------------------------ // Sensor //------------------------------ void setupSensor(){ //-------------------------------------  // LIS2DH (accelerometer)  //-------------------------------------  accel.begin(LIS2DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  //-------------------------------------  // HTS221 (Humidity and Temperature sensor)  //-------------------------------------  smeHumidity.begin(); //-------------------------------------  // OPT3001 (Ambient Light Sensor)  //-------------------------------------  OPT3001_Config newConfig; OPT3001_ErrorCode errorConfig; light.begin(OPT3001_ADDRESS); // I2C address  newConfig.RangeNumber = B1100; // automatic full scale  newConfig.ConvertionTime = B1; // convertion time = 800ms  newConfig.ModeOfConversionOperation = B11; // continous conversion  newConfig.Latch = B0; // hysteresis-style  errorConfig = light.writeConfig(newConfig); if(errorConfig != NO_ERROR){ errorConfig = light.writeConfig(newConfig); //retry  } } //===================================================================== // 割り込み処理 //===================================================================== //----------------------------------------------- // 割り込み処理初期設定 // Timer interrupt (interval=125ms, int=overflow) // メインループのタイマー割り込み設定 //----------------------------------------------- void setupTCInt(){ MsTimer2::set(LOOP_INTERVAL, intTimer); } //---------------------------------------------- // Timer INT // タイマー割り込み関数 //---------------------------------------------- void intTimer(){ bInterval = true; } //==================================================================== // loop //==================================================================== //--------------------------------------------------------------------- // Main loop //--------------------------------------------------------------------- void loop(){ //-----------------------------------------------------  // Timer interval　125ms で1回ループ  //-----------------------------------------------------  if (bInterval == true){ bInterval = false; //--------------------------------------------  loopCounter(); // loop counter  //--------------------------------------------  // 1sに1回実行する  //--------------------------------------------  if (event1s == true){ event1s = false; // initialize parameter  loopSensor(); // sensor read  dispSencerData(); // LCD  } } } //--------------------------------------------------------------------- // Counter // メインループのループ回数をカウントし // 1秒間隔でセンサーデータの取得をONにする //--------------------------------------------------------------------- void loopCounter(){ iLoop1s += 1; //--------------------  // 1s period  //--------------------  if (iLoop1s \u0026gt;= 8){ // 125ms x 8 = 1s  iLoop1s = 0; event1s = true; } } //--------------------------------------------------------------------- // Sensor // センサーデータ取得がONのとき、各センサーからデータを取得 // コンソール出力がONのときシリアルに測定値と計算結果を出力する //--------------------------------------------------------------------- void loopSensor(){ double temp_mv; //-------------------------  // LIS2DH  // 3軸センサーのデータ取得  //-------------------------  accel.read(); dataX_g = accel.x_g; //X軸  dataY_g = accel.y_g; //Y軸  dataZ_g = accel.z_g; //Z軸  if(dataZ_g \u0026gt;= 1.0){ dataZ_g = 1.00; } else if (dataZ_g \u0026lt;= -1.0){ dataZ_g = -1.00; } dataTilt = acos(dataZ_g)/PI*180; //-------------------------  // HTS221  // 温湿度センサーデータ取得  //-------------------------  dataTemp = (float)smeHumidity.readTemperature(); //温度  dataHumid = (float)smeHumidity.readHumidity(); //湿度  //-------------------------  // 温度と湿度の2点補正  //-------------------------  dataTemp=TM0+(TM1-TM0)*(dataTemp-TL0)/(TL1-TL0); // 温度補正  dataHumid=HM0+(HM1-HM0)*(dataHumid-HL0)/(HL1-HL0); // 湿度補正  //-------------------------  // OPT3001  // 照度センサーデータ取得  //-------------------------  OPT3001 result = light.readResult(); if(result.error == NO_ERROR){ dataLight = result.lux; } //-------------------------  // ADC081C027（ADC)  // 電池リーフ電池電圧取得  //-------------------------  uint8_t adcVal1 = 0; uint8_t adcVal2 = 0; Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); adcVal1 = Wire.read(); adcVal2 = Wire.read(); if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { //測定値がFFならバッテリリーフはつながっていない  adcVal1 = adcVal2 = 0; } //電圧計算　ADC　* （(リファレンス電圧(3.3V)/ ADCの分解能(256)) * 分圧比（２倍））  temp_mv = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; dataBatt = (float)(temp_mv / 1000); //-------------------------  // シリアルモニタ表示  //------------------------- #ifdef SERIAL_MONITOR  Serial.println(\u0026#34;--- sensor data ---\u0026#34;); Serial.println(\u0026#34; Tmp[degC] = \u0026#34; + String(dataTemp)); Serial.println(\u0026#34; Hum[%] = \u0026#34; + String(dataHumid)); Serial.println(\u0026#34; Lum[lx] = \u0026#34; + String(dataLight)); Serial.println(\u0026#34; Ang[arc deg] = \u0026#34; + String(dataTilt)); Serial.println(\u0026#34; Bat[V] = \u0026#34; + String(dataBatt)); #endif } //--------------------------------------- // Disp sensor data // センサーデータを文字列に変換してLCDに表示する //--------------------------------------- void dispSencerData(){ float value; char temp[7], humid[7], light[7], tilt[7], battVolt[7]; char sendData[40]; //-----------------------------------  //センサーデータを文字列に変換  //dtostrf(変換する数字,変換される文字数,小数点以下の桁数,変換した文字の格納先);  //変換される文字数を-にすると変換される文字は左詰め、+なら右詰めとなる  //-----------------------------------  //-------------------------  // Temperature (4Byte)  //-------------------------  value = dataTemp; if(value \u0026gt;= 100){ value = 99.9; } else if(value \u0026lt;= -10){ value = -9.9; } dtostrf(value,4,1,temp); //-------------------------  // Humidity (4Byte)  //-------------------------  value = dataHumid; dtostrf(value,4,1,humid); //-------------------------  // Ambient Light (5Byte)  //-------------------------  value = dataLight; if(value \u0026gt;= 100000){ value = 99999; } dtostrf(value,5,0,light); //-------------------------  // Tilt (4Byte)  //-------------------------  value = dataTilt; if(value \u0026lt; 3){ value = 0; } dtostrf(value,4,0,tilt); //-------------------------  // Battery Voltage (4Byte)  //-------------------------  value = dataBatt; if (value \u0026gt;= 10){ value = 9.99; } dtostrf(value, 4, 2, battVolt); //-------------------------  trim(temp); trim(humid); trim(light); trim(tilt); trim(battVolt); lcd.clear(); switch (lcdSendCount){ case 0: // Tmp XX.X [degC]  lcd.print(\u0026#34;Temp\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(temp) +\u0026#34; C\u0026#34;); break; case 1: // Hum xx.x [%]  lcd.print(\u0026#34;Humidity\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(humid) +\u0026#34; %\u0026#34;); break; case 2: // Lum XXXXX [lx]  lcd.print(\u0026#34;Luminous\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(light) +\u0026#34; lx\u0026#34;); break; case 3: // Ang XXXX [arc deg]  lcd.print(\u0026#34;Angle\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(tilt) +\u0026#34; deg\u0026#34;); break; case 4: // Bat X.XX [V]  lcd.print(\u0026#34;Battery\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(battVolt) +\u0026#34; V\u0026#34;); break; default: break; } if (lcdSendCount \u0026lt; 4){ lcdSendCount++; } else{ lcdSendCount = 0; } } //--------------------------------------- // trim // 文字列配列からSPを削除する //--------------------------------------- void trim(char * data){ int i = 0, j = 0; while (*(data + i) != \u0026#39;\\0\u0026#39;){ if (*(data + i) != \u0026#39; \u0026#39;){ *(data + j) = *(data + i); j++; } i++; } *(data + j) = \u0026#39;\\0\u0026#39;; } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- //I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } 4-Sensors_LCD.ino\nExecution Results The LCD display changes in the following order: Temperature → Humidity → Illuminance → Angle → Remaining battery charge.\nBack to previous page\r","excerpt":"Overview An AD converter is mounted on the power supply leaf to monitor the battery voltage. It …","ref":"/en/docs/examples/advanced/1_p/exten/4-sensors_lcd/","title":"4-sensors LCD"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/examples/beginner/1_p/basic/","title":"Basic Kit"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/examples/beginner/3_p/basic/","title":"STM32 MCU + Basic Kit"},{"body":"概要 電源リーフには、電池電圧をモニタするためのADコンバータを実装。温度、湿度、照度、傾きだけでなく、電池電圧も測定し、LCDに表示させます。\n温度（または、湿度）の補正の仕方 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。詳しくは、こちら。\n\n使用するリーフ    Type Name Q\u0026rsquo;ty     AI04 LCD 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AZ01 USB 1   AX03 Leaf×2 1   AV01 CR2032 1   AZ62 Connector Cover 2   AZ63 Nut Plate 1    CR2032 coin cell battery 1    M2*15mm screw 4    リーフの組立 ソースコード  書き込みには、4-Sensors、LCD、AVR MCUライブラリ（タイマ割り込み）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで、以下のスケッチをマイコンボードに書き込んでください。  //===================================================================== // Leafony Platform sample sketch // Application : 4-Sensors with LCD // Processor : ATmega328P (3.3V /8MHz) // Arduino IDE : 1.8.13 // // Leaf configuration // (1) AI01 4-Sensors // (2) AI04 LCD // (3) AP01 AVR MCU // (4) AZ01 USB // //\t(c)2021 LEAFONY SYSTEMS Co., Ltd //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT //　// Rev.00 2021/04/01 First release // //===================================================================== // use libraries // Adafruit Unified Sensor Driver // https://github.com/adafruit/Adafruit_Sensor // Adafruit Bus IO Library // https://github.com/adafruit/Adafruit_BusIO // Adafruit LIS3DH // https://github.com/adafruit/Adafruit_LIS3DH // SmartEverything ST HTS221 Humidity Sensor // https://github.com/ameltech/sme-hts221-library // ClosedCube Arduino Library for ClosedCube OPT3001 // https://github.com/closedcube/ClosedCube_OPT3001_Arduino // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;MsTimer2.h\u0026gt; // Timer#include \u0026lt;Wire.h\u0026gt; // I2C #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; // 3-axis accelerometer#include \u0026lt;HTS221.h\u0026gt; // humidity and temperature sensor#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; // Ambient Light Sensor#include \u0026lt;ST7032.h\u0026gt; // LCD //=====================================================================  //=============================================== // シリアルモニタへの出力 // #define SERIAL_MONITOR = 出力あり //\t//#define SERIAL_MONITOR = 出力なし（コメントアウトする） //=============================================== #define SERIAL_MONITOR  //----------------------------------------------- // IOピン一覧 //----------------------------------------------- // D0 0 // PD0 (RXD) // D1 1 // PD1 (TXD) // D2 2 // PD2 (INT0) // D3 3 // PD3 (INT1) // D4 4 // PD4 // D5 5 // PD5 // D6 6 // PD6 // D7 7 // PD7 // D8 8 // PB0 (S-UART2_RX) // D9 9 // PB1 (S-UART2_TX) // D10 10 // PB2 (SS) // D11 11 // PB3 (MOSI) // D12 12 // PB4 (MISO) // D13 13 // PB5 (SCK/LED)  // D14 14 // [A0] PC0 // D15 15 // [A1] PC1 // D16 16 // [A2] PC2 // D17 17 // [A3] PC3  //----------------------------------------------- // プログラム内で使用する定数定義 //----------------------------------------------- //------------------------------ // I2Cアドレス //------------------------------ #define LIS2DH_ADDRESS 0x19 // Accelerometer (SD0/SA0 pin = VCC) #define OPT3001_ADDRESS 0x45 // Ambient Light Sensor (ADDR pin = VCC) #define LCD_I2C_EXPANDER_ADDR 0x1A // LCD I2C Expander #define BATT_ADC_ADDR 0x50 // Battery ADC  //----------------------------------------------- // loop interval // MsTimer2のタイマー割り込み発生間隔(ms) //----------------------------------------------- #define LOOP_INTERVAL 125 // 125ms interval  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------  ST7032 lcd; //------------------------------ // Sensor //------------------------------ Adafruit_LIS3DH accel = Adafruit_LIS3DH(); ClosedCube_OPT3001 light; //--------------------------------------------------------------------- // プログラムで使用する変数定義 //--------------------------------------------------------------------- //--------------------------- // LCD //--------------------------- int8_t lcdSendCount = 0; //------------------------------ // Loop counter //------------------------------ uint8_t iLoop1s = 0; //------------------------------ // Event //------------------------------ bool event1s = false; //------------------------------ // interval Timer interrupt //------------------------------ volatile bool bInterval = false; //------------------------------ // LIS2DH : Accelerometer //------------------------------ float dataX_g, dataY_g, dataZ_g; float dataTilt; //------------------------------ // HTS221 : Humidity and Temperature sensor //------------------------------ float dataTemp; float dataHumid; //-------------------- // 2点補正用データ //-------------------- // 温度補正用データ0 float TL0 = 25.0; // 4-Sensors温度測定値 float TM0 = 25.0; // 温度計等測定値 // 温度補正用データ1 float TL1 = 40.0; // 4-Sensors温度測定値 float TM1 = 40.0; // 温度計等測定値  // 湿度補正用データ0 float HL0 = 60.0; // 4-Sensors湿度測定値 float HM0 = 60.0; // 湿度計等測定値 // 湿度補正用データ1 float HL1 = 80.0; // 4-Sensors湿度測定値 float HM1 = 80.0; // 湿度計等測定値  //------------------------------ // OPT3001 : Ambient Light Sensor //------------------------------ float dataLight; //--------------------------- // Battery //--------------------------- float dataBatt = 0; //===================================================================== // setup //===================================================================== void setup(){ Wire.begin(); // I2C 100kHz #ifdef SERIAL_MONITOR  Serial.begin(115200); // UART 115200bps  Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;setup start\u0026#34;); #endif  i2c_write_byte(LCD_I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(LCD_I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD 電源ON  // LCD設定  lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;NOW\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;BOOTING!\u0026#34;); setupPort(); delay(10); noInterrupts(); setupTCInt(); interrupts(); setupSensor(); MsTimer2::start(); // Timer inverval start  #ifdef SERIAL_MONITOR  Serial.println(\u0026#34;\u0026#34;); Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;loop start\u0026#34;); Serial.println(\u0026#34;\u0026#34;); #endif } //----------------------------------------------- // IOピンの入出力設定 // 接続するリーフに合わせて設定する //----------------------------------------------- void setupPort(){ } //--------------------------------------------------------------------- // 各デバイスの初期設定 //--------------------------------------------------------------------- //------------------------------ // Sensor //------------------------------ void setupSensor(){ //-------------------------------------  // LIS2DH (accelerometer)  //-------------------------------------  accel.begin(LIS2DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  //-------------------------------------  // HTS221 (Humidity and Temperature sensor)  //-------------------------------------  smeHumidity.begin(); //-------------------------------------  // OPT3001 (Ambient Light Sensor)  //-------------------------------------  OPT3001_Config newConfig; OPT3001_ErrorCode errorConfig; light.begin(OPT3001_ADDRESS); // I2C address  newConfig.RangeNumber = B1100; // automatic full scale  newConfig.ConvertionTime = B1; // convertion time = 800ms  newConfig.ModeOfConversionOperation = B11; // continous conversion  newConfig.Latch = B0; // hysteresis-style  errorConfig = light.writeConfig(newConfig); if(errorConfig != NO_ERROR){ errorConfig = light.writeConfig(newConfig); //retry  } } //===================================================================== // 割り込み処理 //===================================================================== //----------------------------------------------- // 割り込み処理初期設定 // Timer interrupt (interval=125ms, int=overflow) // メインループのタイマー割り込み設定 //----------------------------------------------- void setupTCInt(){ MsTimer2::set(LOOP_INTERVAL, intTimer); } //---------------------------------------------- // Timer INT // タイマー割り込み関数 //---------------------------------------------- void intTimer(){ bInterval = true; } //==================================================================== // loop //==================================================================== //--------------------------------------------------------------------- // Main loop //--------------------------------------------------------------------- void loop(){ //-----------------------------------------------------  // Timer interval　125ms で1回ループ  //-----------------------------------------------------  if (bInterval == true){ bInterval = false; //--------------------------------------------  loopCounter(); // loop counter  //--------------------------------------------  // 1sに1回実行する  //--------------------------------------------  if (event1s == true){ event1s = false; // initialize parameter  loopSensor(); // sensor read  dispSencerData(); // LCD  } } } //--------------------------------------------------------------------- // Counter // メインループのループ回数をカウントし // 1秒間隔でセンサーデータの取得をONにする //--------------------------------------------------------------------- void loopCounter(){ iLoop1s += 1; //--------------------  // 1s period  //--------------------  if (iLoop1s \u0026gt;= 8){ // 125ms x 8 = 1s  iLoop1s = 0; event1s = true; } } //--------------------------------------------------------------------- // Sensor // センサーデータ取得がONのとき、各センサーからデータを取得 // コンソール出力がONのときシリアルに測定値と計算結果を出力する //--------------------------------------------------------------------- void loopSensor(){ double temp_mv; //-------------------------  // LIS2DH  // 3軸センサーのデータ取得  //-------------------------  accel.read(); dataX_g = accel.x_g; //X軸  dataY_g = accel.y_g; //Y軸  dataZ_g = accel.z_g; //Z軸  if(dataZ_g \u0026gt;= 1.0){ dataZ_g = 1.00; } else if (dataZ_g \u0026lt;= -1.0){ dataZ_g = -1.00; } dataTilt = acos(dataZ_g)/PI*180; //-------------------------  // HTS221  // 温湿度センサーデータ取得  //-------------------------  dataTemp = (float)smeHumidity.readTemperature(); //温度  dataHumid = (float)smeHumidity.readHumidity(); //湿度  //-------------------------  // 温度と湿度の2点補正  //-------------------------  dataTemp=TM0+(TM1-TM0)*(dataTemp-TL0)/(TL1-TL0); // 温度補正  dataHumid=HM0+(HM1-HM0)*(dataHumid-HL0)/(HL1-HL0); // 湿度補正  //-------------------------  // OPT3001  // 照度センサーデータ取得  //-------------------------  OPT3001 result = light.readResult(); if(result.error == NO_ERROR){ dataLight = result.lux; } //-------------------------  // ADC081C027（ADC)  // 電池リーフ電池電圧取得  //-------------------------  uint8_t adcVal1 = 0; uint8_t adcVal2 = 0; Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); adcVal1 = Wire.read(); adcVal2 = Wire.read(); if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { //測定値がFFならバッテリリーフはつながっていない  adcVal1 = adcVal2 = 0; } //電圧計算　ADC　* （(リファレンス電圧(3.3V)/ ADCの分解能(256)) * 分圧比（２倍））  temp_mv = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; dataBatt = (float)(temp_mv / 1000); //-------------------------  // シリアルモニタ表示  //------------------------- #ifdef SERIAL_MONITOR  Serial.println(\u0026#34;--- sensor data ---\u0026#34;); Serial.println(\u0026#34; Tmp[degC] = \u0026#34; + String(dataTemp)); Serial.println(\u0026#34; Hum[%] = \u0026#34; + String(dataHumid)); Serial.println(\u0026#34; Lum[lx] = \u0026#34; + String(dataLight)); Serial.println(\u0026#34; Ang[arc deg] = \u0026#34; + String(dataTilt)); Serial.println(\u0026#34; Bat[V] = \u0026#34; + String(dataBatt)); #endif } //--------------------------------------- // Disp sensor data // センサーデータを文字列に変換してLCDに表示する //--------------------------------------- void dispSencerData(){ float value; char temp[7], humid[7], light[7], tilt[7], battVolt[7]; char sendData[40]; //-----------------------------------  //センサーデータを文字列に変換  //dtostrf(変換する数字,変換される文字数,小数点以下の桁数,変換した文字の格納先);  //変換される文字数を-にすると変換される文字は左詰め、+なら右詰めとなる  //-----------------------------------  //-------------------------  // Temperature (4Byte)  //-------------------------  value = dataTemp; if(value \u0026gt;= 100){ value = 99.9; } else if(value \u0026lt;= -10){ value = -9.9; } dtostrf(value,4,1,temp); //-------------------------  // Humidity (4Byte)  //-------------------------  value = dataHumid; dtostrf(value,4,1,humid); //-------------------------  // Ambient Light (5Byte)  //-------------------------  value = dataLight; if(value \u0026gt;= 100000){ value = 99999; } dtostrf(value,5,0,light); //-------------------------  // Tilt (4Byte)  //-------------------------  value = dataTilt; if(value \u0026lt; 3){ value = 0; } dtostrf(value,4,0,tilt); //-------------------------  // Battery Voltage (4Byte)  //-------------------------  value = dataBatt; if (value \u0026gt;= 10){ value = 9.99; } dtostrf(value, 4, 2, battVolt); //-------------------------  trim(temp); trim(humid); trim(light); trim(tilt); trim(battVolt); lcd.clear(); switch (lcdSendCount){ case 0: // Tmp XX.X [degC]  lcd.print(\u0026#34;Temp\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(temp) +\u0026#34; C\u0026#34;); break; case 1: // Hum xx.x [%]  lcd.print(\u0026#34;Humidity\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(humid) +\u0026#34; %\u0026#34;); break; case 2: // Lum XXXXX [lx]  lcd.print(\u0026#34;Luminous\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(light) +\u0026#34; lx\u0026#34;); break; case 3: // Ang XXXX [arc deg]  lcd.print(\u0026#34;Angle\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(tilt) +\u0026#34; deg\u0026#34;); break; case 4: // Bat X.XX [V]  lcd.print(\u0026#34;Battery\u0026#34;); lcd.setCursor(0, 1); lcd.print( String(battVolt) +\u0026#34; V\u0026#34;); break; default: break; } if (lcdSendCount \u0026lt; 4){ lcdSendCount++; } else{ lcdSendCount = 0; } } //--------------------------------------- // trim // 文字列配列からSPを削除する //--------------------------------------- void trim(char * data){ int i = 0, j = 0; while (*(data + i) != \u0026#39;\\0\u0026#39;){ if (*(data + i) != \u0026#39; \u0026#39;){ *(data + j) = *(data + i); j++; } i++; } *(data + j) = \u0026#39;\\0\u0026#39;; } //===================================================================== // I2C　制御関数 //===================================================================== //----------------------------------------------- //I2C スレーブデバイスに1バイト書き込む //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C スレーブデバイスから1バイト読み込む //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } 4-Sensors_LCD.ino\n実行結果 温度 → 湿度 → 照度 → 角度 → バッテリ残量の順に液晶の表示が変わります。\n前のページに戻る\r","excerpt":"概要 電源リーフには、電池電圧をモニタするためのADコンバータを実装。温度、湿度、照度、傾きだけでなく、電池電圧も測定し、LCDに表示させます。\n温度（または、湿度）の補正の仕方 表示させたい温度（ま …","ref":"/docs/examples/advanced/1_p/exten/4-sensors_lcd/","title":"センサの値をLCDに表示"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/1_p/basic/","title":"Basic Kit 2"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/3_p/basic/","title":"Basic Kit 2"},{"body":"  \nFeatures This leaf is equipped with a temperature/humidity sensor, an illuminance sensor and an acceleration sensor and is connected to the MCU leaf via I2C.\nSpecification Dimension    Item Description     Dimension  W23×D20.5×H4.7mm    Temperature/Humidity Sensor    Item Description     Part number HTS221TR   Relative Temperature range -40～120℃   Temperature accuracy ±0.5°C (15 to +40°C)   Relative humidity range 0 to 100%   Humidity accuracy 3.5% rH (20 to +80% rH)   Interfaces I2C(Address: 0x5F)    Illuminance Sensor    Item Description     Part number OPT3001   Measurement range 0.01 lux to 83 k lux   IR Rejects \u0026gt; 99% (typ)   Interfaces I2C(Address: 0x44 or 0x45)    Acceleration Sensor    Item Description     Part number LIS2DHTR   Measurement range ±2g/±4g/±8g/±16g (selectable)   Function 6D/4D orientation detection   Freefall detection    Motion detection    Interfaces I2C(Address: 0x49)    Block diagram \nPinassign \nSample App AVR MCU Examples  Temp Humid Sensor Illuminance Sensor Accelerometer Sensor Web Bluetooth IoT Google sheets IoT 4-sensors LCD  ESP32 MCU Examples  Temp/Humid Sensor Illuminance Sensor Accelerometer Sensor  Library Libraries are available for this leaf. Please install the necessary libraries from Environment to use them.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features This leaf is equipped with a temperature/humidity sensor, an illuminance sensor and an …","ref":"/en/docs/leaf/io/ai01/","title":"AI01 4-Sensors"},{"body":"  \n特徴 温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\n性能 外形サイズ    Item Description     Dimension  W23×D20.5×H4.7mm    温湿度センサ    Item Description     Part number HTS221TR   Relative Temperature range -40～120℃   Temperature accuracy ±0.5°C (15 to +40°C)   Relative humidity range 0 to 100%   Humidity accuracy 3.5% rH (20 to +80% rH)   Interfaces I2C(Address: 0x5F)    照度センサ    Item Description     Part number OPT3001   Measurement range 0.01 lux to 83 k lux   IR Rejects \u0026gt; 99% (typ)   Interfaces I2C(Address: 0x44 or 0x45)    加速度センサ    Item Description     Part number LIS2DHTR   Measurement range ±2g/±4g/±8g/±16g (selectable)   Function 6D/4D orientation detection   Freefall detection    Motion detection    Interfaces I2C(Address: 0x49)    ブロック図 \nピン配置 \nサンプルアプリ AVR MCU Examples  温湿度センサ読み取り 照度センサ読み取り 加速度センサ読み取り Web Bluetoothを使ったIoTアプリ入門 Google sheetsを使ったIoTサービス入門 センサの値をLCDに表示  ESP32 MCU Examples  温湿度センサ読み取り 照度センサ読み取り 加速度センサ読み取り  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールして利用して下さい\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"特徴 温湿度センサ、照度センサ、加速度センサを搭載したリーフです。MCUリーフとはI2Cで接続されます。\n性能 外形サイズ    Item Description     Dimension …","ref":"/docs/leaf/io/ai01/","title":"AI01 4-Sensors"},{"body":"  \nFeatures Leaf using the ATmega328P, with 14 digital input and output pins (six of which can be used as PWM outputs), six analog input pins, an 8 MHz oscillator, and a reset button. Connect USB if you are using USB or Shield if you are using ICSP. When using the Arduino IDE, select the Arduino Pro or Pro Mini board and the ATmega328P (3.3V, 8MHz) processor.\nSpecification    Item Description     Part number ATmega328P   Operating voltage 3.3V   Input voltage 1.5-5V   Digital I/O 14   Analog input 6   Flash memory 32 KB   SRAM 2KB   EEPROM 1KB   Clock speed 8MHz   Dimension W23×D20.5×H4.7mm    Block diagram \nPinassign \nTips About LEDs and switches \n   Item Description     Reset switch Reset microcontroller or other devices   LED Control LED by using pin 13 (Same as Arduino UNO)    Sample App  Blink  How to use it with Arduino In order to use this leaf with Arduino, the board must be configured on the Arduino IDE.\nPlease refer to Environment for instructions.\nDocuments  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing Bootloader  Revision history　  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features Leaf using the ATmega328P, with 14 digital input and output pins (six of which can be used …","ref":"/en/docs/leaf/processor/ap01/","title":"AP01 AVR MCU"},{"body":"  \n特徴 ATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。 USB接続する場合はUSB を接続、ICSPを使用する場合はShield を接続します。 Arduino IDE使用時は、ボードをArduino Pro or Pro Mini、プロセッサをATmega328P(3.3V,8MHz)選択。\n性能    Item Description     Part number ATmega328P   Operating voltage 3.3V   Input voltage 1.5-5V   Digital I/O 14   Analog input 6   ADC 10bit   Flash memory 32 KB   SRAM 2KB   EEPROM 1KB   Clock speed 8MHz   Arduino IDE Board Settings Board: \u0026ldquo;Arduino Pro or Pro Mini\u0026rdquo;    Processor: \u0026ldquo;ATmega328P (3.3V,8MHz)\u0026rdquo;   Dimension W23×D20.5×H4.7mm    ブロック図 \nピン配置 \nTips LED、スイッチについて \n   Item Description     Reset switch Reset microcontroller or other devices   LED Control LED by using pin 13 (Same as Arduino UNO)    サンプルアプリ  LED点滅  Arduinoでの使用方法 本リーフをArduinoで使用するためには、Arduino IDE上でボードの設定が必要です。\n開発環境設定のページで設定方法をご確認下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面 ブートローダ  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"特徴 ATmega328Pを使用したリーフ。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。 USB接続する場 …","ref":"/docs/leaf/processor/ap01/","title":"AP01 AVR MCU"},{"body":"A simple list of sample apps.\nBack to previous page\r","excerpt":"A simple list of sample apps.\nBack to previous page\r","ref":"/en/docs/examples/beginner/","title":"Beginner Examples"},{"body":"簡単なサンプルアプリの一覧です。\n前のページに戻る\r","excerpt":"簡単なサンプルアプリの一覧です。\n前のページに戻る\r","ref":"/docs/examples/beginner/","title":"Beginner Examples"},{"body":"  \n特徴 Silicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証は、CE、FCC、ISED Canada、TELEC、KC South-Korea、NCC Taiwanを取得（SLICON LABS Module Data Sheet　Revision 1.2)。\n性能    Item Description     Part number BGM11S22F256GA-V2   SoC EFR32BG1 (ARM Cortex-M4)   Bluetooth version 4.2   Frequency range 2400M ~ 2483.5MHz   RX sensitivity -90 dBm @ 1 Mbit/s GFSK   TX power +8dBm以下   RF certification CE, full FCC, ISED Canada, Japan and South-Korea   Flash 256KB   RAM 32KB   Interfaces UART   Dimension W23×D20.5×H4.7mm     ブロック図 \nピン配置 \nサンプルアプリ  Simple BLE Characteristic (公開予定) Simple BLE Advertisement (公開予定） Web Bluetooth を使ってセンサの値を表示  Google Sheetsを使ったIoTサービス入門  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールしてご利用下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"特徴 Silicon Labsの技的認証済みBLEモジュールBGM11S22F256GA-V2を搭載したリーフです。MCUリーフとはUARTで接続されます。無線の認証は、CE、FCC、ISED …","ref":"/docs/leaf/communication/ac02/","title":"AC02 BLE Sugar"},{"body":"\nOverview A set of ten connectors for the Leafony platform.\nContents    Type Item Q’ty     AZ61 Connector 10    List \rAZ61 Connector\r\rThe Leafony Platform is based on ACRs (Anisotropic Conductive Rubber), which is an insulating silicone rubber with metal or conductive elastomeric conductive elements arranged at a narrow pitch, which can be compressed to create an electrical connection.\n\r\r\rRevision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Overview A set of ten connectors for the Leafony platform.\nContents    Type Item Q’ty     AZ61 …","ref":"/en/docs/products/conn/","title":"Connector"},{"body":"  --\r概要 人気のESP32マイコンをベースとしたWi-Fi無線通信、microSD、リアルタイムクロック機能が入ったキットです。Basic Kitより少しサイズが大きく、消費電力も大きくなっていますが、断然高性能です。コイン電池では動作しませんが、少し大きめの電池で動きます。そのままで、スマートフォンやパソコンにWi-Fiを使ってタッチセンサの値を送信し、簡単に表示できます。単4形 アルカリ乾電池、リチウムイオン充電池対応の18650電池ホルダを各々ご用意しました。\n18650電池のご購入時の注意 ESP32 Kit 2の18650電池ホルダには、「保護回路なし」の18650電池を使用して下さい。「保護回路付き」の18650電池は、長さ65mmよりも若干長く、統一していないため、市販の電池ホルダが用意されていません。Leafonyは、電池リーフに電流制限が付いているため、「保護回路なし」を選択しています。「保護回路なし」の18650電池は、以下から購入することが出来ます。\n  Amazonで購入する\n  楽天で購入する\n  内容物    Type Item Description Q’ty     AP02 ESP32 MCU Wi-FiとBluetooth LEを内蔵した32bit MCUリーフ 1   AV04 2V～4.5V JST製SHコネクタと昇降圧回路を搭載した2V～4.5Vのリーフ 1   AX07 Back to back 背中合わせに接続するリーフ 1   AX08 29 pin header 29pin I/Fのリーフ 1   AZ02 RTC \u0026amp; microSD Real-Time Clock とmicroSDカードスロットを搭載したリーフ 1   AZ62 Connector Cover コネクタカバー 2   AZ63 Nut Plate 固定金具 2   AZ67 AAA battery holder 単4電池ホルダ 1   AZ68 18650 battery holder 18650電池ホルダ 1    Product sheet 製品シート 1    Product label 製品ラベル 1    M2*12mm screw M2×12 2    φ10x2mm magnet φ10x2mm マグネット 1    リーフ一覧 \rAP02 ESP32 MCU\r\rEspressif Systemsの、技的認証済みWi-FiとBluetooth LEを内蔵したモジュールESP32-WROOM-32を搭載した32bit MCUリーフです。\n\r \rAV04 2V～4.5V\r\rリチウムイオンバッテリや電池ボックス接続用のJST製SHコネクタと電源スイッチ、電圧モニタ用のADコンバータ、3.3V昇降圧回路を搭載した電源リーフです。2V～4.5Vの電池電圧入力に対応しています。\n\r \rAX07 Back to back\r\rリーフを背中合わせに接続可能なコネクタリーフです。\n\r \rAX08 29pin header\r\rリーフI/Fの29ピン全てを2.54mmピッチのピンヘッダに接続したリーフです。\n\r \rAZ02 RTC\u0026amp;microSD\r\rNXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。microSDカードはSPIでアクセスします。\n\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \rAZ63 Nut Plate\r\rNut Plateは、リーフをネジで固定する時に使用します。\n\r \rAZ67 AAA battery holder\r\rJST製SHピンコネクタが付き、単4電池ホルダです。\n\r \rAZ68 18650 battery holder\r\rJST製SHコネクタが付き、18650形(直径18mmｘ長さ65mm)電池ホルダです。\n\r \rサンプルアプリ・応用例 変更履歴  Rev A1.0: 2022年1月初版  前のページに戻る\r","excerpt":"--\r概要 人気のESP32マイコンをベースとしたWi-Fi無線通信、microSD、リアルタイムクロック機能が入ったキットです。Basic Kitより少しサイズが大きく、消費電力も大きくなっています …","ref":"/docs/products/esp32_2/","title":"ESP32 Wi-Fi Kit 2"},{"body":"\nExtenston Kitは、Basic KitやESP32 Wi-Fi Kitと組み合わせて使える、人感センサや MEMS マイクなどを搭載したリーフが入っている開発キットです。Extenston Kitを駆動させるには、Basic Kit かESP32 Wi-Fi KitのMCUリーフに、プログラムを書き込む必要があります。\n用意するもの  Extenston Kit Basic Kit 、またはESP32 Wi-Fi Kit パソコン　  プログラムの書き込み方 プログラミングのためのパソコンの設定の仕方は、開発環境設定に記載しています。\n前のページに戻る\r","excerpt":"\nExtenston Kitは、Basic KitやESP32 Wi-Fi Kitと組み合わせて使える、人感センサや MEMS マイクなどを搭載したリーフが入っている開発キットです。Extenston …","ref":"/docs/getting-started/extension/","title":"Extension Kit スタートガイド"},{"body":"Overview The Leafony template project for KiCad makes leaf board design a breeze. The template project is configured with the following items\n 2cm x 2cm Leaf outline Leafony bus footprint Design Rules.  \nDownload You can download the template project from the link below.\nGitHub - Leafony/cad-template\nDevelopment environment  KiCad 5.0.0 or later  Usage Create a new project  Launch KiCad. File -\u0026gt; New -\u0026gt; Project -\u0026gt; Create Project from Template. Select the User Templates tab. See the following path from the template project downloaded under the template path.  \\cad-template-master\\KiCad\\Leafony_Template\rSelect Leafony Leaf and click OK.  \nEnter a project name and save the project to any location.  Back to previous page\r","excerpt":"Overview The Leafony template project for KiCad makes leaf board design a breeze. The template …","ref":"/en/docs/pcb/kicad/","title":"KiCad Template Project"},{"body":"概要 KiCad向けLeafonyテンプレートプロジェクトを使うとリーフ基板の設計を簡単に行えます。\nテンプレートプロジェクトには下記の項目が設定がされています。\n 2cm x 2cm リーフの外形 Leafony bus フットプリント デザインルール  \nダウンロード 下記のリンクからテンプレートプロジェクトをダウンロードできます。\nGitHub - Leafony/cad-template\n開発環境  KiCad 5.0.0 or later  使い方 新規プロジェクトを作成  KiCadを起動 ファイル -\u0026gt; 新規 -\u0026gt; プロジェクト -\u0026gt; テンプレートからプロジェクトを作成 ユーザーテンプレートタブを選択 テンプレートのパスでダウンロードしたテンプレートプロジェクトから下記パスを参照  \\cad-template-master\\KiCad\\Leafony_Template\rLeafony Leafを選択しOKをクリック  \nプロジェクト名を入力し、任意の場所にプロジェクトを保存  前のページに戻る\r","excerpt":"概要 KiCad向けLeafonyテンプレートプロジェクトを使うとリーフ基板の設計を簡単に行えます。\nテンプレートプロジェクトには下記の項目が設定がされています。\n 2cm x 2cm リー …","ref":"/docs/pcb/kicad/","title":"KiCad テンプレートプロジェクト"},{"body":"  \nFeatures The leaf is equipped with EASEL\u0026rsquo;s technically certified LoRa module ES920LRA1 and is connected to the MCU leaf via UART.\nSpecification    Item Description     Part Number ES920LRA1   SoC MKL16Z128 (ARM Cortex-M0+)   RF Transceiver SX1276 (SEMTECH)   Frequency range 920.6～928.0MHz   Transmission speed 146bps～22kbps   RX sensitivity -118～-142dBm   TX power Max 13dBm（20mW)   RF certification TELEC   Approximate communication distance (wire antenna) Prospect 5km   Flash 128KB   RAM 32KB   Interfaces UART   Dimension W23×D32.8×H4.6mm    Block diagram \nPinassign \nSample App  LoRa  Library Libraries are available for this leaf. Please install the necessary libraries from Environment to use them.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Back to previous page\r","excerpt":"Features The leaf is equipped with EASEL\u0026rsquo;s technically certified LoRa module ES920LRA1 and is …","ref":"/en/docs/leaf/communication/ac03/","title":"AC03 LoRa Easy"},{"body":"  \n特徴 EASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。MCUリーフとはUARTで接続されます。\n性能    Item Description     Part Number ES920LRA1   SoC MKL16Z128 (ARM Cortex-M0+)   RF Transceiver SX1276 (SEMTECH)   Frequency range 920.6～928.0MHz   Transmission speed 146bps～22kbps   RX sensitivity -118～-142dBm   TX power Max 13dBm（20mW)   RF certification TELEC   Approximate communication distance (wire antenna) Prospect 5km   Flash 128KB   RAM 32KB   Interfaces UART   Dimension W23×D32.8×H4.6mm    Tips 直上にリーフを積む時の注意 このリーフには、高背部品(高さ2mm以上)が使用されており、そのままでは直上のリーフと電気的に接続不良をおこす可能性があります。そのため、このリーフの直上には、必ずスペーサリーフ（AX04 Spacer）を間に挟んで下さい。\nブロック図 \nピン配置 \nサンプルアプリ  LoRaを使ってセンサの値を表示  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールしてご利用下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  前のページに戻る\r","excerpt":"特徴 EASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。MCUリーフとはUARTで接続されます。\n性能    Item Description     Part …","ref":"/docs/leaf/communication/ac03/","title":"AC03 LoRa Easy"},{"body":"Introduction Instead of the Arduino IDE, you can also use PlatformIO as the Leafony development environment. PlatformIO makes it easy to manage things like library versioning, board configuration, etc., as well as to use. You can take advantage of the powerful plug-ins for Visual Studio Code to make your development more comfortable.\nAdvance preparation PlatformIO is a plug-in for Visual Studio Code (VSCode). You need to install the following software in advance.\n VSCode Python 3  PlatformIO Installation  Launch VSCode and open the Extensions tab. Enter PlatformIO IDE into the search window. Install the PlatformIO IDE.  Getting Started Create a new project  Press the PlatformIO Home button to display the PlatformIO home. Click on New Project. Name your project and select the appropriate board on Board. Open the main.cpp in the src folder and paste the following code.  #include \u0026lt;Arduino.h\u0026gt; void setup() { // LEDピンを出力ピンに設定  pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); // LEDを点灯  delay(999); // 1秒待つ  digitalWrite(LED_BUILTIN, LOW); // LEDを消灯  delay(999); // 1秒待つ } Press the Build button to build the project. Connect Leafony to your PC. Press the Upload button to write your project to Leafony.  Install the library  Press the PlatformIO Home button to display the PlatformIO home. Open the Libraries tab. Type OPT3001 in the search window to search the library for the illuminance sensor OPT3001. ClosedCube OPT3001をクリック。 Click the Add to Project button and add with Add. Open the PlatformIO.ini. Check that closedcube/ClosedCube OPT3001 @ \u0026lt;version\u0026gt; is added to the lib_deps option. If you paste the code below, you can easily set up the library environment without doing the above.  [env:pro8MHzatmega328]\rplatform = atmelavr\rboard = pro8MHzatmega328\rframework = arduino\rlib_deps = closedcube/ClosedCube OPT3001 @ ^1.1.2\radafruit/Adafruit LIS3DH@1.1.2\rhttps://github.com/ameltech/sme-hts221-library.git\rhttps://github.com/Leafony/TBGLib\rtomozh/ST7032@0.0.0-alpha+sha.501bf64fe6\rpaulstoffregen/MsTimer2@^1.1\radafruit/RTClib@^1.11.2\radafruit/Adafruit Unified Sensor@^1.1.4\radafruit/Adafruit BusIO@^1.5.0\rWriting and Serial Monitor When you press the Serial Port Monitor button, the serial monitor is displayed.\nReference For more information on how to use PlatformIO for VSCode, please refer to the official documentation.\n https://docs.platformio.org/en/latest/integration/ide/vscode.html#ide-vscode  Back to previous page\r","excerpt":"Introduction Instead of the Arduino IDE, you can also use PlatformIO as the Leafony development …","ref":"/en/docs/environment/avr/platformio/","title":"PlatformIO settings for AVR MCU"},{"body":"Introduction Instead of the Arduino IDE, you can also use PlatformIO as the Leafony development environment. PlatformIO makes it easy to manage things like library versioning, board configuration, etc., as well as to use. You can take advantage of the powerful plug-ins for Visual Studio Code to make your development more comfortable.\nAdvance preparation PlatformIO is a plug-in for Visual Studio Code (VSCode). You need to install the following software in advance.\n VSCode Python 3  Platformio Installation  Launch VSCode and open the Extensions tab. Enter PlatformIO IDE into the search window. Install the PlatformIO IDE.  Getting Started Create a new project  Press the PlatformIO Home button to display the PlatformIO home. Click on New Project. Name your project and select the appropriate board on Board. Open the main.cpp in the src folder and paste the following code.  #include \u0026lt;Arduino.h\u0026gt; void setup() { // LEDピンを出力ピンに設定  pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); // LEDを点灯  delay(999); // 1秒待つ  digitalWrite(LED_BUILTIN, LOW); // LEDを消灯  delay(999); // 1秒待つ } Press the Build button to build the project. Connect Leafony to your PC. Press the Upload button to write your project to Leafony. Press the Serial Port Monitor button to display the serial monitor and show the input status of the button.  Install the library  Press the PlatformIO Home button to display the PlatformIO home. Open the Libraries tab. Type OPT3001 in the search window to search the library for the illuminance sensor OPT3001. ClosedCube OPT3001をクリック。 Click the Add to Project button and add with Add. Open the PlatformIO.ini. Check that closedcube/ClosedCube OPT3001 @ \u0026lt;version\u0026gt; is added to the lib_deps option. If you paste the code below, you can easily set up the library environment without doing the above.  [env:pro8MHzatmega328]\rplatform = atmelavr\rboard = pro8MHzatmega328\rframework = arduino\rlib_deps = closedcube/ClosedCube OPT3001 @ ^1.1.2\radafruit/Adafruit LIS3DH@1.1.2\rhttps://github.com/ameltech/sme-hts221-library.git\rhttps://github.com/Leafony/TBGLib\rtomozh/ST7032@0.0.0-alpha+sha.501bf64fe6\rpaulstoffregen/MsTimer2@^1.1\radafruit/RTClib@^1.11.2\radafruit/Adafruit Unified Sensor@^1.1.4\radafruit/Adafruit BusIO@^1.5.0\rWrite and Serial Monitoring When you press the Serial Port Monitor button, the serial monitor is displayed.\nReference For more information on how to use PlatformIO for VSCode, please refer to the official documentation.\n https://docs.platformio.org/en/latest/integration/ide/vscode.html#ide-vscode  Back to previous page\r","excerpt":"Introduction Instead of the Arduino IDE, you can also use PlatformIO as the Leafony development …","ref":"/en/docs/environment/esp32/platformio/","title":"PlatformIO settings for ESP32 MCU"},{"body":"Processor Leaf List\nBack to previous page\r","excerpt":"Processor Leaf List\nBack to previous page\r","ref":"/en/docs/leaf/processor/","title":"Processor Leaves"},{"body":"  \nFeatures This leaf is equipped with a piezoelectric speaker and a motion sensor. The piezoelectric speaker uses PWM and the motion sensor uses I2C to connect to the MCU leaf. The motion sensor has a built-in proximity detection algorithm and can detect proximity with simple settings and can output an interrupt signal when proximity is detected.\nSpecification Dimension    Item Description     Dimension  W23×D20.5×H5.3mm    Piezoelectric Speaker    Item Description     Part number CMT-1203-SMT   dimensions 12 x 12 x 3mm   rated frequency 4kHz(typ)   sound pressure level 81dB(min) at 10 cm, 5 Vp-p, 4,000 Hz square wave   Current consumption 5mA(max) at 5 Vp-p, 4,000 Hz square wave    IR Sensor    Item Description     Part number AK9754   Sensor Quantum-type IR Sensor   Interfaces I2C(Address: 0x65 or 0x64)    Block diagram \nPinassign \nSample App AVR MCU Examples  Speaker IR Sensor PIR Melody Test  ESP32 MCU Examples  Speaker IR Sensor  Document  Spec sheet Schematic SP\u0026amp;PIR Schematic PIR Component marking  PCBLayout SP＆PIR (Zuken) PCBLayout PIR (Zuken) PCBLayout SP＆PIR (dxf) PCBLayout PIR (dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features This leaf is equipped with a piezoelectric speaker and a motion sensor. The piezoelectric …","ref":"/en/docs/leaf/io/ai02/","title":"AI02 SP\u0026PIR"},{"body":"  \n特徴 圧電スピーカと人感センサを搭載したリーフです。圧電スピーカはPWM、人感センサはI2CでMCUリーフと接続されます。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で接近を検知することが出来、接近検知時に割り込み信号を出力することが可能です。\n性能 外形サイズ    Item Description     Dimension  W23×D20.5×H5.3mm    圧電スピーカ    Item Description     Part number CMT-1203-SMT   dimensions 12 x 12 x 3mm   rated frequency 4kHz(typ)   sound pressure level 81dB(min) at 10 cm, 5 Vp-p, 4,000 Hz square wave   Current consumption 5mA(max) at 5 Vp-p, 4,000 Hz square wave    人感センサ    Item Description     Part number AK9754   Sensor Quantum-type IR Sensor   Interfaces I2C(Address: 0x65 or 0x64)    ブロック図 \nピン配置 \nサンプルアプリ AVR MCU Examples  スピーカ 人感センサ 人の接近を検知しメロディを鳴らす  ESP32 MCU Examples  スピーカ 人感センサ  ドキュメント  仕様書 回路図 SP\u0026amp;PIR 回路図 PIR 部品配置図 レイアウト図 SP＆PIR (Zuken) レイアウト図 PIR (Zuken) レイアウト図 SP＆PIR (dxf) レイアウト図 PIR (dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"特徴 圧電スピーカと人感センサを搭載したリーフです。圧電スピーカはPWM、人感センサはI2CでMCUリーフと接続されます。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で接近を検知すること …","ref":"/docs/leaf/io/ai02/","title":"AI02 SP\u0026PIR"},{"body":"Install the 64-bit version of JAVA. It is necessary to install the 64-bit version of JAVA before installing the STM32CubeIDE. Download it from Java Home Page.\nDownload Click Agree and start free download. Install Double-click the downloaded \u0026ldquo;jxpiinstall.exe\u0026rdquo; to open it and click Install. Click on the Close button. Install the STM32CubeIDE Download the STM32CubeIDE.\nDownload Click on the Get Software.\nPlease click on the \u0026ldquo;Get Software\u0026rdquo; link in the STM32CubeIDE-Win line.\nClick on Agree.\nEnter the First Name, Last name, E-mail address, check\n□I have read and understood the Sales Terms \u0026amp; Conditions, Terms of Use and Privacy Policy\r, and click Download.\nThe following page will be displayed. You will receive an email at the address you registered, click Download to start downloading.\nInstall Extract the downloaded zip file.\nDouble-click the unzipped file st-stm32cubeide_1.4.0_7511_20200720_0928_x86_64.exe. (The version may change depending on when it was downloaded and the numbers may be different.)\nClick Next.\nClick I Agree.\nClick Install.\nClick Next.\nClick Finish.\nThe installation is now complete.\nJapaneseization of STM32CubeIDE Download from the MargeDoc Project home page.\nDownload Windows.\nInstall Extract the zip file you downloaded. Double-click the unzipped setup.exe. Select.\nSelect C:\\\\StMoStM32CubeIDE_1.4.0\\Stm32cubeIDE\\Stm32cubeIDE.exe and click on Open.\ntranslate into Japanese.\nOK.\nFinish.\nThe installation is now complete.\nAnti-characterization measures To make sure UTF-8 is not garbled when generating code in STM32CubeMX (not sure if this is really necessary) Add the following to the environment variables\nVariable name ：JAVA_TOOL_OPTIONS variable value：-Dfile.encoding=UTF-8\nSelect Control Panel, System, System Advanced Settings, Environment Variables. Click the New button.\nEnter JAVA_TOOL_OPTIONS in the variable name and -Dfile.encoding=UTF-8 in the variable value.\nClick OK. Back to previous page\r","excerpt":"Install the 64-bit version of JAVA. It is necessary to install the 64-bit version of JAVA before …","ref":"/en/docs/environment/stm32/stm32cube_ide/","title":"Installation of the STM32CubeIDE"},{"body":"Leafonyのキットには、アプリがプレインストールされているため、電源を入れたらすぐに使うことが出来ます。\n前のページに戻る\r","excerpt":"Leafonyのキットには、アプリがプレインストールされているため、電源を入れたらすぐに使うことが出来ます。\n前のページに戻る\r","ref":"/docs/getting-started/","title":"クイックスタート"},{"body":"プロセッサリーフ一覧\n前のページに戻る\r","excerpt":"プロセッサリーフ一覧\n前のページに戻る\r","ref":"/docs/leaf/processor/","title":"プロセッサリーフ"},{"body":"Overview Turns on and off the LEDs on the AVR MCU leaf every second.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n//===================================================================== // Blink // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //=====================================================================  void setup() { // LEDピンを出力ピンに設定  pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); // LEDを点灯  delay(1000); // 1秒待つ  digitalWrite(LED_BUILTIN, LOW); // LEDを消灯  delay(1000); // 1秒待つ } Blink.ino\nExecution Results The LED on the AVR MCU leaf turns on and off every 1 second.\nBack to previous page\r","excerpt":"Overview Turns on and off the LEDs on the AVR MCU leaf every second.\nLeaf to use Use the following …","ref":"/en/docs/examples/beginner/1_p/basic/blink/","title":"Blink"},{"body":"概要 STM32 MCUリーフに搭載されたLEDを1秒おきに点灯/消灯させます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード STM32CubeIDEに下記のプロジェクトをインポートしましょう。\nBlink.zip  \nファイルはZIPで圧縮されているのでフォルダ“ドキュメント¥STM32¥”等に解凍してください。 プロジェクトのインポート方法は下記を参照してください。\nSTM32CubeIDE使用方法  \nmain.cの99～102行にある下記4行でLEDの点滅を行っています。\nHAL_GPIO_WritePin(GPIOH, GPIO_PIN_3, GPIO_PIN_SET); // LEDを点灯 \tHAL_Delay(1000); // 待ち1000ms \tHAL_GPIO_WritePin(GPIOH, GPIO_PIN_3, GPIO_PIN_RESET); // LEDを消灯 \tHAL_Delay(1000); // 待ち1000ms 実行結果 STM32 MCUリーフに搭載されたLEDが1秒おきに点灯/消灯します。\n前のページに戻る\r","excerpt":"概要 STM32 MCUリーフに搭載されたLEDを1秒おきに点灯/消灯させます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 …","ref":"/docs/examples-stm/beginner/blink/","title":"LED点滅"},{"body":"概要 AVR MCUリーフに搭載されたLEDを1秒間隔で、点灯/消灯を繰り返します。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    リーフの組み立て Arduino IDEの場合 ソースコード   マイコンにプログラムを書き込むために、Arduino IDEの設定をして下さい。\n  以下のソースコードをGitHubからダウンロードし、パソコンに保存1 して下さい。\n ソースコード：Blink.ino    マイコンにプログラムを書き込んで下さい。  void setup() { // initialize digital pin LED_BUILTIN as an output.  pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level)  delay(1000); // wait for a second  digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW  delay(1000); // wait for a second } 実行結果  AVR MCUリーフに搭載されたLEDを1秒間隔で、点灯/消灯を繰り返すことを確認して下さい。  PlatformIO IDE の場合 ソースコード   マイコンにプログラムを書き込むために、PlatformIO IDE for VSCodeの設定 をして下さい。\n  「Hello Wolrd」のクイックスタートを行って、PlatformIO IDEの仕組みを把握して下さい。\n  以下のソースコードをGitHubからダウンロードし、パソコンに保存して下さい。2\n ソースコード：Blink.Pjt　    マイコンにプログラムを書き込んで下さい。  実行結果  AVR MCUリーフに搭載されたLEDを1秒間隔で、点灯/消灯を繰り返すことを確認して下さい。  前のページに戻る\r  デフォルトの保存場所は、C:\\Users\\＜ユーザ名＞\\ドキュメント\\Arduinoです。\n\u0026#x21a9;\u0026#xfe0e;\n デフォルトの保存場所は、C:\\Users\\＜ユーザ名＞\\ドキュメント\\PlatformIO\\Projectsです。\n\u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"概要 AVR MCUリーフに搭載されたLEDを1秒間隔で、点灯/消灯を繰り返します。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover …","ref":"/docs/examples/beginner/1_p/basic/blink/","title":"LED点滅"},{"body":"用意するもの  Basic Kit USBケーブル(データ転送用) パソコン (Windows、macOS 、または Linux)  Arduino IDEのインストール 以下の手順で、Arduino IDEをインストールを行います。\n Arduinoのホームページ からSOFTWAREのページを開きます。 Downloadで、インストーラをダウンロードします。 画面の指示に従って、インストールします。  Previous IDE インストール 下記より、Previous IDEのインストールが出来ます。\nPrevious IDE Releases\nパソコンと接続 USBケーブルでパソコンを接続します。\nマイコンボードの設定   Arduino AVR Boardsは、IDEと一緒にインストールされます。Arduino AVR Boards のバージョンは、ツール→ボード→ボードマネージャ で確認をすることが出来ます。バージョンを選択をすれば、以前のものをインストールすることが出来ます。\n\n  ツール → ボードから、Arduino Pro or Pro Miniを選択、プロセッサでATmega328P (3.3V,8MHz)を選択します。\n  \nツール → シリアルポートから、Leafonyが接続されているシリアルポートを選択します。シリアルポートが選択出来ない場合は、シリアルポートが見つからないを参照して下さい。  \nマイコンボードの動作確認  Arduino IDEを起動し、ファイル → スケッチ例 → 01.Basics → Blinkをクリックし、サンプルアプリを開きます。 マイコンボードに書き込むボタンを押すをAVR MCUリーフにプログラムが書き込まれます。 AVR MCUリーフに搭載されたLEDが点滅していることが確認できれば完了です。  スケッチのピンの指定 ピンは、名前(Name)で指定して下さい。\n\nライブラリのインストール プログラムを書き込むには、ライブラリのインストールが必要なリーフがあります。下記の手順を参考に、あらかじめ全てののライブラリをインストールしておきます。\n1. 使用するライブラリ 各Kitで使用するライブラリは以下の通りです。\n\r\rItem\rinclude file\rTags\rDescription\r\r\r\r\rBLE\rTBGLib.h\r\rBluetoothライブラリ\r\r\r4-Sensors\rAdafruit_Sensor.h\r\rユニファイドセンサドライバ\r\r\rAdafruit_BusIO_Register.h\r\rBus IOライブラリ\r\r\rHTS221.h\r\r温湿度センサライブラリ\r\r\rClosedCube_OPT3001.h\r\r照度センサライブラリ\r\r\rAdafruit_LIS3DH.h\r1.1.2\r加速度センサライブラリ\r\r\rLCD\rST7032.h\r\rLCDライブラリ\r\r\rAVR MCU\rMsTimer2.h\r\rタイマ割り込みライブラリ\r\r\rRTC\u0026MicroSD\rRTClib.h\r\rRTCライブラリ\r\r\rSTM32 MCU\rSTM32RTC.h\r1.2.0\rSTM32RTCライブラリ\r\r\rSTM32LowPower.h\r\rSTM32LowPowerライブラリ\r\r\rLTE-M\rLteLeafV4.h\r\rLTE-Mライブラリ\r\r\r\r2. ライブラリをダウンロード 上記表のリンクをクリックすると、ライブラリのGitHubリポジトリにアクセスします。Code → Download ZIPをクリックし、ライブラリをダウンロードします。\n3. ライブラリをインクルード Arduinoを立ち上げ、スケッチ → ライブラリをインクルード → ZIP形式のライブラリをインストールの順に選択して、先程ダウンロードしたZIPファイルを読み込みます。\n困ったときには お問い合わせをする前に、困ったときにはを読んでみてください。\n前のページに戻る\r","excerpt":"用意するもの  Basic Kit USBケーブル(データ転送用) パソコン (Windows、macOS 、または Linux)  Arduino IDEのインストール 以下の手順で、Arduino …","ref":"/docs/environment/avr/arduino/","title":"Arduino IDEの設定"},{"body":"From now on, let\u0026rsquo;s set up a PC environment to develop with Leafony. You can learn how to install the necessary tools and libraries, how to build Leafony, and more here.\nAVR MCU development environment The AVR MCU leaf is a microcontroller leaf included in the Basic Kit.\n Configuring the Arduino IDE PlatformIO Configuration  ESP32 MCU development environment The ESP32 MCU leaf is a microcontroller leaf included in the ESP32Wi-Fi Kit.\n Configuring the Arduino IDE PlatformIO Configuration  STM32 MCU development environment  Configuring the Arduino IDE Installation of the STM32CubeIDE How to connect the debugger  Back to previous page\r","excerpt":"From now on, let\u0026rsquo;s set up a PC environment to develop with Leafony. You can learn how to …","ref":"/en/docs/environment/","title":"Environment Setting"},{"body":"  \nFeatures It is a 32-bit MCU leaf with Espressif Systems\u0026rsquo; Xtensa Dual-Core 32-bit LX6 microprocessor, ESP32-WROOM-32 with built-in technically certified Wi-Fi and BLE. Radio certifications include FCC, CE-RED, IC, TELEC, KCC, SRRC, and NCC (Espressif Systems Data Sheet V2.9). Can be used as VBUS (5V) power supply with USB power supply. List of Assistants\nSpecification    Item Description     Part number ESP32-WROOM-32   SoC ESP32-D0WDQ6 (CPU:Xtensa LX6)   Operating voltage 3.3V   Input voltage 2.2-3.6V   Digital I/O 14   Analog input 6   TouchSensor I/F 6   Flash Memory 4 MB   SRAM 520 KB   Clock frequency 80M-240MHz   Wi-Fi protocols IEEE 802.11b/g/n   Bluetooth protocols Bluetooth v4.2 BR/EDR and BLE specification   RF certification FCC/CE-RED/IC/TELEC/KCC/SRRC/NCC   Dimension W39.1×D32.7×H5.4mm     Block diagram \nPinassign \nTips About LEDs and switches \n   Item Description     LED RX FT232RQ controlled LED / Flashes on UART TX data transmission.   LED TX FT232RQ controlled LED / Flashes on UART RX data transmission.   Reset switch Resets the ESP32 and other devices.   Boot mode switch Switch to change to boot mode.Press and hold the boot mode switch while writing a sketch.   micro USB It is used for writing a sketch to the MCU and serial monitoring by connecting a PC.This also converts USB’s VBUS(5V) to 3.3V by using step-down power circuit and provide VBUS and 3.3V to each leaf.   Antenna This is a shared antenna for Bluetooth LE and Wi-Fi.    Sample App  Button Wi-Fi touchsensor ESP32 googlesheets  How to use it with Arduino In order to use this leaf with Arduino, the board must be configured on the Arduino IDE.\nPlease refer to Environment for instructions.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, January 2020  Back to previous page\r","excerpt":"Features It is a 32-bit MCU leaf with Espressif Systems\u0026rsquo; Xtensa Dual-Core 32-bit LX6 …","ref":"/en/docs/leaf/processor/ap02/","title":"AP02 ESP32 MCU"},{"body":"  \n特徴 Espressif SystemsのXtensa Dual-Core 32-bit LX6 マイクロプロセッサ、技的認証済みWi-FiとBLEを内蔵したESP32-WROOM-32を搭載した32bit MCUリーフである。無線の認証は、 FCC、CE-RED、IC、TELEC、KCC、SRRC、NCCを取得（Espressif Systems Data Sheet V2.9）。 USB電源を供給して、VBUS(5V)電源として使用可能。\n性能    Item Description     Part number ESP32-WROOM-32   SoC ESP32-D0WDQ6 (CPU:Xtensa LX6)   Operating voltage 3.3V   Input voltage 2.2-3.6V   Digital I/O 14   Analog input 6   ADC 12bit   TouchSensor I/F 6   Flash Memory 4 MB   SRAM 520 KB   Clock frequency 80M-240MHz   Wi-Fi protocols IEEE 802.11b/g/n   Bluetooth protocols Bluetooth v4.2 BR/EDR and BLE specification   RF certification FCC/CE-RED/IC/TELEC/KCC/SRRC/NCC   Dimension W39.1×D32.7×H5.4mm    ブロック図 \nピン配置 \n制限事項 ※1:出力の設定不可 ※2:①UART1は、ピン番号をRX=26、TX=25に設定。UART0、2に関しては、ピン番号の指定無し。UART1の設定例を記す。\nHardwareSerial Serial1(1); // UART1 (RX=9, TX=10)  void setup() { Serial1.begin(9600, SERIAL_8N1, 26, 25); // ピンを変更 (RX=26, TX=25) } 　②WiFi.hをインクルードする場合は、アナログ入力として使用不可\n※3:ブートストラップに使用しているため、プルアップ禁止\nTips LED、スイッチについて \n   Item Description     LED RX FT232RQ controlled LED / Flashes on UART TX data transmission.   LED TX FT232RQ controlled LED / Flashes on UART RX data transmission.   Reset switch Resets the ESP32 and other devices.   Boot mode switch Switch to change to boot mode.Press and hold the boot mode switch while writing a sketch.   micro USB It is used for writing a sketch to the MCU and serial monitoring by connecting a PC.This also converts USB’s VBUS(5V) to 3.3V by using step-down power circuit and provide VBUS and 3.3V to each leaf.   Antenna This is a shared antenna for Bluetooth LE and Wi-Fi.    低電力スリープ ESP32 MCUはDeep Sleep機能を利用することで、プロセッサの非利用時に低電力な待機モードを実現できます。\nwifi.disconnect(true); // Wi-Fiをオフにするために，trueを明示してください 電池動作 ESP32 MCUは、コイン電池では動作しません。\n直上にリーフを積む時の注意 このリーフには、高背部品(高さ2mm以上)が使用されており、そのままでは直上のリーフと電気的に接続不良をおこす可能性があります。そのため、このリーフの直上には、必ずスペーサリーフ（AX04 Spacer）を間に挟んで下さい。\nタッチセンサ ESP32は静電容量式タッチセンサの機能を持っています。配線の容量によって値が変わるので閾値の調整が必要です。 | Leafonyピン番号 | Arduinoピン名称 | ESP32 IO番号 | タッチセンサ番号 | 備考 | | :\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | :\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | :\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | :\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | :\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | 7 | D6 | IO14 | T6 | － | | 9 | D7 | IO15 | T3 | － | | 22 | D2 | IO4 | T0 | － | | 24 | D3 | IO27 | T7 | ESP32 Wi-Fi Kitでは使用不可 | | 26 | D4 | IO12 | T5 | － | | 28 | D5 | IO13 | T4 | － |\nサンプルアプリ  ボタン入力 Wi-Fi タッチセンサ データ転送 To Google Sheets  Arduinoでの使用方法 本リーフをArduinoで使用するためには、Arduino IDE上でボードの設定が必要です。\n開発環境設定のページで設定方法をご確認下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2020年1月:初版 2022年2月:低電力強化のため47KΩをC715の上段に追加。ドキュメントは、回路図のみ変更。  前のページに戻る\r","excerpt":"特徴 Espressif SystemsのXtensa Dual-Core 32-bit LX6 マイクロプロセッサ、技的認証済みWi-FiとBLEを内蔵したESP32-WROOM-32を搭載し …","ref":"/docs/leaf/processor/ap02/","title":"AP02 ESP32 MCU"},{"body":"  \n LTE-M King Mの電源供給には、LTE-M king Sが必要になります。必ず、LTE-M king Sを下に配置してご使用下さい。  特徴 LTE-M king Mリーフは、KDDIが開発したLTE-M (LTE Cat-M1)通信機能に対応したリーフです。\n 約23×30mmの小さな基板上に、データ通信用のアンテナを内蔵し（技適取得済）、外部アンテナは不要です。 SIMカードは、KDDIのLTE-M通信網に対応したソラコムのLTE-Mサービス「SORACOM Air for セルラー(plan-KM1)」が利用出来ます。 省電力性能は、通信モジュールが具備するスリープ等の機能だけでなく、ソフトウェア設定で通信モジュールへの給電自体を遮断する機能を搭載しており、長期間使用しない時は電池の消費を限りなくゼロに近づけることが可能にしました。 電池は、単3電池やリチウムイオン電池等で、データ送信の頻度や回数等のユースケースに応じて選択することが出来ます。  性能    Item Description     LTE-M module Type 1SC (LBAD0XX1SC-713TEMP)   Connectivity 3GPP Release 13/optimized for LTE Class 3 output power (+23dBm)   Operating voltage 2.85-4.35V   Antenna On board chip antenna (AM11DP-ST01)   SIM card nanoSIM   Interfaces UART   Baud rate 115200 bps   Dimension W23×D32.8×H4.6mm    Tips　 アンテナ、ナノSIMカードスロットについて \n   Item Description     Antenna On board chip antenna for LTE-M   nanoSIM card slot Insert a nanoSIM card    ブロック図 \nピン配置　 \nサンプルアプリ  LTE-Mを使ったIoTサービス  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールしてご利用下さい。\nドキュメント  仕様書 ※仕掛中 回路図 部品配置図 レイアウト図(Zuken) 3D図面※仕掛中  変更履歴  2022年5月:初版  前のページに戻る\r","excerpt":"LTE-M King Mの電源供給には、LTE-M king Sが必要になります。必ず、LTE-M king Sを下に配置してご使用下さい。  特徴 LTE-M king Mリーフは、KDDIが開発し …","ref":"/docs/leaf/communication/ac04/","title":"AC04 LTE-M King M"},{"body":"\nOverview A connector cover to protect the Nut Plate and ACR from debris when screwing the leaf in place.\nContents    Type Item Q’ty     AZ63 Nut Plate 10   AZ62 Connector Cover 10    List \rAZ63 Nut Plate\r\rThe Nut Plate is used to fix the leaf with a screw. Be careful not to use commercially available hex nuts as they may cause a short circuit by touching the electrodes on the board.\n\r\r\rAZ62 Connector Cover\r\rThe Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris.\n\r \rRevision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Overview A connector cover to protect the Nut Plate and ACR from debris when screwing the leaf in …","ref":"/en/docs/products/nut/","title":"Nut Plate \u0026 Connector Cover"},{"body":"プログラミングのためのパソコンの設定の仕方に関して記載しています。\nAVR MCU 開発環境 AVR MCU リーフはBasic Kitに含まれるマイコンリーフです。\n Arduino IDEの設定 PlatformIO IDE for VSCodeの設定  ESP32 MCU 開発環境 ESP32 MCU リーフはESP32Wi-Fi Kitに含まれるマイコンリーフです。\n Arduino IDEの設定 PlatformIO IDE for VSCodeの設定  STM32 MCU 開発環境  Arduino IDEの設定 PlatformIO IDE for VSCodeの設定 STM32CubeIDEの設定 デバッガの接続方法  前のページに戻る\r","excerpt":"プログラミングのためのパソコンの設定の仕方に関して記載しています。\nAVR MCU 開発環境 AVR MCU リーフはBasic Kitに含まれるマイコンリーフです。\n Arduino IDE …","ref":"/docs/environment/","title":"開発環境設定"},{"body":"Overview Read the battery voltage using the AD converter on the CR2032 coin cell leaf.\nThis sample will also work with battery leaves such as the AA BAT leaf and the 2V to 4.5V leaf.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    Assembly Source code Write the following program in the Arduino IDE.\n//===================================================================== // Battery Voltage // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //=====================================================================  #include \u0026lt;Wire.h\u0026gt; const int BATT_ADC_ADDR = 0x50; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize I2C communication at 100kHz:  Wire.begin(); delay(10); } void loop(){ // read ADC registers:  Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); uint8_t adcVal1 = Wire.read(); uint8_t adcVal2 = Wire.read(); // when ADC is not connected, read values are 0xFF:  if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { adcVal1 = adcVal2 = 0; } // voltage mV = adcVal * Vref(3.3V) / resolution(8bit) * Vdiv(2)  double tempMillivolt = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; float dataBatt = (float)(tempMillivolt / 1000); Serial.println(\u0026#34;Batt[V] = \u0026#34; + String(dataBatt)); delay(1000); } Battery_Voltage.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the battery voltage.\nBack to previous page\r","excerpt":"Overview Read the battery voltage using the AD converter on the CR2032 coin cell leaf.\nThis sample …","ref":"/en/docs/examples/beginner/1_p/basic/read_battery/","title":"Read battery"},{"body":"Overview Read the battery voltage using the AD converter on the CR2032 coin cell leaf.\nThis sample will also work with battery leaves such as the AA BAT leaf and the 2V to 4.5V leaf.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    Assembly Source code Write the following program1 in the Arduino IDE.\n//===================================================================== // Battery Voltage // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //=====================================================================  #include \u0026lt;Wire.h\u0026gt; const int BATT_ADC_ADDR = 0x50; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize I2C communication at 100kHz:  Wire.begin(); delay(10); } void loop(){ // read ADC registers:  Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); uint8_t adcVal1 = Wire.read(); uint8_t adcVal2 = Wire.read(); // when ADC is not connected, read values are 0xFF:  if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { adcVal1 = adcVal2 = 0; } // voltage mV = adcVal * Vref(3.3V) / resolution(8bit) * Vdiv(2)  double tempMillivolt = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; float dataBatt = (float)(tempMillivolt / 1000); Serial.println(\u0026#34;Batt[V] = \u0026#34; + String(dataBatt)); delay(1000); } Battery_Voltage.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the battery voltage.\nBack to previous page\r  The program is the same as AVR MCU Leaf. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview Read the battery voltage using the AD converter on the CR2032 coin cell leaf.\nThis sample …","ref":"/en/docs/examples/beginner/3_p/basic/read_battery/","title":"Read battery"},{"body":"概要 CR2032コイン電池リーフに搭載されたADコンバータを使って電池の電圧を読み取りましょう。\nこのサンプルはAA BATリーフや、2V～4.5Vリーフなどの電池リーフでも動作します。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    リーフの組み立て ソースコード Arduino IDEで下記のプログラムがを作成しましょう。\n//===================================================================== // Battery Voltage // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //=====================================================================  #include \u0026lt;Wire.h\u0026gt; const int BATT_ADC_ADDR = 0x50; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize I2C communication at 100kHz:  Wire.begin(); delay(10); } void loop(){ // read ADC registers:  Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); uint8_t adcVal1 = Wire.read(); uint8_t adcVal2 = Wire.read(); // when ADC is not connected, read values are 0xFF:  if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { adcVal1 = adcVal2 = 0; } // voltage mV = adcVal * Vref(3.3V) / resolution(8bit) * Vdiv(2)  double tempMillivolt = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; float dataBatt = (float)(tempMillivolt / 1000); Serial.println(\u0026#34;Batt[V] = \u0026#34; + String(dataBatt)); delay(1000); } Battery_Voltage.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、電池の電圧が表示されます。\n前のページに戻る\r","excerpt":"概要 CR2032コイン電池リーフに搭載されたADコンバータを使って電池の電圧を読み取りましょう。\nこのサンプルはAA BATリーフや、2V～4.5Vリーフなどの電池リーフでも動作します。\n使用する …","ref":"/docs/examples/beginner/1_p/basic/read_battery/","title":"バッテリ電圧読み取り"},{"body":"概要 CR2032コイン電池リーフに搭載されたADコンバータを使って電池の電圧を読み取りましょう。\nこのサンプルはAA BATリーフや、2V～4.5Vリーフなどの電池リーフでも動作します。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*10mm screw 2    リーフの組み立て ソースコード Arduino IDEで下記のプログラム1がを作成しましょう。\n//===================================================================== // Battery Voltage // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //=====================================================================  #include \u0026lt;Wire.h\u0026gt; const int BATT_ADC_ADDR = 0x50; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize I2C communication at 100kHz:  Wire.begin(); delay(10); } void loop(){ // read ADC registers:  Wire.beginTransmission(BATT_ADC_ADDR); Wire.write(0x00); Wire.endTransmission(false); Wire.requestFrom(BATT_ADC_ADDR,2); uint8_t adcVal1 = Wire.read(); uint8_t adcVal2 = Wire.read(); // when ADC is not connected, read values are 0xFF:  if (adcVal1 == 0xff \u0026amp;\u0026amp; adcVal2 == 0xff) { adcVal1 = adcVal2 = 0; } // voltage mV = adcVal * Vref(3.3V) / resolution(8bit) * Vdiv(2)  double tempMillivolt = ((double)((adcVal1 \u0026lt;\u0026lt; 4) | (adcVal2 \u0026gt;\u0026gt; 4)) * 3300 * 2) / 256; float dataBatt = (float)(tempMillivolt / 1000); Serial.println(\u0026#34;Batt[V] = \u0026#34; + String(dataBatt)); delay(1000); } Battery_Voltage.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、電池の電圧が表示されます。\n前のページに戻る\r  プログラムは、AVR MCUリーフと同じです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"概要 CR2032コイン電池リーフに搭載されたADコンバータを使って電池の電圧を読み取りましょう。\nこのサンプルはAA BATリーフや、2V～4.5Vリーフなどの電池リーフでも動作します。\n使用する …","ref":"/docs/examples/beginner/3_p/basic/read_battery/","title":"バッテリ電圧読み取り"},{"body":"Beginner Examples 各種リーフを使った初心者向けのサンプルアプリを紹介します。実際に動かして使い方を学んでいきましょう。\nAVR Beginner Examples    Item Basic 2 Extension     LED点滅 ✓    バッテリ電圧読み取り ✓    温湿度センサ読み取り ✓    照度センサ読み取り ✓    加速度センサ読み取り ✓    スピーカ ✓ ✓   人感センサ ✓ ✓   サウンドレベルメータ ✓ ✓   LCD ✓ ✓    ESP32 Beginner Examples    Item ESP32 Wi-Fi 2 Basic 2 Extension     ボタン入力 ✓     リアルタイムクロック ✓     microSDカード ✓     温湿度センサ読み取り ✓ ✓    照度センサ読み取り ✓ ✓    加速度センサ読み取り ✓ ✓    スピーカ ✓ ✓ ✓   人感センサ ✓ ✓ ✓   サウンドレベルメータ ✓ ✓ ✓   LCD ✓ ✓ ✓    STM32 Beginner Examples    Item Basic 2 Extension     バッテリ電圧読み取り ✓    温湿度センサ読み取り ✓    照度センサ読み取り ✓    加速度センサ読み取り ✓    スピーカ ✓ ✓   人感センサ ✓ ✓   サウンドレベルメータ ✓ ✓   LCD ✓ ✓    \rAdvanced Examples　 各種リーフを使った上級者向けサンプルアプリを紹介します。サンプルアプリを参考に、身近なものをIoT化しましょう。\nAVR Advanced Examples    Item Basic 2 Extension LoRa Motor     Web Bluetoothを使ったIoTアプリ入門 ✓      Simple BLE Characteristic (公開予定) ✓      Simple BLE Advertising (公開予定) ✓      Google sheetsを使ったIoTサービス入門 ✓      センサの値をLCDに表示 ✓ ✓     センサの値をLCDに表示しBLEで送信(公開予定) ✓ ✓     人の接近を検知しメロディをならす ✓ ✓     超音波センサで距離測定 ✓ ✓     カメラの撮影 ✓ ✓     LoRaを使ってセンサの値を表示 ✓ ✓ ✓    Motorを使って植木に水やり ✓   ✓   自動測定監視システム ✓      体重計 ✓       ESP32 Advanced Examples    Item ESP32 Wi-Fi 2 Basic 2     Wi-Fi タッチセンサ ✓    Google Sheetsを使ったIoTサービス ✓ ✓   BLE Logger Beacon ✓ ✓   低電力にポスト投函検出してLINE通知 ✓ ✓    STM32 Advanced Examples    Item Basic 2 LTE-M     STM32で Web Bluetoothを使ったIoTアプリ入門 ✓    Simple BLE Beacon ✓    4-Sensors BLE Beacon(公開予定) ✓    BLE Logger Beacon ✓    STM32でGoogle SheetsをつかったIoTサービス入門 ✓    STM32で人物検出する推論ネットワークの実装 ✓    LTE-Mリーフを使ったIoTサービス ✓ ✓    前のページに戻る\r","excerpt":"Beginner Examples 各種リーフを使った初心者向けのサンプルアプリを紹介します。実際に動かして使い方を学んでいきましょう。\nAVR Beginner Examples    Item …","ref":"/docs/examples/","title":"Arduino サンプルアプリ・応用例"},{"body":"  \n LTE-M King Sは、LTE-Mリーフ専用のリーフなので必ずLTE-M King Mの下に配置して下さい。 電池はニッケル⽔素電池電池3本か、3.7Vのリチウムイオン電池を想定しています。 LTE-M King Sに貼られているテープは、絶縁防止ためなので外さないで下さい。  \r特徴 LTE-M king Sリーフは、JST製PHコネクタからの電池電圧やVBUSの電圧を3.3Vに変換して、各リーフに供給したり、MCUリーフの書き込みや電池電圧をモニターが出来ます。\n性能　    Item Description     USB connector  Type-C   Battery connector  JST PH connector   Dimension  W23×D21×H6.2mm    USB-UART変換    Item Description     Part Number XR21B1411IL16-F   USB USB 2.0 Full Speed   Data transfer rates 12Mbps (max)    電源(VBUS→PSYS3.3V)    Item Description     Part number TPSM828214SILR   Input voltage 3.3～5.5V   Output voltage 3.3V±1% (PWM mode)   Topology Buck   Controlling method PWM / Power save mode   Maximum output current 1A   Protection circuit Short circuit protection / Overtemperature protection    電源(PSYS→3.3V)    Item Description     Part number RP604K331B-TR   Input voltage 1.8～5.5V   Output voltage 3.3V±2%   Topology Buck-boost   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA (when step down)   Protection circuit Over current protection / Thermal shutdown    ADコンバータ　    Item Description     Part number ADC101C027CIMK   Resolution 10bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置　 \nTips スイッチ、コネクタ、USBについて \n   Item Description     Switch Switch for turning on and off the 3.3v power   Connector JST PH connector   USB Type-C    USBドライバインストール LTE-M king SリーフのUSB-UART変換ICは、調達の都合上、MaxLinear社のIC(XR21B1411IL16-F)を採用しました。以下にXR21B1411IL16-Fのドライバーのインストール方法を記載します。\n  下記からご使用のOSにあったドライバーをダウンロードし、解凍して下さい。Windowsの場合は、解凍すると「V2.6.0.0 Drivers」のフォルダが出来ます。以降、Windowsの場合を説明します。 https://www.maxlinear.com/product/interface/uarts/usb-uarts/xr21b1411   LTE-M king SリーフをPCに接続します。\n  スイッチをONにします。\n  デバイスマネージャを開いて、ポート→USBシリアルデバイスを選択し、ドライバの更新をします。   先程解凍した「V2.6.0.0 Drivers」のフォルダを参照し、ドライバーをインストールします。   正しく接続出来ていたら、ポートにXR21B1411 USB UARTが表示されます。   サンプルアプリ  LTE-Mを使ったIoTサービス  ドキュメント　  仕様書 ※仕掛中 回路図 部品配置図(表面) ※仕掛中 部品配置図(裏面) ※仕掛中 レイアウト図(Zuken) 3D図面 ※仕掛中  変更履歴  2022年5月:初版  前のページに戻る\r","excerpt":"LTE-M King Sは、LTE-Mリーフ専用のリーフなので必ずLTE-M King Mの下に配置して下さい。 電池はニッケル⽔素電池電池3本か、3.7Vのリチウムイオン電池を想定しています。 …","ref":"/docs/leaf/communication/ac05/","title":"AC05 LTE-M King S"},{"body":"はじめに Visual Studio Code (VSCode)は、Microsoft社が提供する軽量ながら強力なソース コード エディターで、デスクトップ上で実行され、Windows、macOS、および Linux で使用できます。PlatformIO IDEは、VSCodeの拡張機能で、ビルドが早く、ライブラリやボードのバージョンがプロジェクト毎に管理されているのが特長です。 \n用意するもの  Basic Kit 2 パソコン (Windows、macOS 、または Linux)  事前準備 Pythonのインストール  PlatformIO IDEを動かすには、Pythonが必要です。こちらを参照して、Pythonインストールして下さい。  PlatformIO IDEのインストール  PlatformIO IDEは、VSCodeの拡張機能なので、まず、VSCodeをインストールして下さい。 拡張機能(画面左のバー)をクリックし、検索窓に以下を入力して、拡張機能をインストールします。  Japanese Language Pack for Visual Studio Code platformio ide Serial Monitor teleplot    クイックスタート 「Hello Wolrd」の事例で、platformIO IDEの使い方を紹介します。\n  VSCodeを立ち上げ、ファイル→ 新しいウィンドウを開きます。\n  PlatformIO(画面左のバー)をクリックし、PLATFORMIO QUICK ACCESS（画面左）を表示させます。\n  PIO Home/Openをクリックします。\n  New Projectをクリックすると、Project Wizardが表示されます。Name、Boad、Frameworkを以下の通り入力して、Finishをクリックします。新しいBoardを選択した時、プログラミングに必要なファイルのダウンロードするために数分かかります。\n Name:Hellow_Wolrd_Pjtと記入  Board:Arduino Pro or Pro Mini ATmega328(3.3v,8Mhz)を選択  Framework:Arduino を選択     platformio.ini (画面左）を開き、 Projectで定義したBoardとFrameworkが、正しく定義されていることを確認します。\n  [env:pro8MHzatmega328] platform = atmelavr board = pro8MHzatmega328 framework = arduino  AVR MCUは、アップロード時に、COMポートの自動検出をするため、COMポートの番号の指定が不要になります。\n  シリアル通信のボーレートをmonitor_speed =で定義します。以下の様に、platformio.iniに加えて下さい。\n  monitor_speed = 115200 src/main.cpp(画面左）を開き、以下のコードを貼り付けて下さい。 PlatformIO IDEのコードは、Arduino IDEのスケッチの先頭に#include \u0026lt;Arduino.h\u0026gt;を加えます。  #include \u0026lt;Arduino.h\u0026gt; void setup() { Serial.begin(115200); delay(10); } void loop(){ Serial.println(\u0026#34;Hello World\u0026#34;); delay(1000); }  ソースコード：Hello_Wold.Pjt   PlatformIO ツールバー(画面下のバー)のProject Environment Switcherボタンを押すと、アクティブなプロジェクが画面上側に全て表示されます。実行するプロジェクトを正しく選択して、Buildボタンを押して下さい。 \n  こちら を参考に、LeafonyをPCに接続して下さい。\n  Uploadボタンを押すと、プログラムがMCUに書き込まれます。\n  MCUのリセットボタンを押して、プログラムを実行させます。\n  シリアルモニターボタンを押して起動させ、Hello Wolrdを表示が出来れば完成です。 \n  ライブラリ   インストールの仕方 ライブラリは、platformio.ini の最後の行に、lib_deps =で定義すれば、PCにインストールされます。定義の仕方は、GitHubのURLを直接指定する方法とLibrariesで指定する方法の二通りがあります。 \n  各リーフのライブラリ一覧は、以下の通りです。\n  \r\rItem\rlib_deps\rTags\rDescription\r\r\r\r\rBLE\rhttps://github.com/Leafony/TBGLib\r\rBluetoothライブラリ\r\r\r4-Sensors\radafruit/Adafruit Unified Sensor@^1.1.6\r\rユニファイドセンサドライバ\r\r\radafruit/Adafruit BusIO@^1.14.1\r\rBus IOライブラリ\r\r\rhttps://github.com/ameltech/sme-hts221-library\r\r温湿度センサライブラリ\r\r\rclosedcube/ClosedCube OPT3001@^1.1.2\r\r照度センサライブラリ\r\r\radafruit/Adafruit LIS3DH@1.1.2\r1.1.2\r加速度センサライブラリ\r\r\rLCD\rtomozh/ST7032@0.0.0-alpha+sha.501bf64fe6\r\rLCDライブラリ\r\r\rAVR MCU\rpaulstoffregen/MsTimer2@^1.1\r\rタイマ割り込みライブラリ\r\r\rRTC\u0026MicroSD\radafruit/RTClib@^2.1.1\r\rRTCライブラリ\r\r\rSTM32 MCU\rstm32duino/STM32duino RTC @1.2.0\r1.2.0\rSTM32RTCライブラリ\r\r\rstm32duino/STM32duino Low Power@^1.2.2\r\rSTM32LowPowerライブラリ\r\r\rLTE-M\rhttps://github.com/Leafony/LteLeafV4\r\rLTE-Mライブラリ\r\r\r\rシリアルプロッター　 PlatformIOには、Arduino IDEにあるシリアルプロッターがないため、VSCodeの拡張機能であるTeleplot for VSCodeを導入します。サンプルのソースコードをダウンロードして、試して下さい。\n  GitHubからソースコードをダウンロードし、パソコンの所定の場所に保存1 します。\n ソースコード:Teleplot_Example_1    プログラムを実行して下さい。\n  画面下のteleplotの表示をクリックして、COMポートを指定して、Open を押すとグラフが表示されます   \u0026gt;varName:1234\\nという形式のシリアルメッセージは、すべてteleplotに表示されます。詳しくは、こちらを参照して下さい。\n  // Plot a sinus  Serial.print(\u0026#34;\u0026gt;sin:\u0026#34;); Serial.println(sin(i)); // Plot a cosinus  Serial.print(\u0026#34;\u0026gt;cos:\u0026#34;); Serial.println(cos(i)); サンプルアプリ・応用 PlatformIOを使った初心者向けのソースコードを準備しました。GitHubからソースコードをダウンロードし、パソコンの所定の場所に保存1 してプログラムを実行して下さい。\nAVR Beginner Examples    Item Source code     LED点滅 Blink_Pjt   バッテリ電圧読み取り Battery_Voltage_Pjt   温湿度センサ読み取り Thermo-Hygrometer_Pjt   照度センサ読み取り Illuminance_Meter_Pjt   加速度センサ読み取り Accelerometer_Pjt   スピーカ toneMelody_Pjt   人感センサ Human_Sensing_Pjt   サウンドレベルメータ Sound_Level_Meter_Pjt   LCD LCD-SW_test_Pjt    Tips MCUとBoardとの関係 LeafonyのMCUとPlatformIO IDEのBoardとの関係は、以下の様になります。\n   Type Item Platform Board Upload      AP01 AVR MCU atmelavr Arduino Pro or Pro Mini ATmega328(3.3v,8Mhz) COMポートの自動検出    AP02 ESP32 MCU Espressif 32 Espressif ESP32 Dev Module COMポートの自動検出    AP03 STM32 MCU ststm32 LEAFONY_AP03 COMポートの自動検出が出来ない。     main.cppの注意点   \u0026lt;Arduino.h\u0026gt; が必要 Arduino用のスケッチをmain.cppに貼り付けるだけでは、ビルド出来ません。先頭に、\u0026lt;Arduino.h\u0026gt; を入れる必要があります。\n  変数・関数の出現順が厳密 Arduino IDEは、関数の設定などを最後に書いてもビルドが通りますが、PlatformIOは、関数や変数は、使用する前に宣言される必要があります。\n  プロジェクトフォルダの名前変更や削除 Project Wizarで、New Projectを立ち上げると、フォルダが作成され、デフォルトでは、~/Documents/PlatformIO/Projects に保存されます。 Projectの名前変更やフォルダの削除は、Project Wizarではなく、エクスプローラから直接出来ます。\nプロジェクトフォルダの保存場所の設定 プロジェクトフォルダの保存場所の設定は、Project Wizarではなく、ターミナルから行います。\n  VSCodeを立ち上げ、ファイル→ 新しいウィンドウを開きます。\n  PlatformIO(画面左のバー)をクリックし、PLATFORMIO QUICK ACCESS（画面左）を表示させます。\n  PIO Home/Openをクリックします。\n  以下のコードを実行します。 pio settings set projects_dir ＜設定したい(絶対)パス＞\n  VSCodeを再起動します。\n  参考  PlatformIO ドキュメント  前のページに戻る\r  デフォルトの保存場所は、C:\\Users\\＜ユーザ名＞\\ドキュメント\\PlatformIO\\Projectsです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"はじめに Visual Studio Code (VSCode)は、Microsoft社が提供する軽量ながら強力なソース コード エディターで、デスクトップ上で実行され、Windows、macOS、お …","ref":"/docs/environment/avr/platformio/","title":"PlatformIO IDE for VSCodeの設定"},{"body":"Beginner Examples Here are some sample apps for beginners using various types of leaves. Let\u0026rsquo;s learn how to use it by actually moving it around.\nAVR Beginner Examples    Item Basic Extension     Blink ✓    Read battery ✓    Temperature and humidity sensor ✓    Illum sensor ✓    Accelerometer ✓    Speaker ✓ ✓   IR sensor ✓ ✓   Sound level meter ✓ ✓   LCD ✓ ✓    ESP32 Beginner Examples    Item ESP32 Wi-Fi Basic Extension     Button ✓     Real time clock ✓     microSD card ✓     Temperature and humidity sensor ✓ ✓    Illum sensor ✓ ✓    Accelerometer ✓ ✓    Speaker ✓ ✓ ✓   IR sensor ✓ ✓ ✓   Sound level meter ✓ ✓ ✓   LCD ✓ ✓ ✓    STM32 Beginner Examples    Item STM32 MCU Basic Extension     Read battery ✓ ✓    Temperature and humidity sensor ✓ ✓    Illum sensor ✓ ✓    Accelerometer ✓ ✓    Speaker ✓ ✓ ✓   IR sensor ✓ ✓ ✓   Sound level meter ✓ ✓ ✓   LCD ✓ ✓ ✓    \rAdvanced Examples　 Here are some sample apps for advanced users using various types of leaves. Take a look at the sample apps and convert your everyday objects into IoT.\nAVR Advanced Examples    Item Basic Extension LoRa Motor     Simple BLE Characteristic (in progress) ✓      Simple BLE Advertising (in progress) ✓      Web Bluetooth IoT ✓      Google sheets IoT ✓      4-sensors LCD ✓ ✓     4-sensors LCD BLE (in progress) ✓ ✓     PIR melody test ✓ ✓     Distance sensor ✓ ✓     Camera ✓ ✓     LoRa ✓ ✓ ✓    Watering plants with a motor ✓   ✓    ESP32 Advanced Examples    Item ESP32 Wi-Fi Basic     Wi-Fi touchsensor ✓    Google Sheets with ESP32 ✓ ✓   Logger Beacon ✓ ✓    STM32 Advanced Examples    Item STM32 MCU Basic     Web Bluetooth IoT with STM32 ✓ ✓   Simple Ble Beacon ✓ ✓   4-Sensors Ble Beacon (in progress) ✓ ✓   BLE Logger Beacon ✓ ✓    Back to previous page\r","excerpt":"Beginner Examples Here are some sample apps for beginners using various types of leaves. Let\u0026rsquo;s …","ref":"/en/docs/examples/","title":"Sample App"},{"body":"  \nFeatures 32-bit MCU leaf with ARM Cortex-M4 32-bit RISC core with STMicroelectronics FPU; connect USB leaf for USB connection or Shield leaf for SWD use.\nSpecification    Item Description     Part number STM32L452REI6   Core ARM Cortex-M4   Operating voltage 3.3V   Input voltage 3.0-3.6V   Flash Memory 512 KB   SRAM 160 KB   Clock frequency 80MHz   Arduino IDE Board Settings Board: ”Nucleo-64”    Board Part number: \u0026ldquo;NUCLEO L452RE\u0026rdquo;    Upload method: ”STM32CubeProgrammer(Serial)   Dimension W23×D20.5×H4.7mm    Block diagram \nPinassign \nTips About LEDs and switches \n   Item Description     LED Lights up when in write mode.   Reset switch Resets the STM32 and other devices.   Program switch Switch to change to Program mode.    Sample App How to use it with Arduino In order to use this leaf with Arduino, you need to configure the board on Arduino IDE.\nPlease refer to Environment for setting instructions.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A: First edition, November 2020  Back to previous page\r","excerpt":"Features 32-bit MCU leaf with ARM Cortex-M4 32-bit RISC core with STMicroelectronics FPU; connect …","ref":"/en/docs/leaf/processor/ap03/","title":"AP03 STM32 MCU"},{"body":"  \n特徴 STM32L452REシリーズを使用した32bit MCUリーフです。USBを使用する場合はUSBリーフを、SWDを使用する場合はShieldリーフを使用します。\n性能    Item Description     Part number STM32L452REI6   Core ARM Cortex-M4   Operating voltage 3.3V   Input voltage 3.0-3.6V   Digital I/O 16   Analog input 6   ADC 12bit   Flash Memory 512 KB   SRAM 160 KB   Clock frequency 80MHz   Others RTC with HW calendar, alarms and calibration   Arduino IDE Board Settings Board: \u0026ldquo;Leafony STM32\u0026rdquo;    Board Part number: \u0026ldquo;Leafony STM32 MCU(16MHz)\u0026rdquo;    Board Part number: \u0026ldquo;Leafony STM32 MCU(80MHz)\u0026rdquo;   Dimension W23×D20.5×H4.7mm    ブロック図 \nピン配置 \nTips LED、スイッチについて \n   Item Description     LED 書き込みモード時に点灯する   Reset switch Resets the STM32 and other devices.   Program switch Switch to change to Program mode.    サンプルアプリ Arduinoでの使用方法 本リーフをArduinoで使用するためには、Arduino IDE上でボードの設定等が必要です。\n開発環境設定のページで設定方法をご確認下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2020年11月:初版  前のページに戻る\r","excerpt":"特徴 STM32L452REシリーズを使用した32bit MCUリーフです。USBを使用する場合はUSBリーフを、SWDを使用する場合はShieldリーフを使用します。\n性能    Item …","ref":"/docs/leaf/processor/ap03/","title":"AP03 STM32 MCU"},{"body":"Template Project for Board CAD You can use Leafony\u0026rsquo;s template projects for various types of circuit CAD to help you design your boards.\n KiCad CR-8000 Design Force  I2C Address Map There are several leaves in the Leafony kit that use I2C communication.\nWhen the same I2C pin is used to communicate with multiple ICs, the same I2C address cannot be used, in principle.\nWhen using I2C communication on your own board, design your board so that the addresses do not overlap.\nThe addresses already in use are shown in the table below.\n\r\r\rType\rLeaf\rDescription\rChip\rI2C Address\r\r\r\r\rAI01\r4-Sensors\rTemperature and humidity sensor\rHTS221TR\r0x5F\r-\r-\r\rIlluminance sensor\rOPT3001\r0x45\r0x44\r-\r\r\rAccelerometer\rLIS3DHTR\r0x19\r-\r-\r\r\rAI02\rSP\u0026PIR\rPIR\rAK9754\r0x65\r0x66\r-\r\r\rAI03\rMIC\u0026VR\u0026LED\rIO Expander\rPCA9557RGVR\r0x1B\r-\r-\r\r\rAI04\rLCD\rLCD\rAQM0802A-RN-GBW\r0x3E\r-\r-\r\rIO Expander\rPCA9557RGVR\r0x1A\r0x1E\r-\r\r\rAV01-AV04\rBAT\rADC\rADC081C027CIMK\r0x50\r0x51\r0x52\r\r\rAV05\rSolar\rADC\rADC081C027CIMK\r0x52\r0x50\r0x51\r\r\rAV06\rGrove\rIO Expander\rPCA9557RGVR\r0x18\r-\r-\r\r\rAZ02\rSD\u0026RTC\rReal Time Clock\rChip\r0x68\r-\r-\r\r\r\rLeafony bus Pin layout \nBoard Manufacturing Tutorial Installation and removal of chip components These videos show you how to install and remove small chip resistors and capacitance from the leaf.\nHow to install chip components \r\rHow to remove chip components \r\rBack to previous page\r","excerpt":"Template Project for Board CAD You can use Leafony\u0026rsquo;s template projects for various types of …","ref":"/en/docs/pcb/","title":"Home-made leaf development"},{"body":"  \nFeatures A 32-bit MCU leaf with an ARM Cortex-M4 32-bit RISC core with STMicroelectronics FPU and two Leafony buses; connect a USB leaf for USB connection or a Shield leaf for SWD use Connect a USB leaf for USB connection or a Shield leaf for SWD use.\nSpecification    Item Description     Part number STM32L452REI6   Core ARM Cortex-M4   Operating voltage 3.3V   Input voltage 3.0-3.6V   Flash Memory 512 KB   SRAM 160 KB   Clock frequency 80MHz   Arduino IDE Board Settings Board: ”Nucleo-64”    Board Part number: \u0026ldquo;NUCLEO L452RE\u0026rdquo;    Upload method: ”STM32CubeProgrammer(Serial)   Dimension W23×D28×H4.7mm    Block diagram \nPinassign \nTips About LEDs and switches \n   Item Description     LED Lights up when in write mode.   Reset switch Resets the STM32 and other devices.   Program switch Switch to change to Program mode.    Sample App How to use it with Arduino In order to use this leaf with Arduino, you need to configure the board on Arduino IDE.\nPlease refer to Environment for setting instructions.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A: First edition, December 2020  Back to previous page\r","excerpt":"Features A 32-bit MCU leaf with an ARM Cortex-M4 32-bit RISC core with STMicroelectronics FPU and …","ref":"/en/docs/leaf/processor/ap04/","title":"AP04 STM32 MCU 2Bus"},{"body":"  \n特徴 STMicroelectronics FPU付きARM Cortex-M4 32-bit RISC coreを搭載し、Leafony bus2個搭載した32bit MCUリーフである。USB接続する場合はUSBリーフを接続、SWDを使用する場合はShieldリーフを接続。\n性能    Item Description     Part number STM32L452REI6   Core ARM Cortex-M4   Operating voltage 3.3V   Input voltage 3.0-3.6V   Digital I/O 32   Analog input 11   Flash Memory 512 KB   SRAM 160 KB   Clock frequency 80MHz   Arduino IDE Board Settings Board: ”Nucleo-64”    Board Part number: \u0026ldquo;NUCLEO L452RE\u0026rdquo;    Upload method: ”STM32CubeProgrammer(Serial)   Dimension W23×D28×H4.7mm    ブロック図 \nピン配置 \nTips LED、スイッチについて \n   Item Description     LED 書き込みモード時に点灯する   Reset switch Resets the STM32 and other devices.   Program switch Switch to change to Program mode.    サンプルアプリ Arduinoでの使用方法 本リーフをArduinoで使用するためには、Arduino IDE上でボードの設定等が必要です。\n開発環境設定のページで設定方法をご確認下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2020年12月:初版  前のページに戻る\r","excerpt":"特徴 STMicroelectronics FPU付きARM Cortex-M4 32-bit RISC coreを搭載し、Leafony bus2個搭載した32bit MCUリーフである。USB接続 …","ref":"/docs/leaf/processor/ap04/","title":"AP04 STM32 MCU 2Bus"},{"body":"STM32CubeIDE サンプルアプリを書き込む STM32CubeIDE使用方法  \nBeginner Examples LED点滅\n前のページに戻る\r","excerpt":"STM32CubeIDE サンプルアプリを書き込む STM32CubeIDE使用方法  \nBeginner Examples LED点滅\n前のページに戻る\r","ref":"/docs/examples-stm/","title":"STM32CubeIDE サンプルアプリ・応用例"},{"body":"基板CAD用テンプレートプロジェクト Leafonyの基板設計には各種回路CAD向けのテンプレートプロジェクトを用いると便利です。\n KiCad CR-8000 Design Force  I2C address map Leafonyキットには、I2C通信を使用しているリーフがいくつか存在します。\n同じI2Cピンを使用して複数のICと通信する場合、原則として同じI2Cアドレスを使用することはできません。\n自作基板でI2C通信を使用する場合は、アドレスが重複しないように設計して下さい。\nすでに使用されているアドレスは下表のとおりです。\n\r\r\rType\rLeaf\rDescription\rChip\rI2Cアドレス\r変更可能アドレス\r\r\r\r\rAI01\r4-Sensors\r温湿度センサ\rHTS221TR\r0x5F\r-\r-\r\r照度センサ\rOPT3001\r0x45\r0x44\r-\r\r\r加速度センサ\rLIS3DHTR\r0x19\r-\r-\r\r\rAI02\rSP\u0026PIR\rPIR\rAK9754\r0x65\r0x66\r-\r\r\rAI03\rMIC\u0026VR\u0026LED\rIOエキスパンダ\rPCA9557RGVR\r0x1B\r-\r-\r\r\rAI04\rLCD\rLCD\rAQM0802A-RN-GBW\r0x3E\r-\r-\r\rIOエキスパンダ\rPCA9557RGVR\r0x1A\r0x1E\r-\r\r\rAV01-AV04\rBAT\rADC\rADC081C027CIMK\r0x50\r0x51\r0x52\r\r\rAV05\rSolar\rADC\rADC081C027CIMK\r0x52\r0x50\r0x51\r\r\rAV06\rGrove\rIOエキスパンダ\rPCA9557RGVR\r0x18\r-\r-\r\r\rAZ02\rSD\u0026RTC\rリアルタイムクロック\rPCF8523TK\r0x68\r-\r-\r\r\r\rLeafony bus pin layout \n基板製造チュートリアル チップ部品の付け外しについて リーフに小さなチップ抵抗やチップコンデンサを取り付けたり、外す際の方法を動画でまとめています。\nチップ部品の取り付け方 \r\rチップ部品の取り外し方 \r\r前のページに戻る\r","excerpt":"基板CAD用テンプレートプロジェクト Leafonyの基板設計には各種回路CAD向けのテンプレートプロジェクトを用いると便利です。\n KiCad CR-8000 Design Force  I2C …","ref":"/docs/pcb/","title":"自作リーフ開発"},{"body":"","excerpt":"","ref":"/en/docs/lowpower/","title":"Lowpower (in progress)"},{"body":"A list of sample apps for advanced users.\nBack to previous page\r","excerpt":"A list of sample apps for advanced users.\nBack to previous page\r","ref":"/en/docs/examples/advanced/","title":"Advanced Examples"},{"body":"上級者向けサンプルアプリの一覧です。\n前のページに戻る\r","excerpt":"上級者向けサンプルアプリの一覧です。\n前のページに戻る\r","ref":"/docs/examples/advanced/","title":"Advanced Examples"},{"body":"Overview The Leafony template design data for the CR-8000 Design Force makes leaf board design easy. The template design data contains the following items.\n 2cm x 2cm Leaf outline Leafony bus footprint Other Parts Footprint Design rule  Download You can download the template design data from the link below.\nGitHub - Leafony/cad-template\nDevelopment Environment  CR-8000 Design Force 2020 or later  Usage  Start the CR-8000 Design Force. File -\u0026gt; Open -\u0026gt; Design Data. Select the template design data you downloaded and click Open.  Back to previous page\r","excerpt":"Overview The Leafony template design data for the CR-8000 Design Force makes leaf board design easy. …","ref":"/en/docs/pcb/cr-8000_design_force/","title":"CR-8000 Design Force Template Design Data"},{"body":"概要 CR-8000 Design Force向けLeafonyテンプレート設計データを使うとリーフ基板の設計を簡単に行えます。テンプレート設計データには下記の項目が設定されています。\n 2cm×2cm リーフの外形 Leafony bus フットプリント その他部品フットプリント デザインルール  ダウンロード 下記のリンクからテンプレート設計データをダウンロードできます。\nGitHub - Leafony/cad-template\n開発環境  CR-8000 Design Force 2020 or later  使い方  CR-8000 Design Forceを起動 ファイル -\u0026gt; 開く -\u0026gt; 設計データ ダウンロードしたテンプレート設計データを選択し 開く をクリック  前のページに戻る\r","excerpt":"概要 CR-8000 Design Force向けLeafonyテンプレート設計データを使うとリーフ基板の設計を簡単に行えます。テンプレート設計データには下記の項目が設定されています。 …","ref":"/docs/pcb/cr-8000_design_force/","title":"CR-8000 Design Force テンプレート設計データ"},{"body":"  --\r概要 Basic KitやESP32 Wi-Fi Kitと組み合わせて使える、便利で使い勝手の良い色々なリーフが入っているキットで、より広範な応用を実現できます。Extension Kit には、マイコンリーフが含まれていませんので、ソフトウェアを動かすためにBasic Kitか、ESP32 Wi-Fi Kit が必要です。\n内容物    Type Item Description Q’ty     AI02 SP \u0026amp; PIR 圧電スピーカと人感センサを搭載したリーフ 1   AI03 MIC \u0026amp; VR \u0026amp; LED マイク、ボリューム、LEDを搭載したリーフ 1   AI04 LCD LCDユニットとスイッチを搭載したリーフ 1   AV03 AA BAT 単3電池ホルダと昇圧回路を搭載したリーフ 1   AX01 Shield Arduino Shield、SWD、ICSPコネクタを実装した拡張リーフ 1   AX03 Leafx2 横並びに接続するリーフ 1   AX04 Spacer 間に挟むスペーサリーフ 1   AX05 I Meas. 3.3VおよびVBUSに流れる電流を測定するためのリーフ 1   AX06 Grove \u0026amp; 5V Seeed Studio製 Groveシリーズに準拠する5Vで動作するリーフ 1    Caution note 注意文言 1    リーフ一覧 \rAI02 SP\u0026amp;PIR\r\r圧電スピーカと人感センサを搭載したリーフです。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で物体の接近を検知することが可能です。\n\r \rAI03 MIC\u0026amp;VR\u0026amp;LED\r\rMEMSマイク、ボリューム、LEDを搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n\r \rAI04 LCD\r\rキャラクタLCDユニットとユーザスイッチ2個を搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n\r \rAV03 AA BAT\r\r単3電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。3つのLeafonyコネクタを搭載しより多くのリーフに電源供給が可能です。\n\r \rAX01 Shield\r\rArduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\n\r \rAX03 Leaf x2\r\rリーフを横並びに接続するためのコネクタリーフです。\n\r \rAX04 Spacer\r\r積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\n\r \rAX05 I Meas.\r\r3.3VおよびVBUSに流れる電流を測定するためのリーフです。通常Leafony busは両面とも電気的に接続されていますが、このリーフでは3.3VとVBUSのみ表裏で切断され、それぞれスルーホールに接続されています。\n\r \rAX06 Grove\u0026amp;5V\r\rSeeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\n\r \rサンプルアプリ・応用例 変更履歴  Rev A1.0: 2019年8月初版  前のページに戻る\r","excerpt":"--\r概要 Basic KitやESP32 Wi-Fi Kitと組み合わせて使える、便利で使い勝手の良い色々なリーフが入っているキットで、より広範な応用を実現できます。Extension Kit に …","ref":"/docs/products/extension/","title":"Extension Kit"},{"body":"電力に特化したLeafony Leafonyは省電力に特化した回路システムです。\n省電力化の考え方 　電子工作をする際に、回路が全体でどれくらいの電力を消費するのか、使いたい電源はそれを動かすのに十分な電力を供給できるのかといったことを考える必要が出てくるかと思います。 多くの場合、電源はUSBやACアダプタのような、数ワット程度出力可能で、かつ、長時間にわたって電力を供給できる装置が電子工作に用いられるかと思います。 この場合、使用している電源の供給能力を超えない限りは回路の電力について考えることは無いかもしれません。 一方で、回路をバッテリで動作させる場合はどうでしょうか。 設計者はいかにしてより長い時間回路を動作させることができるのかを考える必要がでてきます。 大きな電池を用いるのであれば長時間の動作は簡単かもしれません。 しかしながら、小さな腕時計のような電子機器であれば、必然的に使用する電池も小さくなります。小さな電池から取り出せる電力も小さいので、回路の消費電力のごくわずかな大小が、電池の持ち時間に大きく影響します。 Leafonyのように極めて小さなバッテリ駆動回路を開発する場合、回路をどうやって省電力に動作させるかを知っているかどうかがその回路の性能を大きく左右するのです。 この章では、Leafonyをできる限り省電力に動作させるべく、電力の考え方と省電力化のための手引きについて紹介します。\n電力の計算 　電力（単位：ワット）は\nW=V×I\rで計算できます。回路全体で消費される電力を計算したい場合は、電池から流れ出る電流を計算してあげれば、電池電圧×電源電流で回路全体の電力が求まります。 1さらに図1のように回路に接続された部品にはそれぞれ異なる電流（ここでは平均電流）が流れています。 電流はそれぞれの部品によっても、また、その動作状況によっても変化します。 抵抗のようにかけた電圧に対して流れる電流が1:1で決まる素子であれば簡単に電流を求めることができますが、 ICのような部品は、内部の回路の状態によって、ICに流れ込む電流値が変わってきます。 つまり、電流を測定するタイミングによって、その電流値は変わります。このような部品の場合はどのように電力を考えれば良いでしょうか。 それについては次に示すデジタル回路の場合と、「各部品の消費電力を知る」で説明します。\n注1：電池の場合は使用状況によって電池の電圧が変化します。\n　ICにも様々な部品があり、大きく分けて2つ、アナログ回路が組み込まれたものとデジタル回路が組み込まれたものがあります。 ここではCPUのようなデジタル回路の場合の電力の考え方について述べていきます。 デジタル回路は一般的に、論理ゲートと呼ばれる回路によって構成されています。 この論理ゲート回路は最近では一般的にトランジスタの一種であるMOSFETという素子で作られています。 この論理ゲート回路の特徴は、「入力の値が変化したときにだけ、大きな電流が流れる」ということです。 具体的な例を挙げて考えていきましょう。下図はNOTゲートの場合の例です。NOTゲートは入力ピンに入る信号を反転させる機能があります。 例えば入力ピンが0V（入力ピンがLOW）の場合、出力ピンからは5V（出力ピンがHIGH）が出力されます。 このとき、入力ピンがLOWからHIGHに変わる瞬間を考えてみましょう。一番上の時間軸グラフは入力ピンに初め0Vがかかっており、 ある瞬間に5Vがかかります。このとき二番目のグラフに示すように、出力ピンは入力ピンの変化によってその状態が徐々に変化してゆき、 0Vとなります。このとき、NOTゲートにかかる電流は三番目のグラフに示すとおり、入力ピンの状態が変化したときだけ非常に大きな電流が流れています。 ここでは、入力ピンの状態が変化していない場合に流れている電流をリーク電流、変化しているときに流れる電流をダイナミック電流と呼ぶことにします。 一般にリーク電流はダイナミック電流と比較して非常に小さいため、ここではリーク電流を無視してダイナミック電流を計算します。\n　一般に、デジタル回路の消費電力は入力する信号の周波数によって決まります。下図はNOTゲートに周波数fのクロックが入力された回路図です。 出力には寄生容量と呼ばれるコンデンサが付随しています。 このコンデンサは回路の配線や、この先に接続される論理ゲートの入力ピンに発生する寄生容量などによって決まるため、ここでは具体的にどのような値があるかを知る必要はありません。 この場合のNOTゲートで消費される電力は次の式で表されます。\nW=½ * CV^2 * f\r　ここでのWは瞬間的な電流電圧から求まるものではなく、1秒間で平均したスイッチングで発生する電力を表しています。 ここから分かることは、電力は入力するクロックの周波数に比例していて、デジタル回路の周波数が高くなれば高くなるほど電力は増大します。 CPUのような回路はクロックの周波数が高いほど計算スピードが増加しますが、一方で電力も増大してしまうということです。\n各部品の消費電力を知る 　ここまででデジタル回路が組み込まれたICの電力が周波数に依存しているということが分かりました。 しかし、私達は回路の中にどれくらいの論理ゲートが含まれているのか、どれくらいの寄生容量があるのかは、ブラックボックス化されたICの中身を見ない限り知るよしもありません。 では、どうやってICで消費される電力を見積もればよいのでしょうか。\n　実を言うと、ICの回路の中身まで私達が知る必要はありません。市販されているICの場合は必ずデータシートがあり、その資料の中に電力に関する情報が書かれていることがほとんどです。 ここでは、実際にICのデータシートの中から電力に関する記述を見つけ、回路の電力を見積もってみましょう。\nLeafonyのデータシートを参考に、各リーフで使われているICチップの電力を調べます。\n   リーフ チップ 動作モード 電力     AP01      AP01      AP01      AP01       ここに示すように、それぞれのチップによっても、また、その動作状況によっても消費される電流が違います。 次に、これらのチップが消費した電力がどれくらい電池に影響を与えるのかを計算してみましょう。\n電池持続時間 　電池の容量はAh(アンペアアワー)という単位で決まります。 Ahは電荷の量を示していて、1Ahは1時間ずっと1Aの電流を流すために必要な電荷の量を示します。\n1 Ah = 1 A * 1 h\rAhは単にどれくらいの間一定の電流を流せるかということを示しており、ここに電池の電圧は登場しません。 しかしながら、電池には1.5Vや3Vといった出力電圧が決まっており、電圧は電池によっても異なる場合があります。 同じ1Ahでも1.5Vの電池と3Vの電池では動かせる電力が変わってきます。\n電力を表す単位としてW(ワット)という単位が一般的に用いられます。 1Wは1Vの電圧がかかった回路に1Aの電流が流れた時の電力を表しています。\n1 W = 1 V * 1 A\rさらに、1時間ずっと1Wの電力を出力できる量としてWh(ワットアワーという単位があります。\n1 Wh = 1 W * 1 h\rWhを用いれば一定時間に出力できる電力量を比較することができるため、電圧が異なる電池同士でもエネルギーの比較がしやすくなります。 1\n　さて、次に実際に電池の容量がどれくらいあるのかを見ていきましょう。 電池の大きさによっても容量は異なります。 例えば、代表的な電池は下記のような容量があります。\n コイン電池(CR2032)：3.0V 220mAh (660mWh) 単三電池（ニッケル水素）：1.5V 2,000mAh (3,000mWh) リチウムイオン電池：3.7V 3,000mAh以上 (11,100mWh)  Leafonyで使われるコイン電池(CR2032)は、およそ単三電池の5分の1程度の電力量であることがわかります。\nまた、Whの定義より、3.3Vの電源電圧で100mAの電流で動作する回路を動かした場合、コイン電池は\n660 mWh / (3.3 V * 100 mA) = 2 h\r単三電池は\n3,000 mWh / (3.3 V * 100 mA) ≒ 9 h\r動作することがわかります。\nLeafonyの動作電圧とリーフごとの電流はデータシートからおおよそ計算ができるため、電池でどれくらいの時間連続動作が可能なのかを見積もることができます。\n電流が変化する回路の場合 　では、回路の消費電流が次のような場合はどうでしょうか？\n1時間のうち1分間だけ回路が動き、そのとき100mAで動作する。\r残りの59分間は回路がスリープモードに入り、そのとき回路には1mA流れている。\rこの場合、この回路が1時間にどれだけの電荷を必要とするのかを計算すればよいので、\n3.3 V * 100 mA * (1 min / 60 min) + 3.3 V * 1 mA * (59 min / 60 min) = 8.745 mWh\rが、1時間あたりに消費する電荷量となります。\nしたがって、コイン電池(CR2032)を使う場合は、\n660 mWh ÷ 8.745 mWh = 75.5 h\rとなり、83時間 = 3.45日ほど動作する計算になります。\n省電力化のアイデア 　ここでは、これまでにLeafonyのサンプルデザインで使ってきた省電力化のためのアイデアをご紹介します。\n動作周波数を可能な限り下げる この方法はサンプルスケッチ「STM32 BLE Logger Beacon」で使用しています。\n　「電力の計算」の章で紹介したように、デジタル回路の電力は周波数に比例します。Leafonyの場合、最も大きなデジタル回路はCPUです。 STM32リーフの場合、その動作周波数は標準で80MHzに設定されています。Leafonyでは、CPUの処理性能を犠牲にしつつも電力を最小限に抑えるべく、 動作周波数を80MHz、16MHzから選択できるようにしています。\n　動作周波数の選択方法については簡単です。Arduino IDEを開き、ツール → Board part number→ Leafony STM32 MCUを選択し、 利用したい周波数を選択すれば設定完了です。\n では、どうやって動作周波数を決めればよいでしょうか。\n一つは動作の内容によって大まかに決める方法があります。\n 高速な計算が必要な場合 省電力に特化したい場合  二つ目は高速な周波数で設計し動作確認を行ったスケッチを、一つずつ動作周波数を下げてテストしてみる方法があります。\n不要なコアはスリープまたは電源を落とす この方法はサンプルスケッチ「STM32 BLE Logger Beacon」で使用しています。\n　回路にはたくさんの部品が載っており、それらの部品一つ一つがすべて電力を消費します。これらの部品の中には、回路の動作中に一時的に使用しなくても良い部品も含まれているかもしれません。\n　具体的な例を見て考えていきましょう。たとえば、4-Sensorsリーフを用いて4種類のセンサを読み取り、それをBLEリーフで送信するシステムがあるとします。 このシステムでは、まず4-Sensorsリーフからデータを読み出し、読みだしたデータをBLEリーフに転送してデータを送信します。 BLEリーフでデータを送信している時間は4-SensorsリーフのセンサICは使われておらず無駄に電力を消費してしまいます。\nここで消費されるわずかな電力（しかしながらコイン電池を使う場合には非常に大きな影響力がある）を抑えるため、4-Sensorsリーフで使用しているセンサICにはすべてSleepモードが存在します。 センサ読み取り後すぐにSleepモードに移行させることによって、その電力を大幅に抑えることができ、バッテリでの長時間動作に繋がります。\n　さらに発展的な例を考えてみましょう。STM32リーフを使用する場合、STM32チップの内部も複数の回路で構成されていて、これらを個々にスリープモードにして電力を抑えることができます。\n割り込みでスリープから復帰させる この方法はサンプルスケッチ「STM32 BLE Logger Beacon」で使用しています。\n　外部からのイベントが発生したときにだけ回路を動作させたい場合は、CPUの割り込み機能を使うと非常に省電力なシステムを作ることができます。\n電力の測定   電池は使用量によって電圧が変わってくる場合があるため、精確な電力量を計算することはより複雑になります。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"電力に特化したLeafony Leafonyは省電力に特化した回路システムです。\n省電力化の考え方 　電子工作をする際に、回路が全体でどれくらいの電力を消費するのか、使いたい電源はそれを動かすのに十分 …","ref":"/docs/lowpower/","title":"省電力化の流れ"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/examples/advanced/1_p/exten/4-sensors_lcd_ble/","title":"4-Sensors LCD BLE (in progress)"},{"body":"Overview This sample reads the value of the temperature and humidity sensor on the 4-Sensors Leaf and displays it on a serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Thermo-Hygrometer // // (c) 2021 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // Data for two-point correction //--------------------------- // Temperature correction data 0 float TL0 = 25.0; // 4-Sensors Temperature measurement value float TM0 = 25.0; // Thermometer and other measurements value // Temperature correction data 1 float TL1 = 40.0; // 4-Sensors Temperature measurement value float TM1 = 40.0; // Thermometer and other measurements value  // Humidity correction data 0 float HL0 = 60.0; // 4-Sensors Humidity measurement value float HM0 = 60.0; // Hygrometer and other measurements value // Humidity correction data 1 float HL1 = 80.0; // 4-Sensors Humidity measurement value float HM1 = 80.0; // Hygrometer and other measurements value  void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); Wire.begin(); // I2C 100kHz  // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // Temperature correction  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // Humidity correction  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } Thermo-Hygrometer.ino\nTwo-point correction If there is a discrepancy between the temperature (or humidity) you want to display and the 4-Sensors\u0026rsquo; temperature (or humidity), perform a two-point correction. The following is an example of how to compensate for this, using temperature as an example.\nFirst, measure the temperature at two points with the 4-Sensors and a reference instrument. Then, write the measured values into a sample sketch and execute them, and the temperature of the 4-Sensors will be close to the temperature you want to display.　Execution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the temperature and humidity.\nBack to previous page\r","excerpt":"Overview This sample reads the value of the temperature and humidity sensor on the 4-Sensors Leaf …","ref":"/en/docs/examples/beginner/1_p/basic/temp_humid_sensors/","title":"Temperature and humidity sensor"},{"body":"Overview This sample reads the value of the temperature and humidity sensor on the 4-Sensors Leaf and displays it on a serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program1 in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Thermo-Hygrometer // // (c) 2021 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // Data for two-point correction //--------------------------- // Temperature correction data 0 float TL0 = 25.0; // 4-Sensors Temperature measurement value float TM0 = 25.0; // Thermometer and other measurements value // Temperature correction data 1 float TL1 = 40.0; // 4-Sensors Temperature measurement value float TM1 = 40.0; // Thermometer and other measurements value  // Humidity correction data 0 float HL0 = 60.0; // 4-Sensors Humidity measurement value float HM0 = 60.0; // Hygrometer and other measurements value // Humidity correction data 1 float HL1 = 80.0; // 4-Sensors Humidity measurement value float HM1 = 80.0; // Hygrometer and other measurements value  void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); Wire.begin(); // I2C 100kHz  // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // Temperature correction  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // Humidity correction  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } Thermo-Hygrometer.ino\n2 point-to-point correction If there is a discrepancy between the temperature (or humidity) that you want to display and the temperature (or humidity) of the 4-Sensors, perform the correction between the two points. The following is a description of the correction method using temperature as an example.\nFirst, measure the temperatures of the two points with the 4-Sensors and a reference instrument. Then, write the measured values in the sample sketch and run it, and the temperature of the 4-Sensors will be close to the temperature you want to display.　Execution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the temperature and humidity.\nBack to previous page\r  The program is the same as AVR MCU Leaf. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview This sample reads the value of the temperature and humidity sensor on the 4-Sensors Leaf …","ref":"/en/docs/examples/beginner/3_p/basic/temp_humid_sensors/","title":"Temperature and humidity sensor"},{"body":"前のページに戻る\r","excerpt":"前のページに戻る\r","ref":"/docs/examples/advanced/1_p/exten/4-sensors_lcd_ble/","title":"センサの値をLCDに表示しBLEで送信(公開予定)"},{"body":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Thermo-Hygrometer // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // Data for two-point correction //--------------------------- // Temperature correction data 0 float TL0 = 25.0; // 4-Sensors Temperature measurement value float TM0 = 25.0; // Thermometer and other measurements value // Temperature correction data 1 float TL1 = 40.0; // 4-Sensors Temperature measurement value float TM1 = 40.0; // Thermometer and other measurements value  // Humidity correction data 0 float HL0 = 60.0; // 4-Sensors Humidity measurement value float HM0 = 60.0; // Hygrometer and other measurements value // Humidity correction data 1 float HL1 = 80.0; // 4-Sensors Humidity measurement value float HM1 = 80.0; // Hygrometer and other measurements value  void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); Wire.begin(); // I2C 100kHz  // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // Temperature correction  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // Humidity correction  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } Thermo-Hygrometer.ino\n2点間補正 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。以下は、温度を例に、補正方法を記します。\nまず、４-Sensorsと、基準となる計測器で、２点の温度を測定してください。次に、測定した値を、サンプルスケッチに書き込んで、実行して頂ければ、４-Sensorsの温度が、表示させたい温度に近づきます。　実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、温度と湿度が表示されます。\n前のページに戻る\r","excerpt":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/1_p/basic/temp_humid_sensors/","title":"温湿度センサ読み取り"},{"body":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラム1を書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Thermo-Hygrometer // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // Data for two-point correction //--------------------------- // Temperature correction data 0 float TL0 = 25.0; // 4-Sensors Temperature measurement value float TM0 = 25.0; // Thermometer and other measurements value // Temperature correction data 1 float TL1 = 40.0; // 4-Sensors Temperature measurement value float TM1 = 40.0; // Thermometer and other measurements value  // Humidity correction data 0 float HL0 = 60.0; // 4-Sensors Humidity measurement value float HM0 = 60.0; // Hygrometer and other measurements value // Humidity correction data 1 float HL1 = 80.0; // 4-Sensors Humidity measurement value float HM1 = 80.0; // Hygrometer and other measurements value  void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); Wire.begin(); // I2C 100kHz  // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // Temperature correction  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // Humidity correction  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } Thermo-Hygrometer.ino\n2点間補正 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。以下は、温度を例に、補正方法を記します。\nまず、４-Sensorsと、基準となる計測器で、２点の温度を測定してください。次に、測定した値を、サンプルスケッチに書き込んで、実行して頂ければ、４-Sensorsの温度が、表示させたい温度に近づきます。　実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、温度と湿度が表示されます。\n前のページに戻る\r  プログラムは、AVR MCUリーフと同じです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/3_p/basic/temp_humid_sensors/","title":"温湿度センサ読み取り"},{"body":"Communication Leaf List\nBack to previous page\r","excerpt":"Communication Leaf List\nBack to previous page\r","ref":"/en/docs/leaf/communication/","title":"Communication"},{"body":"  --\r概要 Leafonyプラットフォーム用のコネクタ10個セットです。\n内容物    Type Item Q’ty     AZ61 Connector 10    一覧 \rAZ61 Connector\r\rLeafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属又は導電性エラストマの導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\n\r\r\r変更履歴  Rev A1.0: 2019年8月初版  前のページに戻る\r","excerpt":"  --\r概要 Leafonyプラットフォーム用のコネクタ10個セットです。\n内容物    Type Item Q’ty     AZ61 Connector 10    一覧 \rAZ61 …","ref":"/docs/products/conn/","title":"Connector"},{"body":"Leafony バスとは、複数のリーフ間を相互に接続する共通経路部の名称です。電気信号および電源接続を行うための電気的および物理的な仕様（20mm x 5.5mm）が定義されています。\n20mmx5.5mmの基板外形寸法 基板は、厚さt=0.8で、パッド部分は、金めっきです。基板レイアウトのデータは、AX02 29pin を参照して下さい。\n前のページに戻る\r","excerpt":"Leafony バスとは、複数のリーフ間を相互に接続する共通経路部の名称です。電気信号および電源接続を行うための電気的および物理的な仕様（20mm x 5.5mm）が定義されています。 …","ref":"/docs/leafony-bus/","title":"Leafony バス"},{"body":"A Leafony bus is the name of a common pathway section that connects multiple leaves to each other. It defines the electrical and physical specifications (20mm x 5.5mm) for the electrical signal and power connections.\n20 mm x 5.5 mm substrate dimensions The thickness of the board is t=0.8 and the pad part is gold plated. Please refer to AX02 29pin for the data of the board layout.\nBack to previous page\r","excerpt":"A Leafony bus is the name of a common pathway section that connects multiple leaves to each other. …","ref":"/en/docs/leafony-bus/","title":"Leafony-bus"},{"body":"ATM32 MCUリーフは、AVR MCUリーフと同じように、Arduino IDEで開発が出来ます。\n用意するもの  STM32 MCU Basic Kit 、Extenston KitまたはESP32 Wi-Fi Kit パソコン  プログラムの書き込み方 プログラミングのためのパソコンの設定の仕方は、開発環境設定に記載しています。\n前のページに戻る\r","excerpt":"ATM32 MCUリーフは、AVR MCUリーフと同じように、Arduino IDEで開発が出来ます。\n用意するもの  STM32 MCU Basic Kit 、Extenston Kitまた …","ref":"/docs/getting-started/stm32/","title":"STM32 MCU スタートガイド"},{"body":"無線通信リーフ一覧\n前のページに戻る\r","excerpt":"無線通信リーフ一覧\n前のページに戻る\r","ref":"/docs/leaf/communication/","title":"通信"},{"body":"Overview This sample reads the value of the illuminance sensor on the 4-Sensors leaf and displays it on the serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Illuminance meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the illuminance.\nBack to previous page\r","excerpt":"Overview This sample reads the value of the illuminance sensor on the 4-Sensors leaf and displays it …","ref":"/en/docs/examples/beginner/1_p/basic/illum_sensor/","title":"Illum sensor"},{"body":"Overview This sample reads the value of the illuminance sensor on the 4-Sensors leaf and displays it on the serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program1 in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Illuminance meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the illuminance.\nBack to previous page\r  The program is the same as AVR MCU Leaf. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview This sample reads the value of the illuminance sensor on the 4-Sensors leaf and displays it …","ref":"/en/docs/examples/beginner/3_p/basic/illum_sensor/","title":"Illum sensor"},{"body":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Illuminance meter // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、照度が表示されます。\n前のページに戻る\r","excerpt":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/1_p/basic/illum_sensor/","title":"照度センサ読み取り"},{"body":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラム1を書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Illuminance meter // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、照度が表示されます。\n前のページに戻る\r  プログラムは、AVR MCUリーフと同じです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/3_p/basic/illum_sensor/","title":"照度センサ読み取り"},{"body":"用意するもの  ESP32 Wi-Fi Kit USBケーブル(データ転送用) パソコン (Windows、macOS 、または Linux)  Arduino IDEのインストール 以下の手順で、Arduino IDEをインストールを行います。\n Arduinoのホームページ からSOFTWAREのページを開きます。 Downloadで、インストーラをダウンロードします。 画面の指示に従って、インストールします。  Previous IDE ダウンロード 下記より、Previous IDEのダウンロードが出来ます。\nPrevious IDE Releases\nパソコンと接続 USBケーブルでPCと接続します。\nマイコンボードの設定  esp32のボードは、webサイトからインストールします。ファイル → 環境設定を開き、追加のボードマネージャのURL:に、下記URLを入力してください。  　https://dl.espressif.com/dl/package_esp32_index.json\n\n ツール→ボード→ボードマネージャを選択します。\n  ボードマネージャの検索ボックスにesp32を入力してインストールします。バージョンを選択が出来ます。   \n ツール → ボード → ESP32 Dev Moduleをクリックします。\n  ツール → シリアルポートから、Leafonyが接続されているシリアルポートを選択します。シリアルポートが選択出来ない場合は、シリアルポートが見つからないを参照して下さい。\n  マイコンボードの動作確認  Arduino IDEを起動し、下記のサンプルコードをコードエディタに貼り付けます。  //***************************** // ボタン入力の状態をシリアルモニタに表示するサンプル //***************************** int pushButton = 0; void setup() { Serial.begin(115200); pinMode(pushButton, INPUT); } void loop() { int buttonState = digitalRead(pushButton); Serial.println(buttonState); delay(1); } ESP32 MCUリーフが接続されているシリアルポートを選択します。 マイコンボードに書き込むボタンを押して、スケッチを書き込みます。 書き込み中に下記の表示が出たら、ESP32リーフのBootモードスイッチを長押しします。  \nシリアルモニタを開いて、通信速度を115200bpsにします。 Bootモードスイッチ(IO0)を押してスイッチの入力状態が変わるのを確認します。  \nスケッチのピンの指定 ピンは、名前(Name)ではなく、ポート(Port)で指定して下さい。 \n※1：出力の設定は出来ません。 ※2：WiFi.hをインクルードする場合は、アナログ入力として使用出来ません。UART1は、ピン番号をRX=26、TX=25に設定です。UART0、2に関しては、ピン番号の指定はありません。下記に、UART1の設定例を記します。\nHardwareSerial Serial1(1); // UART1 (RX=9, TX=10)  void setup() { Serial1.begin(9600, SERIAL_8N1, 26, 25); // ピンを変更 (RX=26, TX=25) } ※3:ブートストラップに使用しているため、プルアップ禁止です。\nライブラリのインストール プログラムを書き込むには、ライブラリのインストールが必要なリーフがあります。下記より、インストールしてください。\nライブラリのインストール\n困ったときには お問い合わせをする前に、困ったときにはを読んでみてください。\n前のページに戻る\r","excerpt":"用意するもの  ESP32 Wi-Fi Kit USBケーブル(データ転送用) パソコン (Windows、macOS 、または Linux)  Arduino IDEのインストール 以下の手順 …","ref":"/docs/environment/esp32/arduino/","title":"Arduino IDEの設定"},{"body":"Processor \rAP01 AVR MCU\r\rThis leaf uses the ATmega328P and features 14 digital input and output pins (six of which can be used as PWM outputs), six analog input pins, an 8 MHz oscillator, and a reset button.\nBasic Kit 2\r\r\r\rAP02 ESP32 MCU\r\rEspressif Systems\u0026rsquo; ESP32-WROOM-32 32-bit MCU leaf with a module ESP32-WROOM-32 with built-in technically certified Wi-Fi and Bluetooth LE, which includes a USB to UART conversion IC and can write sketches. A step-down power supply circuit provides VBUS and 3.3V. It also has a reset button.\nESP32 Wi-Fi Kit\r\r \rAP03 STM32 MCU\r\r32-bit MCU leaf with ARM Cortex-M4 32-bit RISC core with STMicroelectronics FPU; connect USB leaf for USB connection or Shield leaf for SWD use.\n\r \rCommunication \rAC02 BLE Sugar\r\rThe Leaf is equipped with Silicon Labs\u0026rsquo; technically certified Bluetooth LE module BGM11S22F256GA-V2.\nBasic Kit 2\r\r\r\rAC03 LoRa Easy\r\rThe Leaf is equipped with EASEL\u0026rsquo;s technically certified LoRa module ES920LRA1.\n\r \rIO \rAI01 4-Sensors\r\rThis leaf is equipped with a temperature/humidity sensor, an illuminance sensor and an acceleration sensor. Equipped with power-saving sensors and suitable for long-term sensing.\nBasic Kit 2\r\r\r\rAI02 SP\u0026amp;PIR\r\rThe Leaf is equipped with a piezoelectric speaker and a motion sensor. The motion sensor has a built-in proximity detection algorithm and can detect the approach of an object with simple settings.\nExtension Kit\r\r \rAI03 MIC\u0026amp;VR\u0026amp;LED\r\rThis leaf is equipped with a MEMS microphone, volume and LED. It can be powered off with a load switch by controlling the I2C Expander to achieve low power consumption.\nExtension Kit\r\r \rAI04 LCD\r\rThis leaf is equipped with a character LCD unit and two user switches. It can be powered off with a load switch by controlling the I2C Expander to achieve low power consumption.\nExtension Kit\r\r \rPower \rAV01 CR2032\r\rThis power supply leaf contains a CR2032 coin cell battery holder, a power switch, an AD converter for voltage monitoring, and a 3.3 V to 3.3 V step-up circuit. 2cm x 2cm in size, it is capable of supplying 3.3 V power.\nBasic Kit 2\r\r\r\rAV02 CR2450\r\rThis power supply leaf contains a CR2450 coin cell battery holder, a power switch, an AD converter for voltage monitoring, and a 3 V to 3.3 V step-up circuit.\n\r \rAV03 AA BAT\r\rThis is a power supply leaf with an AA battery holder, a power switch, an AD converter for voltage monitoring, a 3 V to 3.3 V boost circuit, and three Leafony connectors to provide power to more leaves.\nExtension Kit\r\r \rAV04 2V～4.5V\r\rThe power supply leaflet contains a JST SH connector for lithium-ion battery or battery box connection, a power switch, an AD converter for voltage monitoring and a 3.3 V step-up/down circuit.\nESP32 Wi-Fi Kit\r\r \rExtension \rAX01 Shield\r\rAn expansion board with an Arduino Shield connector, a SWD connector, an ICSP connector, and three leaf I/Fs mounted on it.\nExtension Kit\r\r\r\rAX02 29pin\r\rA leaf with all 29 pins of the leaf I/F connected to a 2.54mm pitch through-hole.\nBasic Kit 2\r\r \rAX03 Leaf x2\r\rThis connector leaf is used to connect the leafs side-by-side.\nExtension Kit\r\r \rAX04 Spacer\r\rA spacer leaf that is placed between two stacked leaves. It can be used when parts of the leafs interfere with each other.\nExtension Kit\r\r \rAX05 I Meas.\r\rThis leaf is used to measure the current flowing in the 3.3V and VBUS. Normally, the Leafony bus is electrically connected on both sides, but in this leaf, only the 3.3V and VBUS are disconnected in the front and the back, and they are connected to the through-hole.\nExtension Kit\r\r \rAX06 Grove\u0026amp;5V\r\rThe Grove is a Grove Series compliant leaf from Seeed Studio that operates at 5V with UART, I2C, analog and digital inputs, converted from 3.3V to 5V by a step-up power supply circuit and supplied to the Grove. To achieve low power consumption, it is possible to turn off the 5V power supply by controlling the I2C Expander.\nExtension Kit\r\r \rAX07 Back to back\r\rA connector leaf that can be connected back to back.\nESP32 Wi-Fi Kit\r\r \rAX08 29pin header\r\rA leaf with all 29 pins of the leaf I/F connected to a 2.54mm pitch pin header.\nESP32 Wi-Fi Kit\r\r \rOthers \rAZ01 USB\r\rA leaf to connect when writing a sketch to an AVR MCU or using a serial monitor. FTDI\u0026rsquo;s FT232RQ is mounted as a USB-UART conversion IC. It converts from USB VBUS (5V) to 3.3V with a step-down power supply circuit and supplies VBUS and 3.3V to each leaf.\nBasic Kit 2\r\r\r\rAZ02 RTC\u0026amp;microSD\r\rThis leaf is equipped with NXP\u0026rsquo;s Real-Time Clock PCF8523TK and a microSD card slot. The RTC can output interrupts to the MCU with alarms and timers, while the microSD card is accessible via SPI.\nESP32 Wi-Fi Kit\r\r \rAZ61 Connector\r\rThe Leafony Platform is based on ACRs (Anisotropic Conductive Rubber), which is an insulating silicone rubber with metal or conductive elastomeric conductive elements arranged at a narrow pitch, which can be compressed to create an electrical connection.\nConnector\r\r \rAZ62 Connector Cover\r\rThe Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris.\nNut \u0026 Conn. Cover\r\r \rAZ63 Nut Plate\r\rThe Nut Plate is used to fix the leaf with a screw. Be careful not to use commercially available hex nuts as they may cause a short circuit by touching the electrodes on the board.\nNut \u0026 Conn. Cover\r\r \rAZ66 Basic kit case\r\rThis is a case for the Basic Kit. It can be fixed to the wall with the magnets on the bottom.\nBasic Kit 2\r\r \rBack to previous page\r","excerpt":"Processor \rAP01 AVR MCU\r\rThis leaf uses the ATmega328P and features 14 digital input and output pins …","ref":"/en/docs/leaf/","title":"Leaf Technical Sheets"},{"body":"  --\r概要 リーフをねじで固定する時に使用するNut Plate と ACR に付着するゴミを防御するコネクタカバーです。\n内容物    Type Item Q’ty     AZ63 Nut Plate 10   AZ62 Connector Cover 10    一覧 \rAZ63 Nut Plate\r\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n\r\r\rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \r変更履歴  Rev A1.0: 2019年8月初版  前のページに戻る\r","excerpt":"  --\r概要 リーフをねじで固定する時に使用するNut Plate と ACR に付着するゴミを防御するコネクタカバーです。\n内容物    Type Item Q’ty     AZ63 Nut …","ref":"/docs/products/nut/","title":"Nut Plate \u0026 Connector Cover"},{"body":"プロセッサ \rAP01 AVR MCU\r\rATmega328Pを使用したリーフです。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。\nBasic Kit 2\r\r\r\rAP02 ESP32 MCU\r\rEspressif Systemsの、技的認証済みWi-FiとBluetooth LEを内蔵したモジュールESP32-WROOM-32を搭載した32bit MCUリーフです。USB-UART変換ICを搭載し、スケッチの書き込みができます。USBのVBUS(5V)から降圧電源回路により、VBUSと3.3Vを供給します。また、リセットボタンを備えています。\nESP32 Wi-Fi Kit\r\r \rAP03 STM32 MCU\r\rSTM32L452REシリーズを使用した32bit MCUリーフです。USBを使用する場合はUSBリーフを、SWDを使用する場合はShieldリーフを使用します。\nBasic Kit 2\r\r \r通信 \rAC02 BLE Sugar\r\rSilicon Labsの技的認証済みBluetooth LEモジュールBGM11S22F256GA-V2を搭載したリーフです。\nBasic Kit 2\r\r\r\rAC03 LoRa Easy\r\rEASELの技的認証済みLoRaモジュールES920LRA1を搭載したリーフです。\n\r \rAC04 LTE-M King M\r\r豊富なセンサー類とLTE-M通信機能を持ったKDDIのLTE-M King Mリーフです。\n\r \rAC05 LTE-M King S\r\rKDDI LTE-M King Mリーフの電源供給用リーフです。\n\r \rIO \rAI01 4-Sensors\r\r温湿度センサ、照度センサ、加速度センサを搭載したリーフです。省電力なセンサを搭載し長時間のセンシングに適しています。\nBasic Kit 2\r\r\r\rAI02 SP\u0026amp;PIR\r\r圧電スピーカと人感センサを搭載したリーフです。人感センサは接近検知アルゴリズムを内蔵しており、簡単な設定で物体の接近を検知することが可能です。\nExtension Kit\r\r \rAI03 MIC\u0026amp;VR\u0026amp;LED\r\rMEMSマイク、ボリューム、LEDを搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\nExtension Kit\r\r \rAI04 LCD\r\rキャラクタLCDユニットとユーザスイッチ2個を搭載したリーフです。低消費電力を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\nExtension Kit\r\r \r電源 \rAV01 CR2032\r\rCR2032コイン電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。2cm x 2cmのサイズで3.3Vの電源を供給可能です。\nBasic Kit 2\r\r\r\rAV02 CR2450\r\rCR2450コイン電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。\n\r \rAV03 AA BAT\r\r単3電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。3つのLeafonyコネクタを搭載しより多くのリーフに電源供給が可能です。\nExtension Kit\r\r \rAV04 2V～4.5V\r\rリチウムイオンバッテリや電池ボックス接続用のJST製SHコネクタと電源スイッチ、電圧モニタ用のADコンバータ、3.3V昇降圧回路を搭載した電源リーフです。2V～4.5Vの電池電圧入力に対応しています。\nESP32 Wi-Fi Kit\r\r \r拡張 \rAX01 Shield\r\rArduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\nExtension Kit\r\r\r\rAX02 29pin\r\rリーフI/Fの29ピン全てを2.54mmピッチのスルーホールに接続したリーフです。\nBasic Kit 2\r\r \rAX03 Leaf x2\r\rリーフを横並びに接続するためのコネクタリーフです。\nExtension Kit\r\r \rAX04 Spacer\r\r積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\nExtension Kit\r\r \rAX05 I Meas.\r\r3.3VおよびVBUSに流れる電流を測定するためのリーフです。通常Leafony busは両面とも電気的に接続されていますが、このリーフでは3.3VとVBUSのみ表裏で切断され、それぞれスルーホールに接続されています。\nExtension Kit\r\r \rAX06 Grove\u0026amp;5V\r\rSeeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\nExtension Kit\r\r \rAX07 Back to back\r\rリーフを背中合わせに接続可能なコネクタリーフです。\nESP32 Wi-Fi Kit\r\r \rAX08 29pin header\r\rリーフI/Fの29ピン全てを2.54mmピッチのピンヘッダに接続したリーフです。\nESP32 Wi-Fi Kit\r\r \rその他 \rAZ01 USB\r\rAVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\nBasic Kit 2\r\r\r\rAZ02 RTC\u0026amp;microSD\r\rNXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。microSDカードはSPIでアクセスします。\nESP32 Wi-Fi Kit\r\r \rAZ61 Connector\r\rLeafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属の導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\nConnector\r\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\nNut \u0026 Conn. Cover\r\r \rAZ63 Nut Plate\r\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\nNut \u0026 Conn. Cover\r\r \rAZ66 Basic Kit Case\r\rBasic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\nBasic Kit 2\r\r \rAZ67 AAA battery holder\r\rJST製SHコネクタが付き、単4電池ホルダです。\nESP32 Wi-Fi Kit\r\r \rAZ68 18650 battery holder\r\rJST製SHコネクタが付き、18650(直径18mmｘ長さ65mm)電池ホルダです。\nESP32 Wi-Fi Kit\r\r \r前のページに戻る\r","excerpt":"プロセッサ \rAP01 AVR MCU\r\rATmega328Pを使用したリーフです。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセット …","ref":"/docs/leaf/","title":"リーフ技術資料"},{"body":"Overview Using LoRa Easy leaf, sensor data (temperature, humidity, illumination, tilt) can be sent to a distant location and output to a PC terminal.\n\nIf there is a discrepancy between the temperature (or humidity) you want to display and the temperature (or humidity) of the 4-Sensors, perform the correction between the two points. For details, see here.\nDemo Video \r\rLeaf to use Use the following leaves.\nSending side leaf    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AX04 Spacer 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV03 CR2032 1   AZ01 USB 1   AZ61 Connector 2   AZ62 Connector Cover 3   AZ63 Nut Plate 2    AA battery 1    M2*25mm screw 6    Receiving side leaf    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AP01 AVR MCU 1   AX03 Leaf x2 1   AZ01 USB 1   AZ62 Connector Cover 2   AZ63 Nut Plate 2    M2*15mm screw 4    Assembly Assemble the leaves as shown in the figure below.\nSending side Receiving side Source code  4-Sensors and AVR MCU library (timer interrupt) are required for writing. Please include the library beforehand. For details, see here. In the Arduino IDE, write the following program.  Sending side 4-Sensors_LoRa_Tx.ino Receiving side LoRa_Rx_Serial_monitor.ino     Execution result Open the serial monitor in the Arduino IDE and set the baud rate to 9600 bps to display the sensor data (temperature, humidity, illumination, and tilt).\nBack to previous page\r","excerpt":"Overview Using LoRa Easy leaf, sensor data (temperature, humidity, illumination, tilt) can be sent …","ref":"/en/docs/examples/advanced/1_p/lora/lora/","title":"LoRa"},{"body":"Overview This sample reads the value of the accelerometer on the 4-Sensors Leaf and displays it on a serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below. Source code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries. If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Accelerometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the acceleration and tilt.\nBack to previous page\r","excerpt":"Overview This sample reads the value of the accelerometer on the 4-Sensors Leaf and displays it on a …","ref":"/en/docs/examples/beginner/1_p/basic/accelerometer/","title":"Accelemeter"},{"body":"Overview This sample reads the value of the accelerometer on the 4-Sensors Leaf and displays it on a serial monitor.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program1 in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries. If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Accelerometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\nExecution Results Open the serial monitor of the Arduino IDE and set the baud rate to 115200 bps and you will see the acceleration and tilt.\nBack to previous page\r  The program is the same as AVR MCU Leaf. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview This sample reads the value of the accelerometer on the 4-Sensors Leaf and displays it on a …","ref":"/en/docs/examples/beginner/3_p/basic/accelerometer/","title":"Accelerometer"},{"body":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。\n\n表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。詳しくは、こちら。\nデモ動画 \r\r使用するリーフ 以下のリーフを使用します。\n送信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AX04 Spacer 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV03 CR2032 1   AZ01 USB 1   AZ61 Connector 2   AZ62 Connector Cover 3   AZ63 Nut Plate 2    AA battery 1    M2*25mm screw 6    受信側リーフ    Type Name Q\u0026rsquo;ty     AC03 LoRa Easy 1   AP01 AVR MCU 1   AX03 Leaf x2 1   AZ01 USB 1   AZ62 Connector Cover 2   AZ63 Nut Plate 2    M2*15mm screw 4    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\n送信側 受信側 ソースコード  書き込みには、4-Sensorsと、AVR MCUライブラリ（タイマ割り込み）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで、下記のプログラムを書きましょう。  送信側 4-Sensors_LoRa_Tx.ino 受信側 LoRa_Rx_Serial_monitor.ino     実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを9600bpsとすると、センサデータ（温度・湿度・照度・傾き）が表示されます。\n前のページに戻る\r","excerpt":"概要 LoRa Easyリーフを使って、センサデータ（温度・湿度・照度・傾き）を、遠く離れた場所に送り、パソコンのターミナルに出力します。\n\n表示させたい温度（または、湿度）と４-Sensorsの温 …","ref":"/docs/examples/advanced/1_p/lora/lora/","title":"LoRaを使ってセンサの値を表示"},{"body":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Accelerometer // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、加速度と傾きが表示されます。\n前のページに戻る\r","excerpt":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/1_p/basic/accelerometer/","title":"加速度センサ読み取り"},{"body":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラム1を書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Accelerometer // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、加速度と傾きが表示されます。\n前のページに戻る\r  プログラムは、AVR MCUリーフと同じです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/3_p/basic/accelerometer/","title":"加速度センサ読み取り"},{"body":"はじめに Visual Studio Code (VSCode)は、Microsoft社が提供する軽量ながら強力なソース コード エディターで、デスクトップ上で実行され、Windows、macOS、および Linux で使用できます。PlatformIO IDEは、VSCodeの拡張機能で、ビルドが早く、ライブラリやボードのバージョンがプロジェクト毎に管理されているのが特長です。 \n用意するもの  ESP32 Wi-Fi Kit 2 パソコン (Windows、macOS 、または Linux)  事前準備 Pythonのインストール  PlatformIO IDEを動かすには、Pythonが必要です。こちらを参照して、Pythonインストールして下さい。  PlatformIO IDEのインストール  PlatformIO IDEは、VSCodeの拡張機能なので、まず、VSCodeをインストールして下さい。 拡張機能(画面左のバー)をクリックし、検索窓に以下を入力して、拡張機能をインストールします。  Japanese Language Pack for Visual Studio Code platformio ide Serial Monitor teleplot    クイックスタート 「Hello Wolrd」の事例で、platformIO IDEの使い方を紹介します。\n  VSCodeを立ち上げ、ファイル→ 新しいウィンドウを開きます。\n  PlatformIO(画面左のバー)をクリックし、PLATFORMIO QUICK ACCESS（画面左）を表示させます。\n  PIO Home/Openをクリックします。\n  New Projectをクリックすると、Project Wizardが表示されます。Name、Boad、Frameworkを以下の通り入力して、Finishをクリックします。新しいBoardを選択した時、プログラミングに必要なファイルのダウンロードするために数分かかります。\n Name:ESP32_Hellow_Wolrd_Pjtと記入  Board:Espressif ESP32 Dev Module を選択  Framework:Arduino を選択     platformio.ini (画面左）を開き、 Projectで定義したBoardとFrameworkが、正しく定義されていることを確認します。\n  [env:esp32dev] platform = espressif32 board = esp32dev framework = arduino  ESP32 MCUは、アップロード時に、COMポートの自動検出をするため、COMポートの番号の指定が不要になります。\n  シリアル通信のボーレートをmonitor_speed =で定義します。以下の様に、platformio.iniに加えて下さい。\n  monitor_speed = 115200 src/main.cpp(画面左）を開き、以下のコードを貼り付けて下さい。 PlatformIO IDEのコードは、Arduino IDEのスケッチの先頭に#include \u0026lt;Arduino.h\u0026gt;を加えます。  #include \u0026lt;Arduino.h\u0026gt; void setup() { Serial.begin(115200); delay(10); } void loop(){ Serial.println(\u0026#34;Hello World\u0026#34;); delay(1000); }  ソースコード：ESP32_Hello_Wold.Pjt   PlatformIO ツールバー(画面下のバー)のProject Environment Switcherボタンを押すと、アクティブなプロジェクが画面上側に全て表示されます。実行するプロジェクトを正しく選択して、Buildボタンを押して下さい。 \n  こちら を参考に、LeafonyをPCに接続して下さい。\n  Uploadボタンを押すと、プログラムがMCUに書き込まれます。\n  MCUのリセットボタンを押して、プログラムを実行させます。\n  シリアルモニターボタンを押して起動させ、Hello Wolrdを表示が出来れば完成です。 \n  ライブラリ   インストールの仕方 ライブラリは、platformio.ini の最後の行に、lib_deps =で定義すれば、PCにインストールされます。定義の仕方は、GitHubのURLを直接指定する方法とLibrariesで指定する方法の二通りがあります。 \n  各リーフのライブラリ一覧は、以下の通りです。\n  \r\rItem\rlib_deps\rTags\rDescription\r\r\r\r\rBLE\rhttps://github.com/Leafony/TBGLib\r\rBluetoothライブラリ\r\r\r4-Sensors\radafruit/Adafruit Unified Sensor@^1.1.6\r\rユニファイドセンサドライバ\r\r\radafruit/Adafruit BusIO@^1.14.1\r\rBus IOライブラリ\r\r\rhttps://github.com/ameltech/sme-hts221-library\r\r温湿度センサライブラリ\r\r\rclosedcube/ClosedCube OPT3001@^1.1.2\r\r照度センサライブラリ\r\r\radafruit/Adafruit LIS3DH@1.1.2\r1.1.2\r加速度センサライブラリ\r\r\rLCD\rtomozh/ST7032@0.0.0-alpha+sha.501bf64fe6\r\rLCDライブラリ\r\r\rAVR MCU\rpaulstoffregen/MsTimer2@^1.1\r\rタイマ割り込みライブラリ\r\r\rRTC\u0026MicroSD\radafruit/RTClib@^2.1.1\r\rRTCライブラリ\r\r\rSTM32 MCU\rstm32duino/STM32duino RTC @1.2.0\r1.2.0\rSTM32RTCライブラリ\r\r\rstm32duino/STM32duino Low Power@^1.2.2\r\rSTM32LowPowerライブラリ\r\r\rLTE-M\rhttps://github.com/Leafony/LteLeafV4\r\rLTE-Mライブラリ\r\r\r\rシリアルプロッター　 PlatformIOには、Arduino IDEにあるシリアルプロッターがないため、VSCodeの拡張機能であるTeleplot for VSCodeを導入します。サンプルのソースコードをダウンロードして、試して下さい。\n  GitHubからソースコードをダウンロードし、パソコンの所定の場所に保存1 します。\n ソースコード:ESP32_Teleplot_Example_1    プログラムを実行して下さい。\n  画面下のteleplotの表示をクリックして、COMポートを指定して、Open を押すとグラフが表示されます   \u0026gt;varName:1234\\nという形式のシリアルメッセージは、すべてteleplotに表示されます。詳しくは、こちらを参照して下さい。\n  // Plot a sinus  Serial.print(\u0026#34;\u0026gt;sin:\u0026#34;); Serial.println(sin(i)); // Plot a cosinus  Serial.print(\u0026#34;\u0026gt;cos:\u0026#34;); Serial.println(cos(i)); サンプルアプリ・応用 PlatformIOを使った初心者向けのソースコードを準備しました。GitHubからソースコードをダウンロードし、パソコンの所定の場所に保存1 してプログラムを実行して下さい。\nESP32 Beginner Examples    Item Source code     ボタン入力    リアルタイムクロック    microSDカード    温湿度センサ読み取り    照度センサ読み取り    加速度センサ読み取り    スピーカ    人感センサ    サウンドレベルメータ    LCD     Tips MCUとBoardとの関係 LeafonyのMCUとPlatformIO IDEのBoardとの関係は、以下の様になります。\n   Type Item Platform Board Upload      AP01 AVR MCU atmelavr Arduino Pro or Pro Mini ATmega328(3.3v,8Mhz) COMポートの自動検出    AP02 ESP32 MCU Espressif 32 Espressif ESP32 Dev Module COMポートの自動検出    AP03 STM32 MCU ststm32 LEAFONY_AP03 COMポートの自動検出が出来ない。     main.cppの注意点   \u0026lt;Arduino.h\u0026gt; が必要 Arduino用のスケッチをmain.cppに貼り付けるだけでは、ビルド出来ません。先頭に、\u0026lt;Arduino.h\u0026gt; を入れる必要があります。\n  変数・関数の出現順が厳密 Arduino IDEは、関数の設定などを最後に書いてもビルドが通りますが、PlatformIOは、関数や変数は、使用する前に宣言される必要があります。\n  プロジェクトフォルダの名前変更や削除 Project Wizarで、New Projectを立ち上げると、フォルダが作成され、デフォルトでは、~/Documents/PlatformIO/Projects に保存されます。 Projectの名前変更やフォルダの削除は、Project Wizarではなく、エクスプローラから直接出来ます。\nプロジェクトフォルダの保存場所の設定 プロジェクトフォルダの保存場所の設定は、Project Wizarではなく、ターミナルから行います。\n  VSCodeを立ち上げ、ファイル→ 新しいウィンドウを開きます。\n  PlatformIO(画面左のバー)をクリックし、PLATFORMIO QUICK ACCESS（画面左）を表示させます。\n  PIO Home/Openをクリックします。\n  以下のコードを実行します。 pio settings set projects_dir ＜設定したい(絶対)パス＞\n  VSCodeを再起動します。\n  参考  PlatformIO ドキュメント  前のページに戻る\r  デフォルトの保存場所は、C:\\Users\\＜ユーザ名＞\\ドキュメント\\PlatformIO\\Projectsです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"はじめに Visual Studio Code (VSCode)は、Microsoft社が提供する軽量ながら強力なソース コード エディターで、デスクトップ上で実行され、Windows、macOS、お …","ref":"/docs/environment/esp32/platformio/","title":"PlatformIO IDE for VSCodeの設定"},{"body":"Overview Using the infrared sensor IC for short range detection (AKM AK9754AE) installed in the SP\u0026amp;PIR leaf, let\u0026rsquo;s create a system that plays a melody when a person approaches.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Assemble the leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n//===================================================================== // Leafony Platform sample sketch // Platform : PIR\u0026amp;SP // Processor : ATmega328P (3.3V /8MHz) // Application : PIR with SP Beep // // Leaf configuration // (1) AI02 SP\u0026amp;PIR // (2) AP01 AVR MCU // (3) AZ01 USB // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //===================================================================== // difinition //===================================================================== #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;Arduino.h\u0026gt;#include \u0026lt;Wire.h\u0026gt;#include \u0026#34;pitches.h\u0026#34; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; #define I2C_RECEIVE_BUF_LENGTH 10 unsigned char i2c_receiveBuf[I2C_RECEIVE_BUF_LENGTH]; unsigned char i2c_receiveLenght; //------------------------------ // buzzer output = 5pin //------------------------------ #define BUZZER_OUT 5  byte readReg; double irData; double tempData; char buf[120]; volatile int state = 0; //===================================================================== // setup //===================================================================== void setup() { //pinMode(2, INPUT);  attachInterrupt(0,catchHuman , FALLING ); //人接近検知割り込み  Wire.begin(); Serial.begin( 115200 ); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); } //===================================================================== // Main loop //===================================================================== void loop() { clearI2CReadbuf(); i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_receiveBuf); sprintf(buf, \u0026#34;REG = %02X , %02X , %02X , %02X , %02X , %02X\u0026#34;, i2c_receiveBuf[0], i2c_receiveBuf[1], i2c_receiveBuf[2], i2c_receiveBuf[3], i2c_receiveBuf[4], i2c_receiveBuf[5]); Serial.println(buf); sprintf(buf, \u0026#34;Human detection = %d\u0026#34;, (i2c_receiveBuf[0] \u0026amp; 0x10) \u0026gt;\u0026gt; 4 ); Serial.println(buf); //IRセンサ測定データ  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); //センサ温度  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); if (state == 1){ //------------------------------  // notes in the melody:  //------------------------------  int melody[] = { NOTE_C5, NOTE_C5, NOTE_G5, NOTE_G5, NOTE_A5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_F5, NOTE_E5, NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5 }; //------------------------------  // note durations: 4 = quarter note, 8 = eighth note, etc.:  //------------------------------  int noteDurations[] = { 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 2 }; //----------------------------------------  // iterate over the notes of the melody:  //----------------------------------------  for (int thisNote = 0; thisNote \u0026lt; 14; thisNote++) { //----------------------------------------  // to calculate the note duration, take one second  // divided by the note type.  //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.  //----------------------------------------  int noteDuration = 1000 / noteDurations[thisNote]; tone(BUZZER_OUT, melody[thisNote], noteDuration); //----------------------------------------  // to distinguish the notes, set a minimum time between them.  // the note\u0026#39;s duration + 30% seems to work well:  //----------------------------------------  float pauseBetweenNotes = noteDuration * 1.30; delay(pauseBetweenNotes); //-----------------------  // stop the tone playing:  //-----------------------  noTone(BUZZER_OUT); } state = 0; } delay(1000); } //===================================================================== void catchHuman(){ state = 1; Serial.println(\u0026#34;!! Interrupt !!\u0026#34;); //人の接近を検知 } //===================================================================== double clacTemp(){ double ret; unsigned short val = (unsigned short)((i2c_receiveBuf[4] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } //===================================================================== double clacIR(){ double ret; unsigned short val = (unsigned short)((i2c_receiveBuf[2] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C スレーブデバイスに1バイト書き込む **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから1バイト読み込む **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C スレーブデバイスに複数バイト書き込む **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから複数バイト読み込む **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C 受信バッファクリア **********************************************/ void clearI2CReadbuf(){ memcpy(i2c_receiveBuf, 0x00, I2C_RECEIVE_BUF_LENGTH); } PIR_Melody_test.ino\nExecution result The melody sounds when someone approaches.\nBack to previous page\r","excerpt":"Overview Using the infrared sensor IC for short range detection (AKM AK9754AE) installed in the …","ref":"/en/docs/examples/advanced/1_p/exten/pir_melody_test/","title":"PIR melody test"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/examples/beginner/1_p/exten/","title":"Basic Kit + Extension Kit"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/examples/beginner/3_p/exten/","title":"STM32 MCU + Basic Kit + Extension Kit"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたらメロディが鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // Leafony Platform sample sketch // Platform : PIR\u0026amp;SP // Processor : ATmega328P (3.3V /8MHz) // Application : PIR with SP Beep // // Leaf configuration // (1) AI02 SP\u0026amp;PIR // (2) AP01 AVR MCU // (3) AZ01 USB // //\t(c) 2021 LEAFONY SYSTEMS Co., Ltd //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== //===================================================================== // difinition //===================================================================== #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;Arduino.h\u0026gt;#include \u0026lt;Wire.h\u0026gt;#include \u0026#34;pitches.h\u0026#34; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; #define I2C_RECEIVE_BUF_LENGTH 10 unsigned char i2c_receiveBuf[I2C_RECEIVE_BUF_LENGTH]; unsigned char i2c_receiveLenght; //------------------------------ // buzzer output = 5pin //------------------------------ #define BUZZER_OUT 5  byte readReg; double irData; double tempData; char buf[120]; volatile int state = 0; //===================================================================== // setup //===================================================================== void setup() { //pinMode(2, INPUT);  attachInterrupt(0,catchHuman , FALLING ); //人接近検知割り込み  Wire.begin(); Serial.begin( 115200 ); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); } //===================================================================== // Main loop //===================================================================== void loop() { clearI2CReadbuf(); i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_receiveBuf); sprintf(buf, \u0026#34;REG = %02X , %02X , %02X , %02X , %02X , %02X\u0026#34;, i2c_receiveBuf[0], i2c_receiveBuf[1], i2c_receiveBuf[2], i2c_receiveBuf[3], i2c_receiveBuf[4], i2c_receiveBuf[5]); Serial.println(buf); sprintf(buf, \u0026#34;Human detection = %d\u0026#34;, (i2c_receiveBuf[0] \u0026amp; 0x10) \u0026gt;\u0026gt; 4 ); Serial.println(buf); //IRセンサ測定データ  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); //センサ温度  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); if (state == 1){ //------------------------------  // notes in the melody:  //------------------------------  int melody[] = { NOTE_C5, NOTE_C5, NOTE_G5, NOTE_G5, NOTE_A5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_F5, NOTE_E5, NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5 }; //------------------------------  // note durations: 4 = quarter note, 8 = eighth note, etc.:  //------------------------------  int noteDurations[] = { 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 2 }; //----------------------------------------  // iterate over the notes of the melody:  //----------------------------------------  for (int thisNote = 0; thisNote \u0026lt; 14; thisNote++) { //----------------------------------------  // to calculate the note duration, take one second  // divided by the note type.  //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.  //----------------------------------------  int noteDuration = 1000 / noteDurations[thisNote]; tone(BUZZER_OUT, melody[thisNote], noteDuration); //----------------------------------------  // to distinguish the notes, set a minimum time between them.  // the note\u0026#39;s duration + 30% seems to work well:  //----------------------------------------  float pauseBetweenNotes = noteDuration * 1.30; delay(pauseBetweenNotes); //-----------------------  // stop the tone playing:  //-----------------------  noTone(BUZZER_OUT); } state = 0; } delay(1000); } //===================================================================== void catchHuman(){ state = 1; Serial.println(\u0026#34;!! Interrupt !!\u0026#34;); //人の接近を検知 } //===================================================================== double clacTemp(){ double ret; unsigned short val = (unsigned short)((i2c_receiveBuf[4] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } //===================================================================== double clacIR(){ double ret; unsigned short val = (unsigned short)((i2c_receiveBuf[2] \u0026lt;\u0026lt; 8) | i2c_receiveBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C スレーブデバイスに1バイト書き込む **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから1バイト読み込む **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C スレーブデバイスに複数バイト書き込む **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C スレーブデバイスから複数バイト読み込む **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C 受信バッファクリア **********************************************/ void clearI2CReadbuf(){ memcpy(i2c_receiveBuf, 0x00, I2C_RECEIVE_BUF_LENGTH); } PIR_Melody_test.ino\n実行結果 人が近づくとメロディが鳴ります。\n前のページに戻る\r","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたらメロディが鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使 …","ref":"/docs/examples/advanced/1_p/exten/pir_melody_test/","title":"人の接近を検知しメロディを鳴らす"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/1_p/exten/","title":"Basic Kit 2 + Extension Kit"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/3_p/exten/","title":"Basic Kit 2 + Extension Kit"},{"body":"IO Leaf List\nBack to previous page\r","excerpt":"IO Leaf List\nBack to previous page\r","ref":"/en/docs/leaf/io/","title":"IO"},{"body":"IOリーフ一覧\n前のページに戻る\r","excerpt":"IOリーフ一覧\n前のページに戻る\r","ref":"/docs/leaf/io/","title":"IO"},{"body":"Basic Kitは、販売終了となり、後継機としてBasic Kit 2が、製品化されています。\n  --\r概要 コイン電池でも駆動可能な超小型・低消費電力システム向きの開発キットです。AVRマイコン(Atmega328P)、Bluetooth LE、温湿度センサ、照度センサ、加速度センサを搭載したリーフとマグネット付きプラスチックケースが含まれており、簡単にIoTセンサデバイスを作ることが出来ます。\n内容物    Type Item Q’ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AX02 29pin 1   AZ01 USB 1   AZ62 Connector Cover 1   AZ66 Basic Kit Case 1    CR2032 coin cell battery 1    M2*18mm screw 2    Screw driver 1    リーフ一覧 \rAC02 BLE Sugar\r\rSilicon Labsの技的認証済みBluetooth LEモジュールBGM11S22F256GA-V2を搭載したリーフです。\n\r\r\rAI01 4-Sensors\r\r温湿度センサ、照度センサ、加速度センサを搭載したリーフです。省電力なセンサを搭載し長時間のセンシングに適しています。\n\r \rAP01 AVR MCU\r\rATmega328Pを使用したリーフです。14個のデジタル入出力ピン（6個はPWM出力として使用可能）、6個のアナログ入力ピン、8MHz振動子、およびリセットボタンを備えています。\n\r \rAV01 CR2032\r\rCR2032コイン電池ホルダと電源スイッチ、電圧モニタ用のADコンバータ、3V→3.3V昇圧回路を搭載した電源リーフです。2cm x 2cmのサイズで3.3Vの電源を供給可能です。\n\r \rAX02 29pin\r\rリーフI/Fの29ピン全てを2.54mmピッチのスルーホールに接続したリーフです。\n\r \rAZ01 USB\r\rAVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\n\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \rAZ66 Basic kit case\r\rBasic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\n\r \rサンプルアプリ・応用例 変更履歴  Rev A1.0: 2019年8月初版  前のページに戻る\r","excerpt":"Basic Kitは、販売終了となり、後継機としてBasic Kit 2が、製品化されています。\n  --\r概要 コイン電池でも駆動可能な超小型・低消費電力システム向きの開発キットです。AVRマイコ …","ref":"/docs/products/basic/","title":"Basic Kit"},{"body":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AI02 SP\u0026amp;PIR 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Open the Arduino, go to File → Sketch Examples → 02.Digital → toneMelody.\nIn this sample code, the speaker is supposed to be connected to pin number 8.\nBut as the loudspeaker is connected to pin 5 in Leafony, you should fix the following part to make it correct.\n Change the 8 to 5 in line 37.  tone(5, melody[thisNote], noteDuration);\r Change 8 to 5 in line 44.  noTone(5);\rExecution Results The melody sounds only once from the speakers.\nBack to previous page\r","excerpt":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to …","ref":"/en/docs/examples/beginner/1_p/exten/speaker/","title":"Speaker"},{"body":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AI02 SP\u0026amp;PIR 1   AP03 STM32 MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Open the Arduino, go to File → Sketch Examples → 02.Digital → toneMelody.\nIn this sample code, the speaker is supposed to be connected to pin number 8.\nBut as the loudspeaker is connected to pin 5 in Leafony, you should fix the following part to make it correct.1\n Change the 8 to PB4 in line 37.  tone(PB4, melody[thisNote], noteDuration);\r Change 8 to PB4 in line 44.  noTone(PB4);\rExecution Results The melody sounds only once from the speakers.\nBack to previous page\r  The program differs from the AVR MUC leaf only in the designation of the pins. For more information, here. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to …","ref":"/en/docs/examples/beginner/3_p/exten/speaker/","title":"Speaker"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AI02 SP\u0026amp;PIR 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduinoを開き、ファイル → スケッチ例 → 02.Digital → toneMelodyを開いてください。\nこのサンプルコードでは、スピーカが8番ピンに接続されている事になっています。\nしかし、Leafonyではスピーカが5番ピンに接続されているので、下記の部分を修正して正しいピン接続になるようにしましょう。\n 37行目の8を5に変更  tone(5, melody[thisNote], noteDuration);\r 44行目の8を5に変更  noTone(5);\r実行結果 スピーカーから一度だけメロディが鳴ります。\n前のページに戻る\r","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/1_p/exten/speaker/","title":"スピーカ"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AI02 SP\u0026amp;PIR 1   AP03 STM32 MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduinoを開き、ファイル → スケッチ例 → 02.Digital → toneMelodyを開いてください。\nこのサンプルコードでは、スピーカが8番ピンに接続されている事になっています。\nしかし、Leafonyではスピーカが5番ピンに接続されているので、下記の部分を修正して正しいピン接続になるようにしましょう。\n 37行目の8を5に変更  tone(5, melody[thisNote], noteDuration);\r 44行目の8を5に変更  noTone(5);\r実行結果 スピーカーから一度だけメロディが鳴ります。\n前のページに戻る\r","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/3_p/exten/speaker/","title":"スピーカ"},{"body":"用意するもの  STM32 MCUリーフ Basic Kit パソコン (Windows、macOS 、または Linux)  STM32CubeProg のインストール プログラムを書き込むには、STM32CubeProgのインストール1が必要です。下記より、インストールしてください。\nSTM32CubeProg\nArduino IDEのインストール 以下の手順で、Arduino IDEをインストールを行います。\n Arduinoのホームページ からSOFTWAREのページを開きます。 Downloadで、インストーラをダウンロードします。 画面の指示に従って、インストールします。  Previous IDE インストール 下記より、Previous IDEのインストールが出来ます。\nPrevious IDE Releases\nパソコンと接続 USBケーブルでパソコンと接続します。\nマイコンボードの設定   Leafony STM32のボードは、webサイトからインストールします。 ファイル → 環境設定を開き、追加のボードマネージャのURL:に、下記URLを入力してください。  https://github.com/Leafony/BoardManagerFiles/raw/master/Leafony_STM32/package_leafony_stm_index.json  \n  ツール→ボード→ボードマネージャを選択します。\n  ボードマネージャの検索ボックスにLeafonyを入力してインストールします。インストールに数分時間のかかる場 合があります。 \n  ツール → ボード→ Leafony STM32  をクリックします。 \n  ツール → Board part number→ Leafony STM32 MCU をクリックします。Arduino IDEのデフォルトは、80MHzですが、低消費電力でご使用頂くため、クロックを16MHzに落としたボードも用意しています。 \n  ツール → Upload method→ STM32CubeProgrammer(Serial) をクリックします。 \n  ツール → シリアルポートから、Leafonyが接続されているシリアルポートを選択します。シリアルポートが選択出来ない場合は、シリアルポートが見つからないを参照して下さい。 \n  マイコンボードの動作確認   STM32 MCUリーフのプログラムスイッチを、プログラム側にして、次にリセットスイッチを押します。 \n  温湿度センサ読み取りを参照し、プログラムを書き込みます。書き込みが完了するまで、時間のかかる場合があります。正常に書き込まれた場合は Start operation achieved successfullyと表示されます。表示されない場合は、プログラムが正常に動作しません。2 \n  書き込みが完了したら、STM32 MCUリーフのプログラムスイッチを実行（Run)側にするとLEDが消灯します。\n  STM32 MCUリーフのリセットスイッチを押してプログラムを動作させます。温度と湿度が表示されていれば完了です。\n  スケッチのピンの指定 ピンは、名前(Name)又はポート(Port)で指定して下さい。\n\nライブラリのインストール プログラムを書き込むには、ライブラリのインストールが必要なリーフがあります。下記より、インストールしてください。\nライブラリのインストール\nタイマ割り込みライブラリ(MsTimer2.h)は、AVR MCUのライブラリなので、STM32 MCUリーフには、使用出来ません。以下のHardwareTimerを参考にしてください。\nHardwareTimer 使用例を以下に、記載します。詳細はこちら 初期設定\nHardwareTimer *timer2 = new HardwareTimer (TIM2); timer2-\u0026gt;setOverflow(LOOP_INTERVAL, MICROSEC_FORMAT); // 125ms  timer2-\u0026gt;attachInterrupt(intTimer); timer2-\u0026gt;resume(); 割り込みルーチン\nvoid intTimer(void){ bInterval = true; ： ： } 困ったときには お問い合わせをする前に、困ったときにはを読んでみてください。\n前のページに戻る\r  Windows 64bitのV2.12.0、V2.6.0、V2.4.0は、動作確認済み。v2.5.0は動作しないので要注意。 \u0026#x21a9;\u0026#xfe0e;\n スイッチをプログラム側にしないで書き込んだ場合もボードへの書き込みが完了しましたとなりますが、画面の下部にTimeout error occured while waiting for acknowledgementと表示され、プログラムが正常に動作しません。  \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"用意するもの  STM32 MCUリーフ Basic Kit パソコン (Windows、macOS 、または Linux)  STM32CubeProg のインストール プログラムを書き込むに …","ref":"/docs/environment/stm32/arduino_ide/","title":"Arduino IDEの設定"},{"body":"ESP32 Wi-Fi Kitは、販売終了となり、後継機としてESP32 Wi-Fi Kit 2が、製品化されています。\n  --\r概要 人気のESP32マイコンをベースとしたWi-Fi無線通信、microSD、リアルタイムクロック機能が入ったキットです。Basic Kitより少しサイズが大きく、消費電力も大きくなっていますが、断然高性能です。コイン電池では動作しませんが、少し大きめの電池で動きます。そのままで、スマートフォンやパソコンにWi-Fiを使ってタッチセンサの値を送信し、簡単に表示できます。\n内容物    Type Item Q’ty     AP02 ESP32 MCU 1   AV04 2V～4.5V 1   AX07 Back to back 1   AX08 29 pin header 1   AZ02 RTC \u0026amp; microSD 1   AZ62 Connector Cover 2   AZ63 Nut Plate 2    AAA battery holder 1    Caution note 1    M2*12mm screw 2    φ10x2mm magnet 1    リーフ一覧 \rAP02 ESP32 MCU\r\rEspressif Systemsの、技的認証済みWi-FiとBluetooth LEを内蔵したモジュールESP32-WROOM-32を搭載した32bit MCUリーフです。\n\r \rAV04 2V～4.5V\r\rリチウムイオンバッテリや電池ボックス接続用のJST製SHコネクタと電源スイッチ、電圧モニタ用のADコンバータ、3.3V昇降圧回路を搭載した電源リーフです。2V～4.5Vの電池電圧入力に対応しています。\n\r \rAX07 Back to back\r\rリーフを背中合わせに接続可能なコネクタリーフです。\n\r \rAX08 29pin header\r\rリーフI/Fの29ピン全てを2.54mmピッチのピンヘッダに接続したリーフです。\n\r \rAZ02 RTC\u0026amp;microSD\r\rNXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。microSDカードはSPIでアクセスします。\n\r \rAZ62 Connector Cover\r\rConnector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n\r \rAZ63 Nut Plate\r\rNut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n\r \rサンプルアプリ・応用例 変更履歴  Rev A1.0: 2020年1月初版  前のページに戻る\r","excerpt":"ESP32 Wi-Fi Kitは、販売終了となり、後継機としてESP32 Wi-Fi Kit 2が、製品化されています。\n  --\r概要 人気のESP32マイコンをベースとしたWi-Fi無線通 …","ref":"/docs/products/esp32/","title":"ESP32 Wi-Fi Kit"},{"body":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR Leaf, let\u0026rsquo;s create a system that makes a sound when a person approaches.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n//===================================================================== // Human Sensing // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/16 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; // Function to be called when a person is detected void onHumanDetected() { Serial.println(\u0026#34;Detect!\u0026#34;); tone(5, 262, 300); // Make a beep sound } void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with AK9754AE:  Wire.begin(); delay(100); // Human sensor setting  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 Human detection algorithm enabled / Interrupt output enabled  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 Sensor gain 205% (maximum)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(Continuous measurement mode)  delay(1000); // Human proximity detection interrupt  attachInterrupt(0, onHumanDetected, FALLING ); } void loop() { // Clear buffer  clearI2CReadbuf(); // Register read  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); // IR Sensor  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); // Sensor temperature  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); delay(1000); } double clacTemp() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } double clacIR() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C Write 1 byte to the slave device **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C Read 1 byte from the slave device **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C Write multiple bytes to the slave device **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C Read multiple bytes from the slave device **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C Receive buffer clear **********************************************/ void clearI2CReadbuf(){ memset(\u0026amp;i2c_recvBuf[0], 0x00, sizeof(i2c_recvBuf)); } Human_Sensing.ino\nExecution Results Sounds as the person approaches.\nBack to previous page\r","excerpt":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR …","ref":"/en/docs/examples/beginner/1_p/exten/ir_sensor/","title":"IR sensor"},{"body":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR Leaf, let\u0026rsquo;s create a system that makes a sound when a person approaches.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program1 in the Arduino IDE.\n//===================================================================== // STM32 Human Sensing // // (c) 2021 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/01/26 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; // Function to be called when a person is detected void onHumanDetected() { Serial.println(\u0026#34;Detect!\u0026#34;); tone(PB4, 262, 300); // Make a beep sound } void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with AK9754AE:  Wire.begin(); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 Human detection algorithm enabled / Interrupt output enabled  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 Sensor gain 205% (maximum)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(Continuous measurement mode)  delay(1000); // Human proximity detection interrupt  attachInterrupt(PC7, onHumanDetected, FALLING ); } void loop() { // Clear buffer  clearI2CReadbuf(); // Register read  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); // IR Sensor  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); // Sensor temperature  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); delay(1000); } double clacTemp() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } double clacIR() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C Write 1 byte to the slave device **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C Read 1 byte from the slave device **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C Write multiple bytes to the slave device **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C Read multiple bytes from the slave device **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C Receive buffer clear **********************************************/ void clearI2CReadbuf(){ memset(\u0026amp;i2c_recvBuf[0], 0x00, sizeof(i2c_recvBuf)); } STM32_Human_Sensing.ino\nExecution Results Sounds as the person approaches.\nBack to previous page\r  The program differs from the AVR MUC leaf only in the designation of the pins. For more information, here. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR …","ref":"/en/docs/examples/beginner/3_p/exten/ir_sensor/","title":"IR sensor"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP01 AVR MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // Human Sensing // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; // Function to be called when a person is detected void onHumanDetected() { Serial.println(\u0026#34;Detect!\u0026#34;); tone(5, 262, 300); // Make a beep sound } void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with AK9754AE:  Wire.begin(); delay(100); // Human sensor setting  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 Human detection algorithm enabled / Interrupt output enabled  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 Sensor gain 205% (maximum)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(Continuous measurement mode)  delay(1000); // Human proximity detection interrupt  attachInterrupt(0, onHumanDetected, FALLING ); } void loop() { // Clear buffer  clearI2CReadbuf(); // Register read  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); // IR Sensor  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); // Sensor temperature  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); delay(1000); } double clacTemp() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } double clacIR() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C Write 1 byte to the slave device **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C Read 1 byte from the slave device **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C Write multiple bytes to the slave device **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C Read multiple bytes from the slave device **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C Receive buffer clear **********************************************/ void clearI2CReadbuf(){ memset(\u0026amp;i2c_recvBuf[0], 0x00, sizeof(i2c_recvBuf)); } Human_Sensing.ino\n実行結果 人が近づくと音が鳴ります。\n前のページに戻る\r","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用しま …","ref":"/docs/examples/beginner/1_p/exten/ir_sensor/","title":"人感センサ"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI02 SP\u0026amp;PIR 1   AZ01 USB 1   AP03 STM32 MCU 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // Human Sensing // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt; #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; // Function to be called when a person is detected void onHumanDetected() { Serial.println(\u0026#34;Detect!\u0026#34;); tone(5, 262, 300); // Make a beep sound } void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with AK9754AE:  Wire.begin(); delay(100); // Human sensor setting  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 Human detection algorithm enabled / Interrupt output enabled  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 Sensor gain 205% (maximum)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(Continuous measurement mode)  delay(1000); // Human proximity detection interrupt  attachInterrupt(0, onHumanDetected, FALLING ); } void loop() { // Clear buffer  clearI2CReadbuf(); // Register read  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); // IR Sensor  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); // Sensor temperature  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); delay(1000); } double clacTemp() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else { ret = (double)val * 0.0019837; } return ret + 25; } double clacIR() { double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ( (val \u0026amp; 0x8000) == 0x8000) { val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else { ret = (double)(val * 0.4578 ); } return ret; } /********************************************** * I2C Write 1 byte to the slave device **********************************************/ void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } /********************************************** * I2C Read 1 byte from the slave device **********************************************/ unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } /********************************************** * I2C Write multiple bytes to the slave device **********************************************/ void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } /********************************************** * I2C Read multiple bytes from the slave device **********************************************/ void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } /********************************************** * I2C Receive buffer clear **********************************************/ void clearI2CReadbuf(){ memset(\u0026amp;i2c_recvBuf[0], 0x00, sizeof(i2c_recvBuf)); } Human_Sensing.ino\n実行結果 人が近づくと音が鳴ります。\n前のページに戻る\r","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用しま …","ref":"/docs/examples/beginner/3_p/exten/ir_sensor/","title":"人感センサ"},{"body":"  \nFeatures The MEMS microphone and volume are connected to the MCU leaf via analog input pins and the LED is connected to the digital output pins. To achieve low power consumption, the power can be turned off using a load switch controlled by the I2C Expander.\nSpecification Dimension    Item Description     Dimension  W23×D20.5×H4.7mm    Microphone    Item Description     Part number SPW2430HR5H-B   Type MEMS   Direction Omnidirectional   Frequency range 100Hz ～ 10kHz   Gain 0dB   Interfaces Analog    Volume    Item Description     Part number ST-4ETA10kΩ   Nominal resistance 10kΩ   Resistance law Linear law (B)   Effective electrical angle 210° (1 turn)    LED    Item Description     Part number SML-A12Y8TT86   Package type Side-view   Emitting color Yellow    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1B)    Block diagram \nPinassign \nTips About Microphone, Volume and LED \n   Item     Microphone MK500   Volume VR500   LED    Sample App AVR MCU Examples  Sound Level Meter  ESP32 MCU Examples  Sound Level Meter  Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features The MEMS microphone and volume are connected to the MCU leaf via analog input pins and the …","ref":"/en/docs/leaf/io/ai03/","title":"AI03 MIC\u0026VR\u0026LED"},{"body":"  \n特徴 MEMSマイク、ボリューム、LEDを搭載したリーフです。MEMSマイクとボリュームはアナログ入力ピン、LEDはデジタル出力ピンでMCUリーフと接続されます。低消費電力を実現するのためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n性能 外形サイズ    Item Description     Dimension  W23×D20.5×H4.7mm    マイク    Item Description     Part number SPW2430HR5H-B   Type MEMS   Direction Omnidirectional   Frequency range 100Hz ～ 10kHz   Gain 0dB   Interfaces Analog    ボリューム    Item Description     Part number ST-4ETA10kΩ   Nominal resistance 10kΩ   Resistance law Linear law (B)   Effective electrical angle 210° (1 turn)    LED    Item Description     Part number SML-A12Y8TT86   Package type Side-view   Emitting color Yellow    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1B)    ブロック図 \nピン配置 \nTips マイクロフォン、ボリューム、LEDについて \n   Item     Microphone MK500   Volume VR500   LED    サンプルアプリ AVR MCU Examples  サウンドレベルメータ  ESP32 MCU Examples  サウンドレベルメータ  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"特徴 MEMSマイク、ボリューム、LEDを搭載したリーフです。MEMSマイクとボリュームはアナログ入力ピン、LEDはデジタル出力ピンでMCUリーフと接続されます。低消費電力を実現するのためI2C …","ref":"/docs/leaf/io/ai03/","title":"AI03 MIC\u0026VR\u0026LED"},{"body":"はじめに Visual Studio Code (VSCode)は、Microsoft社が提供する軽量ながら強力なソース コード エディターで、デスクトップ上で実行され、Windows、macOS、および Linux で使用できます。PlatformIO IDEは、VSCodeの拡張機能で、ビルドが早く、ライブラリやボードのバージョンがプロジェクト毎に管理されているのが特長です。 \n用意するもの  Basic Kit 2 パソコン (Windows、macOS、または Linux)  事前準備 Pythonのインストール PlatformIO IDEを動かすには、Pythonが必要です。こちらを参照して、Pythonインストールして下さい。\nPlatformIO IDEのインストール  PlatformIO IDEは、VSCodeの拡張機能なので、まず、VSCodeをインストールして下さい。 拡張機能(画面左のバー)をクリックし、検索窓に以下を入力して、拡張機能をインストールします。  Japanese Language Pack for Visual Studio Code platformio ide Serial Monitor teleplot    STM32CubeProg とArduino IDEのインストール STM32MCUにプログラムを書き込むために、以下のインストールが必要になります。\n STM32CubeProg1 Arduino IDE  STM32MCUのBoardファイルの準備 STM32MCUは、NUCLEO-L452REとピンアサインが異なるため、STM32MCUのBoardファイル(③、④）が必要になります。PlatformIOで NUCLEO-L452REのプロジェクトを立ち上げると①と②がPCにダウンロードされます。次に③と④をGitHubからダウンロードしてpcの保存すれば完了です。 Nucleo L452REのプロジェクトの立ち上げ   VSCodeを立ち上げ、ファイル→ 新しいウィンドウを開きます。\n  PlatformIO(画面左のバー)をクリックし、PLATFORMIO QUICK ACCESS（画面左）を表示させます。\n  PIO Home/Openをクリックします。\n  New Projectをクリックすると、Project Wizardが表示されます。Name、Boad、Frameworkを以下の通り入力して、Finishをクリックします。新しいBoardを選択した時、プログラミングに必要なファイルのダウンロードするために数分かかります。\n Name:Testと記入  Board:ST Nucleo L452REを選択  Framework:Arduino を選択     C:\\Users\\ユーザ名\\ .platformio の下に、①と②のふたつのフォルダが出来ていることを確認して下さい。\n  ③Leafony_AP03と④Leafony_AP03.jsonのダウンロードと保存   以下からダウンロードし、所定の場所に保存して下さい。\n https://github.com/Leafony/platformio-LEAFONY_AP03    Project WizardのBoardの検索窓にLeafony_AP03が表示されることを確認して下さい。\n  クイックスタート 「Hello Wold」の事例で、platformIO IDEの使い方を紹介します。\n  VSCodeを立ち上げ、ファイル→ 新しいウィンドウを開きます。\n  PlatformIO(画面左のバー)をクリックし、PLATFORMIO QUICK ACCESS（画面左）を表示させます。\n  PIO Home/Openをクリックします。\n  New Projectをクリックすると、Project Wizardが表示されます。Name、Boad、Frameworkを以下の通り入力して、Finishをクリックします。新しいBoardを選択した時、プログラミングに必要なファイルのダウンロードするために数分かかります。\n Name:STM32_Hello_World_Pjtと記入  Board:LEAFONY_AP03を選択  Framework:Arduino を選択      platformio.ini (画面左）を開き、 Projectで定義したBoardとFrameworkが、正しく定義されていることを確認します。\n  [env:LEAFONY_AP03] platform = ststm32 board = LEAFONY_AP03 framework = arduino STM32 MCUは、COMポートの番号とプログラムファイルの実行場所をplatformio.iniに記載して下さい。COMポートの番号は、シリアルモニターから確認出来ます。   Windowsの場合\n;upload_protocol for Windows upload_port = COM\u0026lt;番号\u0026gt; upload_command = %%userprofile%%\\AppData\\Local\\Arduino15\\packages\\STM32\\tools\\STM32Tools\\1.4.0\\tools\\win\\stm32CubeProg.bat 1 $SOURCE $UPLOAD_PORT -s macOSの場合\n;upload_protocol for macOS upload_port = cu.usbserial-\u0026lt;シリアル番号\u0026gt; upload_command = /Users/\u0026lt;ユーザ名\u0026gt;/Library/Arduino15/packages/STM32/tools/STM32Tools/1.4.0/tools/macosx/stm32CubeProg.sh 1 $SOURCE $UPLOAD_PORT -s また、 シリアル通信のボーレートをmonitor_speed =で定義し、platformio.iniに記載して下さい。  monitor_speed = 115200 src/main.cpp(画面左）を開き、以下のコードを貼り付けて下さい。 PlatformIO IDEのコードは、Arduino IDEのスケッチの先頭に#include \u0026lt;Arduino.h\u0026gt;を加えます。  #include \u0026lt;Arduino.h\u0026gt; void setup() { Serial.begin(115200); delay(10); } void loop(){ Serial.println(\u0026#34;Hello World\u0026#34;); delay(1000); }  ソースコード:STM32_Hello_Wold_Pjt   PlatformIO ツールバー(画面下のバー)のProject Environment Switcherボタンを押すと、アクティブなプロジェクが画面上側に全て表示されます。実行するプロジェクトを正しく選択して、Buildボタンを押して下さい。 \n  こちら を参考に、LeafonyをPCに接続し、STM32 MCUリーフのプログラムスイッチをプログラム側(LED点灯)にし下さい。\n  Uploadボタンを押すと、プログラムがMCUに書き込まれます。SUCCESS　TooK XX.XX secondsと表示が出ても、以下の表示が出ていない時は、正しく書き込まれていないので、注意をして下さい。 \n  正しく書き込まれたら、プログラムスイッチを実行側(LED消灯)にして下さい。\n  MCUのリセットボタンを押して、プログラムを実行させます。\n  シリアルモニターボタンを押して起動させ、Hello Wolrdを表示が出来れば完成です。\n  CPUの周波数を80MHz(デフォルト）から16MHzに設定変更 CPUの周波数は、80MHz（デフォルト）に設定されています。省電力を実現するためにCPUの周波数を下げることは有効な手段なので、CPUの周波数を16MHzに設定出来るようにしました。設定方法を以下に記します。\n platformio.iniに以下を追記して下さい。  ; Enable function to set CPU frequency to 16 MHz in Leafony_tools.cpp build_flags = -D CPUCLOCK_LOW  leafony_tools.cppのファイルを以下からダウンロードし、srcに保存して下さい。\n https://github.com/Leafony/platformio-LEAFONY_AP03    以下のソースコードを実行して、CPUの周波数が16MHzに設定されていることをシリアルモニターで確認して下さい。\n  \r ソースコード：STM32_CPU_Frequency_Pjt  ライブラリ   インストールの仕方 ライブラリは、platformio.ini の最後の行に、lib_deps =で定義すれば、PCにインストールされます。定義の仕方は、GitHubのURLを直接指定する方法とLibrariesで指定する方法の二通りがあります。 \n  各リーフのライブラリ一覧は、以下の通りです。\n  \r\rItem\rlib_deps\rTags\rDescription\r\r\r\r\rBLE\rhttps://github.com/Leafony/TBGLib\r\rBluetoothライブラリ\r\r\r4-Sensors\radafruit/Adafruit Unified Sensor@^1.1.6\r\rユニファイドセンサドライバ\r\r\radafruit/Adafruit BusIO@^1.14.1\r\rBus IOライブラリ\r\r\rhttps://github.com/ameltech/sme-hts221-library\r\r温湿度センサライブラリ\r\r\rclosedcube/ClosedCube OPT3001@^1.1.2\r\r照度センサライブラリ\r\r\radafruit/Adafruit LIS3DH@1.1.2\r1.1.2\r加速度センサライブラリ\r\r\rLCD\rtomozh/ST7032@0.0.0-alpha+sha.501bf64fe6\r\rLCDライブラリ\r\r\rAVR MCU\rpaulstoffregen/MsTimer2@^1.1\r\rタイマ割り込みライブラリ\r\r\rRTC\u0026MicroSD\radafruit/RTClib@^2.1.1\r\rRTCライブラリ\r\r\rSTM32 MCU\rstm32duino/STM32duino RTC @1.2.0\r1.2.0\rSTM32RTCライブラリ\r\r\rstm32duino/STM32duino Low Power@^1.2.2\r\rSTM32LowPowerライブラリ\r\r\rLTE-M\rhttps://github.com/Leafony/LteLeafV4\r\rLTE-Mライブラリ\r\r\r\rシリアルプロッター　 PlatformIOには、Arduino IDEにあるシリアルプロッターがないため、VSCodeの拡張機能であるTeleplot for VSCodeを導入します。サンプルのソースコードをダウンロードして、試して下さい。\n  GitHubからソースコードをダウンロードし、パソコンの所定の場所に保存1 します。\n ソースコード:STM32_Teleplot_Example_1    プログラムを実行して下さい。\n  画面下のteleplotの表示をクリックして、COMポートを指定して、Open を押すとグラフが表示されます   \u0026gt;varName:1234\\nという形式のシリアルメッセージは、すべてteleplotに表示されます。詳しくは、こちらを参照して下さい。\n  // Plot a sinus  Serial.print(\u0026#34;\u0026gt;sin:\u0026#34;); Serial.println(sin(i)); // Plot a cosinus  Serial.print(\u0026#34;\u0026gt;cos:\u0026#34;); Serial.println(cos(i)); STM32 Beginner Examples PlatformIO IDEを使った簡単なソースコードを準備しました。GitHubからダウンロードし、パソコンの所定の場所に保存1 してプログラムを実行して下さい。\n   Item Source code     バッテリ電圧読み取り    温湿度センサ読み取り    照度センサ読み取り    スピーカ    人感センサ    サウンドレベルメータ    LCD     Tips MCUとBoardとの関係 LeafonyのMCUとPlatformIO IDEのBoardとの関係は、以下の様になります。\n   Type Item Platform Board Upload      AP01 AVR MCU atmelavr Arduino Pro or Pro Mini ATmega328(3.3v,8Mhz) COMポートの自動検出    AP02 ESP32 MCU Espressif 32 Espressif ESP32 Dev Module COMポートの自動検出    AP03 STM32 MCU ststm32 LEAFONY_AP03 COMポートの自動検出が出来ない。     main.cppの注意点   \u0026lt;Arduino.h\u0026gt; が必要 Arduino用のスケッチをmain.cppに貼り付けるだけでは、ビルド出来ません。先頭に、\u0026lt;Arduino.h\u0026gt; を入れる必要があります。\n  変数・関数の出現順が厳密 Arduino IDEは、関数の設定などを最後に書いてもビルドが通りますが、PlatformIOは、関数や変数は、使用する前に宣言される必要があります。\n  プロジェクトフォルダの名前変更や削除 Project Wizarで、New Projectを立ち上げると、フォルダが作成され、デフォルトでは、~/Documents/PlatformIO/Projects に保存されます。 Projectの名前変更やフォルダの削除は、Project Wizarではなく、エクスプローラから直接出来ます。\nプロジェクトフォルダの保存場所の設定 プロジェクトフォルダの保存場所の設定は、Project Wizarではなく、ターミナルから行います。\n  VSCodeを立ち上げ、ファイル→ 新しいウィンドウを開きます。\n  PlatformIO(画面左のバー)をクリックし、PLATFORMIO QUICK ACCESS（画面左）を表示させます。\n  PIO Home/Openをクリックします。\n  以下のコードを実行します。 pio settings set projects_dir ＜設定したい(絶対)パス＞\n  VSCodeを再起動します。\n  参考  PlatformIO ドキュメント  前のページに戻る\r  Windows 64bitのV2.12.0、V2.6.0、V2.4.0は、動作確認済み。v2.5.0は動作しないので要注意。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"はじめに Visual Studio Code (VSCode)は、Microsoft社が提供する軽量ながら強力なソース コード エディターで、デスクトップ上で実行され、Windows、macOS、お …","ref":"/docs/environment/stm32/platformio/","title":"PlatformIO IDE for VSCodeの設定"},{"body":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of rotation. You can also turn on the number of LEDs according to the ambient volume with the microphone.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AI03 MIC\u0026amp;VR\u0026amp;LED 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n//===================================================================== // Sound level meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/17 First release //===================================================================== #define LED1 6 #define LED2 7 #define LED3 8 #define LED4 9 #define LED5 10 #define LED6 11  #define MIC 16 // A2 #define VR 17 // A3  unsigned int dataVR; unsigned int dataMic; //----------------------------------------------- // Get VR and MIC data //----------------------------------------------- void getSensorData() { dataVR = analogRead(VR); dataMic = analogRead(MIC); Serial.println(\u0026#34;---------------------\u0026#34;); Serial.print(\u0026#34;MIC = \u0026#34;); Serial.println(dataMic,DEC); Serial.print(\u0026#34;VR = \u0026#34;); Serial.println(dataVR,DEC); } //----------------------------------------------- // Turn the LEDs on and off according to the VR and MIC values. //----------------------------------------------- void dispSensorData() { if (dataVR \u0026lt; 400) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 400 \u0026amp;\u0026amp; dataVR \u0026lt; 800) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 800 \u0026amp;\u0026amp; dataVR \u0026lt; 900) { digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else { digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; 700) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= 700 \u0026amp;\u0026amp; dataMic \u0026lt; 800) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= 800 \u0026amp;\u0026amp; dataMic \u0026lt; 850) { digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else { digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup() { Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); //起動テスト(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); } void loop() { getSensorData(); dispSensorData(); delay(100); } Sound_Level_Meter.ino\nExecution Results As you rotate the volume, the number of LEDs will light up according to the amount of rotation. The number of LEDs will light up according to the ambient volume, depending on the microphone.\nBack to previous page\r","excerpt":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of …","ref":"/en/docs/examples/beginner/1_p/exten/sound_level/","title":"Sound level meter"},{"body":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of rotation. You can also turn on the number of LEDs according to the ambient volume with the microphone.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AI03 MIC\u0026amp;VR\u0026amp;LED 1   AP03 STM32 MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program1 in the Arduino IDE.\n//===================================================================== // STM32 Sound level meter // // (c) 2021 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/01/26 First release //===================================================================== #define LED1 PA8 // D6 #define LED2 PB12 // D7 #define LED3 PA9 // D8 #define LED4 PA10 // D9 #define LED5 PB6 // D10 #define LED6 PA7 // D11  #define MIC PA1 // A2 #define VR PB0 // A3  unsigned int dataVR; unsigned int dataMic; //----------------------------------------------- // Get VR and MIC data //----------------------------------------------- void getSensorData() { dataVR = analogRead(VR); dataMic = analogRead(MIC); Serial.println(\u0026#34;---------------------\u0026#34;); Serial.print(\u0026#34;MIC = \u0026#34;); Serial.println(dataMic,DEC); Serial.print(\u0026#34;VR = \u0026#34;); Serial.println(dataVR,DEC); } //----------------------------------------------- // Turn the LEDs on and off according to the VR and MIC values. //----------------------------------------------- void dispSensorData() { if (dataVR \u0026lt; 400) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 400 \u0026amp;\u0026amp; dataVR \u0026lt; 800) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 800 \u0026amp;\u0026amp; dataVR \u0026lt; 900) { digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else { digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; 300) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= 300 \u0026amp;\u0026amp; dataMic \u0026lt; 350) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= 350 \u0026amp;\u0026amp; dataMic \u0026lt; 450) { digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else { digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup() { Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); // Startup test(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); } void loop() { getSensorData(); dispSensorData(); delay(100); } STM32_Sound_Level_Meter.ino\nExecution Results As you rotate the volume, the number of LEDs will light up according to the amount of rotation. The number of LEDs will light up according to the ambient volume, depending on the microphone.\nBack to previous page\r  The program differs from the AVR MUC leaf only in the designation of the pins. For more information, here. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of …","ref":"/en/docs/examples/beginner/3_p/exten/sound_level/","title":"Sound level meter"},{"body":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI03 MIC\u0026amp;VR\u0026amp;LED 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // STM32 Sound level meter // // (c) 2022 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/04/01 First release //===================================================================== #define LED1 PA8 // D6 #define LED2 PB12 // D7 #define LED3 PA9 // D8 #define LED4 PA10 // D9 #define LED5 PB6 // D10 #define LED6 PA7 // D11  #define MIC PA1 // A2 #define VR PB0 // A3  unsigned int dataVR; unsigned int dataMic; unsigned int MicLevelNom = 450; //----------------------------------------------- // Get VR and MIC data //----------------------------------------------- void getSensorData() { dataVR = analogRead(VR); dataMic = analogRead(MIC); Serial.print(dataVR,DEC); Serial.print(\u0026#34;,\u0026#34;); Serial.println(dataMic,DEC); } //----------------------------------------------- // Turn the LEDs on and off according to the VR and MIC values. //----------------------------------------------- void dispSensorData() { if (dataVR \u0026lt; 400) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 400 \u0026amp;\u0026amp; dataVR \u0026lt; 800) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 800 \u0026amp;\u0026amp; dataVR \u0026lt; 900) { digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else { digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; MicLevelNom) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= MicLevelNom \u0026amp;\u0026amp; dataMic \u0026lt; MicLevelNom+50) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= MicLevelNom+50 \u0026amp;\u0026amp; dataMic \u0026lt; MicLevelNom+150) { digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else { digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup() { Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); // Startup test(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); Serial.print(\u0026#34;VR\u0026#34;); Serial.print(\u0026#34;,\u0026#34;); Serial.println(\u0026#34;MIC\u0026#34;); } void loop() { getSensorData(); dispSensorData(); delay(100); } Sound_Level_Meter.ino\n実行結果 ボリュームを回転させると回転量に応じた数のLEDが点灯します。マイクにより周囲の音量に応じた数のLEDが点灯します。\n前のページに戻る\r","excerpt":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type …","ref":"/docs/examples/beginner/1_p/exten/sound_level/","title":"サウンドレベルメータ"},{"body":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AI03 MIC\u0026amp;VR\u0026amp;LED 1   AP03 STM32 MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // STM32 Sound level meter // // (c) 2022 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/04/01 First release //===================================================================== #define LED1 PA8 // D6 #define LED2 PB12 // D7 #define LED3 PA9 // D8 #define LED4 PA10 // D9 #define LED5 PB6 // D10 #define LED6 PA7 // D11  #define MIC PA1 // A2 #define VR PB0 // A3  unsigned int dataVR; unsigned int dataMic; unsigned int MicLevelNom = 450; //----------------------------------------------- // Get VR and MIC data //----------------------------------------------- void getSensorData() { dataVR = analogRead(VR); dataMic = analogRead(MIC); Serial.print(dataVR,DEC); Serial.print(\u0026#34;,\u0026#34;); Serial.println(dataMic,DEC); } //----------------------------------------------- // Turn the LEDs on and off according to the VR and MIC values. //----------------------------------------------- void dispSensorData() { if (dataVR \u0026lt; 400) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 400 \u0026amp;\u0026amp; dataVR \u0026lt; 800) { digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 800 \u0026amp;\u0026amp; dataVR \u0026lt; 900) { digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else { digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; MicLevelNom) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= MicLevelNom \u0026amp;\u0026amp; dataMic \u0026lt; MicLevelNom+50) { digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= MicLevelNom+50 \u0026amp;\u0026amp; dataMic \u0026lt; MicLevelNom+150) { digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else { digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup() { Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); // Startup test(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); Serial.print(\u0026#34;VR\u0026#34;); Serial.print(\u0026#34;,\u0026#34;); Serial.println(\u0026#34;MIC\u0026#34;); } void loop() { getSensorData(); dispSensorData(); delay(100); } Sound_Level_Meter.ino\n実行結果 ボリュームを回転させると回転量に応じた数のLEDが点灯します。マイクにより周囲の音量に応じた数のLEDが点灯します。\n前のページに戻る\r","excerpt":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type …","ref":"/docs/examples/beginner/3_p/exten/sound_level/","title":"サウンドレベルメータ"},{"body":"  \nFeatures This leaf is equipped with a character LCD unit and two switches. The LCD unit is connected to the MCU leaf via I2C. The switch is connected to the digital input pin of the MCU and the P1 pin of the I2C Expander. To achieve low power consumption, the I2C Expander can be controlled to turn off the power supply with a load switch.\nSpecification Dimension    Item Description     Dimension  W30.8×D30.5×H5.3mm    LCD    Item Description     Part number AQM0802A-RN-GBW   Display format 8x2 Character   Viewing area (WxH) 27x10.5mm   Dot size (WxH) 0.45x0.5mm   Dot pitch (WxH) 0.5x0.55mm   Character size (WxH) 2.45x4.35mm   Character pitch (WxH) 2.95x4.9mm   Viewing direction 6:00 O\u0026rsquo;Clock   Driving method 1/16Duty,1/5Bias   Controller IC ST7032I-0D(Sitronix) or compatible   Display mode STN (Gray)/Positive/Reflective   Interfaces I2C (Address: 0x3E)    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1A or 0x1E)    Block diagram \nPinassign \nTips About the switch \n   Item Description     Switch1 Connected to pin 2   Switch2 Connected to I2C Expander P1 pin    Sample App AVR MCU Examples  LCD 4-Sensors Lcd Distance sensor  ESP32 MCU Examples  LCD  Library Libraries are available for this leaf. Please install the necessary libraries from Environment to use them.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features This leaf is equipped with a character LCD unit and two switches. The LCD unit is connected …","ref":"/en/docs/leaf/io/ai04/","title":"AI04 LCD"},{"body":"  \n特徴 キャラクタLCDユニットとスイッチ2個を搭載したリーフです。LCDユニットはI2CでMCUリーフと接続されます。スイッチはMCUのデジタル入力ピンとI2C ExpanderのP1ピンに接続されています。 低消費電力化を実現するためI2C Expander を制御することにより電源をロードスイッチによりオフすることが可能です。\n性能 外形サイズ    Item Description     Dimension  W30.8×D30.5×H5.3mm    LCD    Item Description     Part number AQM0802A-RN-GBW   Display format 8x2 Character   Viewing area (WxH) 27x10.5mm   Dot size (WxH) 0.45x0.5mm   Dot pitch (WxH) 0.5x0.55mm   Character size (WxH) 2.45x4.35mm   Character pitch (WxH) 2.95x4.9mm   Viewing direction 6:00 O\u0026rsquo;Clock   Driving method 1/16Duty,1/5Bias   Controller IC ST7032I-0D(Sitronix) or compatible   Display mode STN (Gray)/Positive/Reflective   Interfaces I2C (Address: 0x3E)    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1A or 0x1E)    ブロック図 \nピン配置 \nTips スイッチについて \n   Item Description     Switch1 Connected to pin 2   Switch2 Connected to I2C Expander P1 pin    サンプルアプリ AVR MCU Examples  LCD センサの値をLCDに表示 超音波センサで距離測定  ESP32 MCU Examples  LCD  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールしてご利用下さい。\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"特徴 キャラクタLCDユニットとスイッチ2個を搭載したリーフです。LCDユニットはI2CでMCUリーフと接続されます。スイッチはMCUのデジタル入力ピンとI2C ExpanderのP1ピンに接続されて …","ref":"/docs/leaf/io/ai04/","title":"AI04 LCD"},{"body":"64bit版JAVAをインストール STM32CubeIDEインストール前に64bit版JAVAをインストールすることが必要となります。 Java ホームページからダウンロードしましょう。\nダウンロード 同意して無料ダウンロードを開始をクリックしましょう。 インストール ダウンロードしたjxpiinstall.exeをダブルクリックして開き、インストールをクリックして下さい。\n閉じるをクリックしてください。 STM32CubeIDEをインストール STM32CubeIDEをダウンロードしましょう。\nダウンロード ソフトウェア入手をクリックして下さい。 製品型番STM32CubeIDE-Win行のソフトウエア入手をクリックして下さい。 同意をクリックして下さい。 名、姓、E-mail addressを入力し、\n□I have read and understood the Sales Terms \u0026amp; Conditions, Terms of Use and Privacy Policy\rをチェックして、ダウンロードをクリックしてください。 下記ページが表示されます。 登録したアドレスにメールが届くので、ダウンロードをクリックしてダウンロードを開始します。\nインストール ダウンロードしたZIPファイルを解凍します。\n解凍してできたst-stm32cubeide_1.4.0_7511_20200720_0928_x86_64.exeをダブルクリックします。 (ダウンロードした時期によりバージョンが変わる可能性があり数字が異なる場合があります)\nNextをクリックしてください。 I Agreeをクリックしてください。 Installをクリックしてください。 Nextをクリックしてください。 Finishをクリックしてください。 これでインストール完了です。\nSTM32CubeIDEの日本語化 MargeDoc Projectホームページからダウンロードしましょう。\nダウンロード Windowsをクリックしてください。 インストール ダウンロードしたZIPファイルを解凍します。 解凍してできたsetup.exeをダブルクリックして下さい。 選択をクリックしてください。 C:\\ST\\STM32CubeIDE_1.4.0\\STM32CubeIDE\\stm32cubeide.exeを選択し、開くをクリック 日本語化するをクリックしてください。 OKをクリックしてください。 終了をクリックしてください。 これでインストール完了です。\n文字化け対策 STM32CubeMXのコード生成時にUTF-8が文字化けしないようにするには(本当に必要かは不明) 環境変数に以下を追加します。\n変数名：JAVA_TOOL_OPTIONS 変数値：-Dfile.encoding=UTF-8\nコントロールパネル→システム→システムの詳細設定→環境変数を選択します。 新規をクリックします。 変数名にJAVA_TOOL_OPTIONS、変数値に-Dfile.encoding=UTF-8を入力します。 OKをクリックします。 前のページに戻る\r","excerpt":"64bit版JAVAをインストール STM32CubeIDEインストール前に64bit版JAVAをインストールすることが必要となります。 Java ホームページからダウンロードしましょう。\nダウンロー …","ref":"/docs/environment/stm32/stm32cube_ide/","title":"STM32CubeIDEの設定"},{"body":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt also comes with two button switches and can be used as a controller.\nLeaf to use Let\u0026rsquo;s assemble leaves as shown in the figure below.\n   Name Q\u0026rsquo;ty      AZ62 Connector Cover 1   AI04 LCD 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to use MIC\u0026amp;VR\u0026amp;LED Leaf, you need to install the library. If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : ATmega328P (3.3V /8MHz) // // Leaf configuration // (1) AI04 LCD // (2) AP01 AVR MCU // (3) AZ01 USB // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== // use libraries // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IO pin name definition // Define it according to the leaf to be connected. //----------------------------------------------- #define SW1 2 // PD2 (INT0)  //----------------------------------------------- // Define constants to be used in the program //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop(){ char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C control function //===================================================================== //----------------------------------------------- //I2C Write 1 byte to the slave device //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C Read 1 byte from the slave device //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } LCD-SW_test.ino\nExecution Results On the LCD the screens are displayed in the following order\n The \u0026ldquo;Hello\u0026rdquo; string Moving the cursor Button input status display  Back to previous page\r","excerpt":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt …","ref":"/en/docs/examples/beginner/1_p/exten/lcd/","title":"LCD"},{"body":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt also comes with two button switches and can be used as a controller.\nLeaf to use    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI04 LCD 1   AP03 STM32 MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE. The Basic Kit differs from the Basic Kit only in the specification of the pins. In order to use MIC\u0026amp;VR\u0026amp;LED Leaf, you need to install the library. If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : STM32L452RE (Nucleo-64/Nucleo L452RE) // // Leaf configuration // (1) AI04 LCD // (2) AP03 STM32 MCU // (3) AZ01 USB // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2021/01/26 First release //===================================================================== // use libraries // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IO pin name definition // Define it according to the leaf to be connected. //----------------------------------------------- #define SW1 PC7 // D2 (INT0)  //----------------------------------------------- // Define constants to be used in the program //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop(){ char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C control function //===================================================================== //----------------------------------------------- // I2C Write 1 byte to the slave device //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- // I2C Read 1 byte from the slave device //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } STM32_LED-SW_test.ino\nExecution Results On the LCD the screens are displayed in the following order\n The \u0026ldquo;Hello\u0026rdquo; string Moving the cursor Button input status display  Back to previous page\r","excerpt":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt …","ref":"/en/docs/examples/beginner/3_p/exten/lcd/","title":"LCD"},{"body":"概要 LCD(液晶ディスプレイ)リーフを使用すると、文字列を簡単に画面に表示することができます。\nまた、ボタンスイッチが2個搭載されていて、コントローラとして使うこともできます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI04 LCD 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : ATmega328P (3.3V /8MHz) // // Leaf configuration // (1) AI04 LCD // (2) AP01 AVR MCU // (3) AZ01 USB // //\t(c) 2021 LEAFONY SYSTEMS Co., Ltd //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== // use libraries // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IO pin name definition // Define it according to the leaf to be connected. //----------------------------------------------- #define SW1 2 // PD2 (INT0)  //----------------------------------------------- // Define constants to be used in the program //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop(){ char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C control function //===================================================================== //----------------------------------------------- //I2C Write 1 byte to the slave device //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C Read 1 byte from the slave device //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } LCD-SW_test.ino\n実行結果 LCDに下記の順で画面が表示されます。\n 「Hello」の文字列 カーソルの移動 ボタンの入力状態表示  前のページに戻る\r","excerpt":"概要 LCD(液晶ディスプレイ)リーフを使用すると、文字列を簡単に画面に表示することができます。\nまた、ボタンスイッチが2個搭載されていて、コントローラとして使うこともできます。\n使用するリー …","ref":"/docs/examples/beginner/1_p/exten/lcd/","title":"LCD"},{"body":"概要 LCD(液晶ディスプレイ)リーフを使用すると、文字列を簡単に画面に表示することができます。\nまた、ボタンスイッチが2個搭載されていて、コントローラとして使うこともできます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI04 LCD 1   AP03 STM32 MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    M2*15mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : ATmega328P (3.3V /8MHz) // // Leaf configuration // (1) AI04 LCD // (2) AP01 AVR MCU // (3) AZ01 USB // //\t(c) 2021 LEAFONY SYSTEMS Co., Ltd //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== // use libraries // ST7032 - Arduino LiquidCrystal compatible library // https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IO pin name definition // Define it according to the leaf to be connected. //----------------------------------------------- #define SW1 2 // PD2 (INT0)  //----------------------------------------------- // Define constants to be used in the program //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop(){ char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C control function //===================================================================== //----------------------------------------------- //I2C Write 1 byte to the slave device //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- //I2C Read 1 byte from the slave device //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } LCD-SW_test.ino\n実行結果 LCDに下記の順で画面が表示されます。\n 「Hello」の文字列 カーソルの移動 ボタンの入力状態表示  前のページに戻る\r","excerpt":"概要 LCD(液晶ディスプレイ)リーフを使用すると、文字列を簡単に画面に表示することができます。\nまた、ボタンスイッチが2個搭載されていて、コントローラとして使うこともできます。\n使用するリー …","ref":"/docs/examples/beginner/3_p/exten/lcd/","title":"LCD"},{"body":"  \nFeatures This leaf is equipped with a motor driver that can connect two DC motors.\nSpecification    Item Description     Part number TB6612FNG   Motor Supply Voltage 2.5V~13.5V   Output current (Vm≧4.5V) 1A   Output current (4.5V\u0026gt;Vm≧2.5V) 0.4A   Dimension W25.6×D30.9×H4.7mm        Block diagram \nPinassign \nTips Harness Connection \n   Pin Description     1 Motor A+   2 Motor A-   3 Motor B-   4 Motor B+   5 GND   6 Motor Supply (Vm)   7 GND   8 3.3V    Sample App AVR MCU Examples  Motor_BLE_demo  Library There is a library that supports this leaf.Please install and use the necessary libraries in Environment.\nDocument  Spec sheet Schematic PCBLayout(KiCad) 3D drawing  Revision history  First edition, December 2020  Back to previous page\r","excerpt":"Features This leaf is equipped with a motor driver that can connect two DC motors.\nSpecification …","ref":"/en/docs/leaf/io/aix1/","title":"AIx1 Motor"},{"body":"  \n特徴 2個のDCモータを接続可能なモータドライバを搭載したリーフです。\n性能    Item Description     Part number TB6612FNG   Motor Supply Voltage 2.5V~13.5V   Output current (Vm≧4.5V) 1A   Output current (4.5V\u0026gt;Vm≧2.5V) 0.4A   Dimension W25.6×D30.9×H4.7mm        ブロック図 \nピン配置 \nTips ハーネス接続について \n   Pin Description     1 Motor A+   2 Motor A-   3 Motor B-   4 Motor B+   5 GND   6 Motor Supply (Vm)   7 GND   8 3.3V    サンプルアプリ AVR MCU Examples  Motor_BLE_demo  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールしてご利用下さい。\nドキュメント  仕様書 回路図 レイアウト図(KiCad) 3D図面  変更履歴  2020年12月:初版  前のページに戻る\r","excerpt":"特徴 2個のDCモータを接続可能なモータドライバを搭載したリーフです。\n性能    Item Description     Part number TB6612FNG   Motor Supply …","ref":"/docs/leaf/io/aix1/","title":"AIx1 Motor"},{"body":"Overview The STM32 MCU leaf can be used with STMicroelectronics\u0026rsquo; STLINK-V3SET and ST-LINK/V2 debuggers. This page explains how to connect to these debuggers.\n STM32 debugger  What to prepare  STM32 MCU、Shield、Screw STLINK-V3SET /ST-LINK/V2＋ARM-JTAG-20-10 USB cable PC (Windows)  Connection method A 1.27mm pitch SWD connector (FTSH-105-01-L-D) is mounted on the Shield leaf, so you can attach an STM32 MCU leaf and connect it to the debugger.\nIn the case of STLINK-V3SET \nIn the case of ST-LINK/V2 + ARM-JTAG-20-10 \nBack to previous page\r","excerpt":"Overview The STM32 MCU leaf can be used with STMicroelectronics\u0026rsquo; STLINK-V3SET and ST-LINK/V2 …","ref":"/en/docs/environment/stm32/stm32_debug/","title":"How to connect the debugger"},{"body":"概要 STM32 MCUリーフは、STマイクロエレクトロニクス社のSTM32CubeIDEとSTLINK-V3SETまたはST-LINK/V2のデバッガを使用してデバッグを行うことができます。Arduino IDEを使用する場合はデバッガを使用したデバッグはできません。ここでは、これらのデバッガとの接続方法を説明します。\n STM32 デバッガ  用意するもの  STM32 MCU、Shield、Screw STLINK-V3SETの場合 /ST-LINK/V2＋ARM-JTAG-20-10の場合 USBケーブル PC (Windows)  接続方法 Shieldリーフに1.27mmピッチのSWDコネクタ(FTSH-105-01-L-D）が実装されているので、STM32 MCUリーフを装着し、デバッガと接続する。\nSTLINK-V3SETの場合 \nST-LINK/V2＋ARM-JTAG-20-10の場合 \n前のページに戻る\r","excerpt":"概要 STM32 MCUリーフは、STマイクロエレクトロニクス社のSTM32CubeIDEとSTLINK-V3SETまたはST-LINK/V2のデバッガを使用してデバッグを行うことができま …","ref":"/docs/environment/stm32/stm32_debug/","title":"デバッガの接続方法"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/examples/beginner/2_p/esp32/","title":"ESP32 Wi-Fi Kit"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/2_p/esp32/","title":"ESP32 Wi-Fi Kit 2"},{"body":"  \nFeatures A CR2032 coin cell battery holder is mounted on this leaf, and the voltage of the 3V battery is converted to 3.3V by a step-up power supply circuit, and 3.3V is supplied to each leaf. A switch for turning on/off the 3.3V is mounted on this leaf. The AD converter for monitoring the battery voltage is mounted in this IC.\nSpecification Dimension    Item Description     Dimension  W24×D20.5×H8.7mm    Power Supply    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    AD Converter    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    Block diagram \nPinassign \nTips About the switch \n   Item Description     Switch Switch for turning on and off the 3.3v power    Sample App  Read Battery  Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features A CR2032 coin cell battery holder is mounted on this leaf, and the voltage of the 3V …","ref":"/en/docs/leaf/power/av01/","title":"AV01 CR2032"},{"body":"  \n特徴 CR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能 外形サイズ    Item Description     Dimension  W24×D20.5×H8.7mm    電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips スイッチについて \n   Item Description     Switch Switch for turning on and off the 3.3v power    サンプルアプリ  バッテリ電圧読み取り  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"特徴 CR2032コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電 …","ref":"/docs/leaf/power/av01/","title":"AV01 CR2032"},{"body":"Power Leaf List\nBack to previous page\r","excerpt":"Power Leaf List\nBack to previous page\r","ref":"/en/docs/leaf/power/","title":"Power Supply"},{"body":"電源リーフ一覧\n前のページに戻る\r","excerpt":"電源リーフ一覧\n前のページに戻る\r","ref":"/docs/leaf/power/","title":"電源リーフ"},{"body":"Overview Displays the status of the boot mode switch on the ESP32 MCU leaf on the serial monitor.\n\nLeaf to use Use the following leaf.\n   Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1    Source code Write the following program in the Arduino IDE.\n//===================================================================== // Button // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/07/02 First release //=====================================================================  int pushButton = 0; void setup() { Serial.begin(115200); pinMode(pushButton, INPUT); } void loop() { int buttonState = digitalRead(pushButton); Serial.println(buttonState); delay(1000); } ESP32_Button.ino\nExecution Results When you press the Boot mode switch, the display on the serial monitor will change from 1 to 0.\n\nBack to previous page\r","excerpt":"Overview Displays the status of the boot mode switch on the ESP32 MCU leaf on the serial monitor. …","ref":"/en/docs/examples/beginner/2_p/esp32/button/","title":"Button"},{"body":"概要 ESP32 MCUリーフに搭載されたBoot mode スイッチの状態をシリアルモニタに表示させます。\n\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1    ソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // Button // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //=====================================================================  int pushButton = 0; void setup() { Serial.begin(115200); pinMode(pushButton, INPUT); } void loop() { int buttonState = digitalRead(pushButton); Serial.println(buttonState); delay(1000); } ESP32_Button.ino\n実行結果 Boot mode スイッチを押すと、シリアルモニタの表示が、１から０に変わります。\n\n前のページに戻る\r","excerpt":"概要 ESP32 MCUリーフに搭載されたBoot mode スイッチの状態をシリアルモニタに表示させます。\n\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/2_p/esp32/button/","title":"ボタン入力"},{"body":"  \nFeatures A CR2450 coin cell battery holder is mounted on this leaf, which converts 3 V battery voltage to 3.3 V using a step-up power supply circuit and supplies 3.3 V to each leaf. A switch for turning on/off the 3.3V is mounted on this leaf. The AD converter for monitoring the battery voltage is mounted in this IC.\nSpecification Dimension    Item Description     Dimension  W25.1×D25.5×H10.5mm    Power Supply    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    AD Converter    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    Block diagram \nPinassign \nTips About the switch \n   Item Description     Switch Switch for turning on and off the 3.3v power    Sample App  Read Battery  Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Back to previous page\r","excerpt":"Features A CR2450 coin cell battery holder is mounted on this leaf, which converts 3 V battery …","ref":"/en/docs/leaf/power/av02/","title":"AV02 CR2450"},{"body":"  \n特徴 CR2450コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能　 外形サイズ    Item Description     Dimension  W25.1×D25.5×H10.5mm    電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips スイッチについて \n   Item Description     Switch Switch for turning on and off the 3.3v power    サンプルアプリ  バッテリ電圧読み取り  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  前のページに戻る\r","excerpt":"特徴 CR2450コイン電池ホルダを実装し、3Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電 …","ref":"/docs/leaf/power/av02/","title":"AV02 CR2450"},{"body":"Overview The time will be displayed on the serial monitor of the PC.\nLeaf to use Use the following leaf.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AP02 ESP32 MCU 1   AZ02 RTC\u0026amp;microSD 1   AZ63 Nut Plate 1    M2*15mm screw 2    Assembly Source code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n  In the Arduino IDE, go to \u0026ldquo;File\u0026rdquo; -\u0026gt; \u0026ldquo;Sketch Examples\u0026rdquo; -\u0026gt; \u0026ldquo;RTClib\u0026rdquo; -\u0026gt; \u0026ldquo;pcf8523\u0026rdquo; and write it to the microcontroller board.\n  Add 87 lines for low power consumption setting.\n  // Date and time functions using a PCF8523 RTC connected via I2C and Wire lib #include \u0026#34;RTClib.h\u0026#34; RTC_PCF8523 rtc; char daysOfTheWeek[7][12] = {\u0026#34;Sunday\u0026#34;, \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34;}; void setup () { Serial.begin(115200); #ifndef ESP8266  while (!Serial); // wait for serial port to connect. Needed for native USB #endif  if (! rtc.begin()) { Serial.println(\u0026#34;Couldn\u0026#39;t find RTC\u0026#34;); Serial.flush(); abort(); } if (! rtc.initialized() || rtc.lostPower()) { Serial.println(\u0026#34;RTC is NOT initialized, let\u0026#39;s set the time!\u0026#34;); // When time needs to be set on a new device, or after a power loss, the  // following line sets the RTC to the date \u0026amp; time this sketch was compiled  rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); // This line sets the RTC with an explicit date \u0026amp; time, for example to set  // January 21, 2014 at 3am you would call:  // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));  //  // Note: allow 2 seconds after inserting battery or applying external power  // without battery before calling adjust(). This gives the PCF8523\u0026#39;s  // crystal oscillator time to stabilize. If you call adjust() very quickly  // after the RTC is powered, lostPower() may still return true.  } // When time needs to be re-set on a previously configured device, the  // following line sets the RTC to the date \u0026amp; time this sketch was compiled  // rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));  // This line sets the RTC with an explicit date \u0026amp; time, for example to set  // January 21, 2014 at 3am you would call:  // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));  // When the RTC was stopped and stays connected to the battery, it has  // to be restarted by clearing the STOP bit. Let\u0026#39;s do this to ensure  // the RTC is running.  rtc.start(); rtc.writeSqwPinMode(PCF8523_OFF); // Low consumption of electricity  } void loop () { DateTime now = rtc.now(); Serial.print(now.year(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(now.month(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(now.day(), DEC); Serial.print(\u0026#34; (\u0026#34;); Serial.print(daysOfTheWeek[now.dayOfTheWeek()]); Serial.print(\u0026#34;) \u0026#34;); Serial.print(now.hour(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(now.minute(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(now.second(), DEC); Serial.println(); Serial.print(\u0026#34; since midnight 1/1/1970 = \u0026#34;); Serial.print(now.unixtime()); Serial.print(\u0026#34;s = \u0026#34;); Serial.print(now.unixtime() / 86400L); Serial.println(\u0026#34;d\u0026#34;); // calculate a date which is 7 days, 12 hours and 30 seconds into the future  DateTime future (now + TimeSpan(7,12,30,6)); Serial.print(\u0026#34; now + 7d + 12h + 30m + 6s: \u0026#34;); Serial.print(future.year(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(future.month(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(future.day(), DEC); Serial.print(\u0026#39; \u0026#39;); Serial.print(future.hour(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(future.minute(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(future.second(), DEC); Serial.println(); Serial.println(); delay(3000); } Setting the Time The compiled time is written. When the RTC is initialized due to power loss, etc., it will be initialized to the compiled time.\nExecution Results When you start the serial monitor, the time will be displayed. Back to previous page\r","excerpt":"Overview The time will be displayed on the serial monitor of the PC.\nLeaf to use Use the following …","ref":"/en/docs/examples/beginner/2_p/esp32/rtc/","title":"Real time clock"},{"body":"概要 時刻がパソコンのシリアルモニタに表示されます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AP02 ESP32 MCU 1   AZ02 RTC\u0026amp;microSD 1   AZ63 Nut Plate 1    M2*15mm screw 2    リーフの組立 ソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n  Arduino IDEで、「ファイル」→「スケッチ例」→「RTClib」→「pcf8523」で、マイコンボードに書き込んでください。\n  低消費電力設定のため、87行を追加してください。\n  // Date and time functions using a PCF8523 RTC connected via I2C and Wire lib #include \u0026#34;RTClib.h\u0026#34; RTC_PCF8523 rtc; char daysOfTheWeek[7][12] = {\u0026#34;Sunday\u0026#34;, \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34;}; void setup () { Serial.begin(115200); #ifndef ESP8266  while (!Serial); // wait for serial port to connect. Needed for native USB #endif  if (! rtc.begin()) { Serial.println(\u0026#34;Couldn\u0026#39;t find RTC\u0026#34;); Serial.flush(); abort(); } if (! rtc.initialized() || rtc.lostPower()) { Serial.println(\u0026#34;RTC is NOT initialized, let\u0026#39;s set the time!\u0026#34;); // When time needs to be set on a new device, or after a power loss, the  // following line sets the RTC to the date \u0026amp; time this sketch was compiled  rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); // This line sets the RTC with an explicit date \u0026amp; time, for example to set  // January 21, 2014 at 3am you would call:  // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));  //  // Note: allow 2 seconds after inserting battery or applying external power  // without battery before calling adjust(). This gives the PCF8523\u0026#39;s  // crystal oscillator time to stabilize. If you call adjust() very quickly  // after the RTC is powered, lostPower() may still return true.  } // When time needs to be re-set on a previously configured device, the  // following line sets the RTC to the date \u0026amp; time this sketch was compiled  // rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));  // This line sets the RTC with an explicit date \u0026amp; time, for example to set  // January 21, 2014 at 3am you would call:  // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));  // When the RTC was stopped and stays connected to the battery, it has  // to be restarted by clearing the STOP bit. Let\u0026#39;s do this to ensure  // the RTC is running.  rtc.start(); rtc.writeSqwPinMode(PCF8523_OFF); // Low consumption of electricity  } void loop () { DateTime now = rtc.now(); Serial.print(now.year(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(now.month(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(now.day(), DEC); Serial.print(\u0026#34; (\u0026#34;); Serial.print(daysOfTheWeek[now.dayOfTheWeek()]); Serial.print(\u0026#34;) \u0026#34;); Serial.print(now.hour(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(now.minute(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(now.second(), DEC); Serial.println(); Serial.print(\u0026#34; since midnight 1/1/1970 = \u0026#34;); Serial.print(now.unixtime()); Serial.print(\u0026#34;s = \u0026#34;); Serial.print(now.unixtime() / 86400L); Serial.println(\u0026#34;d\u0026#34;); // calculate a date which is 7 days, 12 hours and 30 seconds into the future  DateTime future (now + TimeSpan(7,12,30,6)); Serial.print(\u0026#34; now + 7d + 12h + 30m + 6s: \u0026#34;); Serial.print(future.year(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(future.month(), DEC); Serial.print(\u0026#39;/\u0026#39;); Serial.print(future.day(), DEC); Serial.print(\u0026#39; \u0026#39;); Serial.print(future.hour(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(future.minute(), DEC); Serial.print(\u0026#39;:\u0026#39;); Serial.print(future.second(), DEC); Serial.println(); Serial.println(); delay(3000); } 時刻の設定 コンパイルした時間が書き込まれます。 電源がなくなる等でRTCが初期化されると、コンパイルした時間に初期化されます。\n実行結果 シリアルモニタを起動すると、時刻が表示されます。 前のページに戻る\r","excerpt":"概要 時刻がパソコンのシリアルモニタに表示されます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AP02 ESP32 …","ref":"/docs/examples/beginner/2_p/esp32/rtc/","title":"リアルタイムクロック"},{"body":"  \nFeatures This leaf has an AA battery holder and converts 1.5V battery voltage to 3.3V using a step-up power supply circuit and supplies 3.3V to each leaf. A switch for turning on/off the 3.3V is mounted. The AD converter for monitoring the battery voltage is mounted in this IC.\nSpecification Dimension    Item Description     Dimension  W23×D60×H24.2mm    Power Supply    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    AD Converter    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    Block diagram \nPinassign \nTips About the switch \n   Item Description     Switch Switch for turning on and off the 3.3v power    Sample App  Read Battery  Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D dawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features This leaf has an AA battery holder and converts 1.5V battery voltage to 3.3V using a …","ref":"/en/docs/leaf/power/av03/","title":"AV03 AA BAT"},{"body":"  \n特徴 単3電池ホルダを実装し、1.5Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニタするためのADコンバータを実装しています。\n性能 外形サイズ    Item Description     Dimension  W23×D60×H24.2mm    電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips スイッチについて \n   Item Description     Switch Switch for turning on and off the 3.3v power    サンプルデザイン  バッテリ電圧読み取り  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"特徴 単3電池ホルダを実装し、1.5Vの電池電圧を昇圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモ …","ref":"/docs/leaf/power/av03/","title":"AV03 AA BAT"},{"body":"Overview The information on the microSD card will be displayed on the serial monitor of the PC.\nLeaf to use    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AP02 ESP32 MCU 1   AZ02 RTC\u0026amp;microSD 1   AZ63 Nut Plate 1    M2*15mm screw 2    Assembly Source code  In the Arduino IDE, go to File -\u0026gt; Sketch Examples -\u0026gt; SD(esp32) -\u0026gt; SD_Test and write it to the microcontroller board.  /* * Connect the SD card to the following pins: * * SD Card | ESP32 * D2 - * D3 SS * CMD MOSI * VSS GND * VDD 3.3V * CLK SCK * VSS GND * D0 MISO * D1 - */ #include \u0026#34;FS.h\u0026#34;#include \u0026#34;SD.h\u0026#34;#include \u0026#34;SPI.h\u0026#34; void listDir(fs::FS \u0026amp;fs, const char * dirname, uint8_t levels){ Serial.printf(\u0026#34;Listing directory: %s\\n\u0026#34;, dirname); File root = fs.open(dirname); if(!root){ Serial.println(\u0026#34;Failed to open directory\u0026#34;); return; } if(!root.isDirectory()){ Serial.println(\u0026#34;Not a directory\u0026#34;); return; } File file = root.openNextFile(); while(file){ if(file.isDirectory()){ Serial.print(\u0026#34; DIR : \u0026#34;); Serial.println(file.name()); if(levels){ listDir(fs, file.name(), levels -1); } } else { Serial.print(\u0026#34; FILE: \u0026#34;); Serial.print(file.name()); Serial.print(\u0026#34; SIZE: \u0026#34;); Serial.println(file.size()); } file = root.openNextFile(); } } void createDir(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Creating Dir: %s\\n\u0026#34;, path); if(fs.mkdir(path)){ Serial.println(\u0026#34;Dir created\u0026#34;); } else { Serial.println(\u0026#34;mkdir failed\u0026#34;); } } void removeDir(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Removing Dir: %s\\n\u0026#34;, path); if(fs.rmdir(path)){ Serial.println(\u0026#34;Dir removed\u0026#34;); } else { Serial.println(\u0026#34;rmdir failed\u0026#34;); } } void readFile(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Reading file: %s\\n\u0026#34;, path); File file = fs.open(path); if(!file){ Serial.println(\u0026#34;Failed to open file for reading\u0026#34;); return; } Serial.print(\u0026#34;Read from file: \u0026#34;); while(file.available()){ Serial.write(file.read()); } file.close(); } void writeFile(fs::FS \u0026amp;fs, const char * path, const char * message){ Serial.printf(\u0026#34;Writing file: %s\\n\u0026#34;, path); File file = fs.open(path, FILE_WRITE); if(!file){ Serial.println(\u0026#34;Failed to open file for writing\u0026#34;); return; } if(file.print(message)){ Serial.println(\u0026#34;File written\u0026#34;); } else { Serial.println(\u0026#34;Write failed\u0026#34;); } file.close(); } void appendFile(fs::FS \u0026amp;fs, const char * path, const char * message){ Serial.printf(\u0026#34;Appending to file: %s\\n\u0026#34;, path); File file = fs.open(path, FILE_APPEND); if(!file){ Serial.println(\u0026#34;Failed to open file for appending\u0026#34;); return; } if(file.print(message)){ Serial.println(\u0026#34;Message appended\u0026#34;); } else { Serial.println(\u0026#34;Append failed\u0026#34;); } file.close(); } void renameFile(fs::FS \u0026amp;fs, const char * path1, const char * path2){ Serial.printf(\u0026#34;Renaming file %s to %s\\n\u0026#34;, path1, path2); if (fs.rename(path1, path2)) { Serial.println(\u0026#34;File renamed\u0026#34;); } else { Serial.println(\u0026#34;Rename failed\u0026#34;); } } void deleteFile(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Deleting file: %s\\n\u0026#34;, path); if(fs.remove(path)){ Serial.println(\u0026#34;File deleted\u0026#34;); } else { Serial.println(\u0026#34;Delete failed\u0026#34;); } } void testFileIO(fs::FS \u0026amp;fs, const char * path){ File file = fs.open(path); static uint8_t buf[512]; size_t len = 0; uint32_t start = millis(); uint32_t end = start; if(file){ len = file.size(); size_t flen = len; start = millis(); while(len){ size_t toRead = len; if(toRead \u0026gt; 512){ toRead = 512; } file.read(buf, toRead); len -= toRead; } end = millis() - start; Serial.printf(\u0026#34;%u bytes read for %u ms\\n\u0026#34;, flen, end); file.close(); } else { Serial.println(\u0026#34;Failed to open file for reading\u0026#34;); } file = fs.open(path, FILE_WRITE); if(!file){ Serial.println(\u0026#34;Failed to open file for writing\u0026#34;); return; } size_t i; start = millis(); for(i=0; i\u0026lt;2048; i++){ file.write(buf, 512); } end = millis() - start; Serial.printf(\u0026#34;%u bytes written for %u ms\\n\u0026#34;, 2048 * 512, end); file.close(); } void setup(){ Serial.begin(115200); if(!SD.begin()){ Serial.println(\u0026#34;Card Mount Failed\u0026#34;); return; } uint8_t cardType = SD.cardType(); if(cardType == CARD_NONE){ Serial.println(\u0026#34;No SD card attached\u0026#34;); return; } Serial.print(\u0026#34;SD Card Type: \u0026#34;); if(cardType == CARD_MMC){ Serial.println(\u0026#34;MMC\u0026#34;); } else if(cardType == CARD_SD){ Serial.println(\u0026#34;SDSC\u0026#34;); } else if(cardType == CARD_SDHC){ Serial.println(\u0026#34;SDHC\u0026#34;); } else { Serial.println(\u0026#34;UNKNOWN\u0026#34;); } uint64_t cardSize = SD.cardSize() / (1024 * 1024); Serial.printf(\u0026#34;SD Card Size: %lluMB\\n\u0026#34;, cardSize); listDir(SD, \u0026#34;/\u0026#34;, 0); createDir(SD, \u0026#34;/mydir\u0026#34;); listDir(SD, \u0026#34;/\u0026#34;, 0); removeDir(SD, \u0026#34;/mydir\u0026#34;); listDir(SD, \u0026#34;/\u0026#34;, 2); writeFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;Hello \u0026#34;); appendFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;World!\\n\u0026#34;); readFile(SD, \u0026#34;/hello.txt\u0026#34;); deleteFile(SD, \u0026#34;/foo.txt\u0026#34;); renameFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;/foo.txt\u0026#34;); readFile(SD, \u0026#34;/foo.txt\u0026#34;); testFileIO(SD, \u0026#34;/test.txt\u0026#34;); Serial.printf(\u0026#34;Total space: %lluMB\\n\u0026#34;, SD.totalBytes() / (1024 * 1024)); Serial.printf(\u0026#34;Used space: %lluMB\\n\u0026#34;, SD.usedBytes() / (1024 * 1024)); } void loop(){ } Execution Results The information on the microSD card will be displayed on the serial monitor of the PC.\nBack to previous page\r","excerpt":"Overview The information on the microSD card will be displayed on the serial monitor of the PC.\nLeaf …","ref":"/en/docs/examples/beginner/2_p/esp32/microsd/","title":"micro SD"},{"body":"概要 microSD カードの情報が、パソコンのシリアルモニタに表示されます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AP02 ESP32 MCU 1   AZ02 RTC\u0026amp;microSD 1   AZ63 Nut Plate 1    M2*15mm screw 2    リーフの組立 ソースコード  Arduino IDEで、「ファイル」→「スケッチ例」→「SD(esp32)」→「SD_Test」で、マイコンボードに書き込んでください。  /* * Connect the SD card to the following pins: * * SD Card | ESP32 * D2 - * D3 SS * CMD MOSI * VSS GND * VDD 3.3V * CLK SCK * VSS GND * D0 MISO * D1 - */ #include \u0026#34;FS.h\u0026#34;#include \u0026#34;SD.h\u0026#34;#include \u0026#34;SPI.h\u0026#34; void listDir(fs::FS \u0026amp;fs, const char * dirname, uint8_t levels){ Serial.printf(\u0026#34;Listing directory: %s\\n\u0026#34;, dirname); File root = fs.open(dirname); if(!root){ Serial.println(\u0026#34;Failed to open directory\u0026#34;); return; } if(!root.isDirectory()){ Serial.println(\u0026#34;Not a directory\u0026#34;); return; } File file = root.openNextFile(); while(file){ if(file.isDirectory()){ Serial.print(\u0026#34; DIR : \u0026#34;); Serial.println(file.name()); if(levels){ listDir(fs, file.name(), levels -1); } } else { Serial.print(\u0026#34; FILE: \u0026#34;); Serial.print(file.name()); Serial.print(\u0026#34; SIZE: \u0026#34;); Serial.println(file.size()); } file = root.openNextFile(); } } void createDir(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Creating Dir: %s\\n\u0026#34;, path); if(fs.mkdir(path)){ Serial.println(\u0026#34;Dir created\u0026#34;); } else { Serial.println(\u0026#34;mkdir failed\u0026#34;); } } void removeDir(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Removing Dir: %s\\n\u0026#34;, path); if(fs.rmdir(path)){ Serial.println(\u0026#34;Dir removed\u0026#34;); } else { Serial.println(\u0026#34;rmdir failed\u0026#34;); } } void readFile(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Reading file: %s\\n\u0026#34;, path); File file = fs.open(path); if(!file){ Serial.println(\u0026#34;Failed to open file for reading\u0026#34;); return; } Serial.print(\u0026#34;Read from file: \u0026#34;); while(file.available()){ Serial.write(file.read()); } file.close(); } void writeFile(fs::FS \u0026amp;fs, const char * path, const char * message){ Serial.printf(\u0026#34;Writing file: %s\\n\u0026#34;, path); File file = fs.open(path, FILE_WRITE); if(!file){ Serial.println(\u0026#34;Failed to open file for writing\u0026#34;); return; } if(file.print(message)){ Serial.println(\u0026#34;File written\u0026#34;); } else { Serial.println(\u0026#34;Write failed\u0026#34;); } file.close(); } void appendFile(fs::FS \u0026amp;fs, const char * path, const char * message){ Serial.printf(\u0026#34;Appending to file: %s\\n\u0026#34;, path); File file = fs.open(path, FILE_APPEND); if(!file){ Serial.println(\u0026#34;Failed to open file for appending\u0026#34;); return; } if(file.print(message)){ Serial.println(\u0026#34;Message appended\u0026#34;); } else { Serial.println(\u0026#34;Append failed\u0026#34;); } file.close(); } void renameFile(fs::FS \u0026amp;fs, const char * path1, const char * path2){ Serial.printf(\u0026#34;Renaming file %s to %s\\n\u0026#34;, path1, path2); if (fs.rename(path1, path2)) { Serial.println(\u0026#34;File renamed\u0026#34;); } else { Serial.println(\u0026#34;Rename failed\u0026#34;); } } void deleteFile(fs::FS \u0026amp;fs, const char * path){ Serial.printf(\u0026#34;Deleting file: %s\\n\u0026#34;, path); if(fs.remove(path)){ Serial.println(\u0026#34;File deleted\u0026#34;); } else { Serial.println(\u0026#34;Delete failed\u0026#34;); } } void testFileIO(fs::FS \u0026amp;fs, const char * path){ File file = fs.open(path); static uint8_t buf[512]; size_t len = 0; uint32_t start = millis(); uint32_t end = start; if(file){ len = file.size(); size_t flen = len; start = millis(); while(len){ size_t toRead = len; if(toRead \u0026gt; 512){ toRead = 512; } file.read(buf, toRead); len -= toRead; } end = millis() - start; Serial.printf(\u0026#34;%u bytes read for %u ms\\n\u0026#34;, flen, end); file.close(); } else { Serial.println(\u0026#34;Failed to open file for reading\u0026#34;); } file = fs.open(path, FILE_WRITE); if(!file){ Serial.println(\u0026#34;Failed to open file for writing\u0026#34;); return; } size_t i; start = millis(); for(i=0; i\u0026lt;2048; i++){ file.write(buf, 512); } end = millis() - start; Serial.printf(\u0026#34;%u bytes written for %u ms\\n\u0026#34;, 2048 * 512, end); file.close(); } void setup(){ Serial.begin(115200); if(!SD.begin()){ Serial.println(\u0026#34;Card Mount Failed\u0026#34;); return; } uint8_t cardType = SD.cardType(); if(cardType == CARD_NONE){ Serial.println(\u0026#34;No SD card attached\u0026#34;); return; } Serial.print(\u0026#34;SD Card Type: \u0026#34;); if(cardType == CARD_MMC){ Serial.println(\u0026#34;MMC\u0026#34;); } else if(cardType == CARD_SD){ Serial.println(\u0026#34;SDSC\u0026#34;); } else if(cardType == CARD_SDHC){ Serial.println(\u0026#34;SDHC\u0026#34;); } else { Serial.println(\u0026#34;UNKNOWN\u0026#34;); } uint64_t cardSize = SD.cardSize() / (1024 * 1024); Serial.printf(\u0026#34;SD Card Size: %lluMB\\n\u0026#34;, cardSize); listDir(SD, \u0026#34;/\u0026#34;, 0); createDir(SD, \u0026#34;/mydir\u0026#34;); listDir(SD, \u0026#34;/\u0026#34;, 0); removeDir(SD, \u0026#34;/mydir\u0026#34;); listDir(SD, \u0026#34;/\u0026#34;, 2); writeFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;Hello \u0026#34;); appendFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;World!\\n\u0026#34;); readFile(SD, \u0026#34;/hello.txt\u0026#34;); deleteFile(SD, \u0026#34;/foo.txt\u0026#34;); renameFile(SD, \u0026#34;/hello.txt\u0026#34;, \u0026#34;/foo.txt\u0026#34;); readFile(SD, \u0026#34;/foo.txt\u0026#34;); testFileIO(SD, \u0026#34;/test.txt\u0026#34;); Serial.printf(\u0026#34;Total space: %lluMB\\n\u0026#34;, SD.totalBytes() / (1024 * 1024)); Serial.printf(\u0026#34;Used space: %lluMB\\n\u0026#34;, SD.usedBytes() / (1024 * 1024)); } void loop(){ } 実行結果 microSD カードの情報が、パソコンのシリアルモニタに表示されます。\n前のページに戻る\r","excerpt":"概要 microSD カードの情報が、パソコンのシリアルモニタに表示されます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1 …","ref":"/docs/examples/beginner/2_p/esp32/microsd/","title":"micro SD"},{"body":"  \nFeatures The RTC is equipped with a JST SH connector, which converts 2 to 4.5V battery voltage to 3.3V with a step-up/down power supply circuit and supplies 3.3V to each leaf. A switch to turn on/off the 3.3V is mounted on the IC. It has an AD converter to monitor the battery voltage. The batteries that can be connected to the SH connector are assumed to be two or three dry batteries or Li-Po and Li-ION batteries.\nSpecification Dimension    Item Description     Dimension  W23×D21×H6.2mm    Power Supply    Item Description     Part number RP604K331B-TR   Battery voltage 1.8～5.5V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA (when step down)   Protection circuit Over current protection / Thermal shutdown    AD Converter    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    Block diagram \nPinassign \nTips Switches and Connectors \n   Item Description     Switch Switch for turning on and off the 3.3v power   Connector JST SH connector    Sample App  Read Battery  ドキュメント  Spec sheet Schematic Component marking (Front side) Component marking (reverse side) PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, January 2020  Back to previous page\r","excerpt":"Features The RTC is equipped with a JST SH connector, which converts 2 to 4.5V battery voltage to …","ref":"/en/docs/leaf/power/av04/","title":"AV04A 2V～4.5V"},{"body":"  \n特徴 JST製SHコネクタを実装し、2～4.5Vの電池電圧を昇降圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、電池電圧をモニターするためのADコンバータを実装しています。 SHコネクタに接続可能な電池は乾電池2～3本またはLi-Po、Li-ION電池を想定しています。\n性能　 外形サイズ    Item Description     Dimension  W23×D21×H6.2mm    電源    Item Description     Part number RP604K331B-TR   Battery voltage 1.8～5.5V   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA (when step down)   Protection circuit Over current protection / Thermal shutdown    ADコンバータ    Item Description     Part number ADC081C027CIMK   Resolution 8bit   Reference voltage Vdd(3.3V)   Sample rate 188.9kSPS(max)   Interfaces I2C (Address: 0x50)    ブロック図 \nピン配置 \nTips スイッチ、コネクタについて \n   Item Description     Switch Switch for turning on and off the 3.3v power   Connector JST SH connector    サンプルアプリ  バッテリ電圧読み取り  ドキュメント  仕様書 回路図 部品配置図(表面) 部品配置図(裏面) レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2020年1月:初版  前のページに戻る\r","excerpt":"特徴 JST製SHコネクタを実装し、2～4.5Vの電池電圧を昇降圧電源回路により3.3Vに変換し、3.3Vを各リーフに供給するリーフです。3.3Vをオン/オフするためのスイッチを実装しています。また、 …","ref":"/docs/leaf/power/av04/","title":"AV04 2V～4.5V"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/examples/beginner/2_p/basic/","title":"ESP32 Wi-Fi Kit + Basic Kit"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/2_p/basic/","title":"ESP32 Wi-Fi Kit 2 + Basic Kit 2"},{"body":"Extension Leaf List\nBack to previous page\r","excerpt":"Extension Leaf List\nBack to previous page\r","ref":"/en/docs/leaf/extension/","title":"Extension"},{"body":"  \nFeatures An expansion board with an Arduino Shield connector, a SWD connector, an ICSP connector, and three leaf I/Fs mounted on it.\nSpecification    Item Description     Dimension  W59.2×D59.8×H11mm    Block diagram \nDocument  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"  \nFeatures An expansion board with an Arduino Shield connector, a SWD connector, an ICSP connector, …","ref":"/en/docs/leaf/extension/ax01/","title":"AX01 Shield"},{"body":"  \n特徴 Arduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\n性能    Item Description     Dimension  W59.2×D59.8×H11mm    ブロック図 \nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"  \n特徴 Arduino Shield接続用コネクタ、SWDコネクタ、ICSPコネクタ、リーフI/F3個を実装した拡張基板です。\n性能    Item Description …","ref":"/docs/leaf/extension/ax01/","title":"AX01 Shield"},{"body":"拡張リーフ一覧\n前のページに戻る\r","excerpt":"拡張リーフ一覧\n前のページに戻る\r","ref":"/docs/leaf/extension/","title":"拡張リーフ"},{"body":"Overview This sample reads the value of the temperature and humidity sensor mounted on the 4-Sensors leaf and displays it on the serial monitor.\nLeaf to use Use the following leaf.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Thermo-hygrometer ESP32 // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/07/28 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // Data for two-point correction //--------------------------- // Temperature correction data 0 float TL0 = 25.0; // 4-Sensors Temperature measurement value float TM0 = 25.0; // Thermometer and other measurements value // Temperature correction data 1 float TL1 = 40.0; // 4-Sensors Temperature measurement value float TM1 = 40.0; // Thermometer and other measurements value  // Humidity correction data 0 float HL0 = 60.0; // 4-Sensors Humidity measurement value float HM0 = 60.0; // Hygrometer and other measurements value // Humidity correction data 1 float HL1 = 80.0; // 4-Sensors Humidity measurement value float HM1 = 80.0; // Hygrometer and other measurements value  void setup() { // initialize serial communication at 115200 bit per second:  Serial.begin(115200); // I2C 初期化  pinMode(21, OUTPUT); // SDA  digitalWrite(21, 0); Wire.begin(); // I2C 100kHz  // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // 温度補正  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // 湿度補正  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } ESP32_Thermo-Hygrometer.ino\n2 point-to-point correction If there is a discrepancy between the temperature (or humidity) that you want to display and the temperature (or humidity) of the 4-Sensors, perform the correction between the two points. The following is a description of the correction method using temperature as an example.\nFirst, measure the temperatures of the two points with the 4-Sensors and a reference instrument. Then, write the measured values in the sample sketch and run it, and the temperature of the 4-Sensors will be close to the temperature you want to display.　Execution Results Open the serial monitor in the Arduino IDE and set the baud rate to 115200 bps to display the temperature and humidity.\nBack to previous page\r","excerpt":"Overview This sample reads the value of the temperature and humidity sensor mounted on the 4-Sensors …","ref":"/en/docs/examples/beginner/2_p/basic/temp_humid_sensors/","title":"Temperature and humidity sensor"},{"body":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Thermo-hygrometer ESP32 // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt; //--------------------------- // Data for two-point correction //--------------------------- // Temperature correction data 0 float TL0 = 25.0; // 4-Sensors Temperature measurement value float TM0 = 25.0; // Thermometer and other measurements value // Temperature correction data 1 float TL1 = 40.0; // 4-Sensors Temperature measurement value float TM1 = 40.0; // Thermometer and other measurements value  // Humidity correction data 0 float HL0 = 60.0; // 4-Sensors Humidity measurement value float HM0 = 60.0; // Hygrometer and other measurements value // Humidity correction data 1 float HL1 = 80.0; // 4-Sensors Humidity measurement value float HM1 = 80.0; // Hygrometer and other measurements value  void setup() { // initialize serial communication at 115200 bit per second:  Serial.begin(115200); // I2C 初期化  pinMode(21, OUTPUT); // SDA  digitalWrite(21, 0); Wire.begin(); // I2C 100kHz  // initialize i2c communication with HTS221:  smeHumidity.begin(); delay(10); } void loop() { // read temperature and humidity:  float dataTemp = (float)smeHumidity.readTemperature(); float dataHumid = (float)smeHumidity.readHumidity(); // calibration:  dataTemp = TM0 + (TM1 - TM0) * (dataTemp - TL0) / (TL1 - TL0); // 温度補正  dataHumid = HM0 + (HM1 - HM0) * (dataHumid - HL0) / (HL1 - HL0); // 湿度補正  Serial.println(String(dataTemp) + \u0026#34;[℃], \u0026#34; + String(dataHumid) + \u0026#34;[%]\u0026#34;); delay(1000); } ESP32_Thermo-Hygrometer.ino\n2点間補正 表示させたい温度（または、湿度）と４-Sensorsの温度（または、湿度）に、ずれがあるときは、２点間補正を行います。以下は、温度を例に、補正方法を記します。\nまず、４-Sensorsと、基準となる計測器で、２点の温度を測定してください。次に、測定した値を、サンプルスケッチに書き込んで、実行して頂ければ、４-Sensorsの温度が、表示させたい温度に近づきます。　実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、温度と湿度が表示されます。\n前のページに戻る\r","excerpt":"概要 4-Sensorsリーフに搭載された温湿度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/2_p/basic/temp_humid_sensors/","title":"温湿度センサ読み取り"},{"body":"  \nFeatures This is a leaf with all 29 pins of the leaf I/F connected to a through-hole.\nSpecification    Item Description     Dimension  W23×D20.5×H4.7mm    Pinassign \nDocuments  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) PCBLayout(KiCad)1 PCBLayout(EAGLE)1 3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r  The data from KiCad and EAGLE, both of which are widely used by individuals, have been prepared by converting Zuken\u0026rsquo;s CAD data, so the possibility of conversion errors cannot be excluded. Please check the dimensions and other factors carefully before using the data. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Features This is a leaf with all 29 pins of the leaf I/F connected to a through-hole.\nSpecification …","ref":"/en/docs/leaf/extension/ax02/","title":"AX02 29 pin"},{"body":"  \n特徴 リーフI/Fの29ピン全てをスルーホールに接続したリーフです。\n性能    Item Description     Dimension  W23×D20.5×H4.7mm    ピン配置 \nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) レイアウト図(KiCad) 1 レイアウト図(EAGLE) 1 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r  個人の方が、多く利用しているKiCadとEAGLEのデータをご用意しました。Zuken のCADデータを変換して作成したので、変換ミスの可能性をぬぐいきれません。各自で、寸法等十分確認の上、ご使用ください。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"  \n特徴 リーフI/Fの29ピン全てをスルーホールに接続したリーフです。\n性能    Item Description     Dimension  W23×D20.5×H4.7mm …","ref":"/docs/leaf/extension/ax02/","title":"AX02 29 pin"},{"body":"Overview This sample reads the value of the illuminance sensor mounted on the 4-Sensors leaf and displays it on the serial monitor.\nLeaf to use Use the following leaf.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Illuminance meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\nExecution Results Open the serial monitor in the Arduino IDE and set the baud rate to 115200 bps, and you will see the illumination.\nBack to previous page\r","excerpt":"Overview This sample reads the value of the illuminance sensor mounted on the 4-Sensors leaf and …","ref":"/en/docs/examples/beginner/2_p/basic/illum_sensor/","title":"Illum sensor"},{"body":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Illuminance meter // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; #define OPT3001_ADDRESS 0x45 // ADDR pin = VCC  ClosedCube_OPT3001 illum; float dataIllum; void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with OPT3001:  Wire.begin(); delay(10); OPT3001_Config illumConfig; OPT3001_ErrorCode illumErrorConfig; illum.begin(OPT3001_ADDRESS); illumConfig.RangeNumber = B1100; // automatic full scale  illumConfig.ConvertionTime = B1; // convertion time = 800ms  illumConfig.ModeOfConversionOperation = B11; // continous conversion  illumConfig.Latch = B0; // hysteresis-style  illumErrorConfig = illum.writeConfig(illumConfig); if(illumErrorConfig != NO_ERROR){ illumErrorConfig = illum.writeConfig(illumConfig); //retry  } } void loop() { OPT3001 result = illum.readResult(); if(result.error == NO_ERROR){ dataIllum = result.lux; } Serial.println(\u0026#34;Lum[lx] = \u0026#34; + String(dataIllum)); delay(1000); } Illuminance_Meter.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、照度が表示されます。\n前のページに戻る\r","excerpt":"概要 4-Sensorsリーフに搭載された照度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/2_p/basic/illum_sensor/","title":"照度センサ読み取り"},{"body":"  \nFeatures Leaf for connecting all the leaf I/F terminals to the side.\nSpecification    Item Description     Dimension  W50×D20.5×H4.7mm    Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"  \nFeatures Leaf for connecting all the leaf I/F terminals to the side.\nSpecification    Item …","ref":"/en/docs/leaf/extension/ax03/","title":"AX03 Leaf x2"},{"body":"  \n特徴 全てのリーフI/F端子を接続したリーフを横に接続するためのリーフです。\n性能    Item Description     Dimension  W50×D20.5×H4.7mm    ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"  \n特徴 全てのリーフI/F端子を接続したリーフを横に接続するためのリーフです。\n性能    Item Description     Dimension  W50×D20.5×H4.7mm     …","ref":"/docs/leaf/extension/ax03/","title":"AX03 Leaf x2"},{"body":"Overview This sample reads the value of the accelerometer mounted on the 4-Sensors leaf and displays it on the serial monitor.\nLeaf to use Use the following leaf.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Accelerometer // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/05/05 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\nExecution Results Open the serial monitor in the Arduino IDE and set the baud rate to 115200 bps to display the acceleration and tilt.\nBack to previous page\r","excerpt":"Overview This sample reads the value of the accelerometer mounted on the 4-Sensors leaf and displays …","ref":"/en/docs/examples/beginner/2_p/basic/accelerometer/","title":"Accelerometer"},{"body":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図を参考にリーフを組み立ててみましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Accelerometer // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== #include \u0026lt;Adafruit_LIS3DH.h\u0026gt; #define LIS3DH_ADDRESS 0x19  Adafruit_LIS3DH accel = Adafruit_LIS3DH(); void setup() { // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication with LIS3DH:  accel.begin(LIS3DH_ADDRESS); accel.setClick(0, 0); // Disable Interrupt  accel.setRange(LIS3DH_RANGE_2_G); // Full scale +/- 2G  accel.setDataRate(LIS3DH_DATARATE_10_HZ); // Data rate = 10Hz  delay(100); } void loop() { accel.read(); Serial.print(\u0026#34;X [g] = \u0026#34; + String(accel.x_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Y [g] = \u0026#34; + String(accel.y_g)); Serial.print(\u0026#34;, \u0026#34;); Serial.print(\u0026#34;Z [g] = \u0026#34; + String(accel.z_g)); Serial.println(\u0026#34;\u0026#34;); delay(100); } Accelerometer.ino\n実行結果 Arduino IDEのシリアルモニタを開き、ボーレートを115200bpsとすると、加速度と傾きが表示されます。\n前のページに戻る\r","excerpt":"概要 4-Sensorsリーフに搭載された加速度センサの値を読み取って、シリアルモニタに表示するサンプルです。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/2_p/basic/accelerometer/","title":"加速度センサ読み取り"},{"body":"  \nFeatures A spacer leaf that is placed between two stacked leaves. It can be used when parts of the leafs interfere with each other.\nSpecification    Item Description     Dimension  W23×D6×H4.7mm    Document  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"  \nFeatures A spacer leaf that is placed between two stacked leaves. It can be used when parts of …","ref":"/en/docs/leaf/extension/ax04/","title":"AX04 Spacer"},{"body":"  \n特徴 積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\n性能    Item Description     Dimension  W23×D6×H4.7mm    ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"  \n特徴 積み重ねた2枚のリーフの間に挟むスペーサリーフです。リーフ同士の部品が干渉する時に使えます。\n性能    Item Description     Dimension …","ref":"/docs/leaf/extension/ax04/","title":"AX04 Spacer"},{"body":"  \nFeatures This leaf can measure the current consumption of 3.3V and VBUS. In the current measurement leaf, the pads on the front and back sides of the 3.3V and VBUS are electrically separated, so by connecting an ammeter to each of the following through holes, the total power supply current of a single leaf or a group of leaves located far from the battery leaf can be measured. In the example below, the sensor leaf and the BLE leaf are located on the far side of the battery leaf via the current measurement leaf, so the total current of both leaves can be measured.\nSpecification    Item Description     Dimension  W23×D20.5×H4.7mm    Document  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features This leaf can measure the current consumption of 3.3V and VBUS. In the current measurement …","ref":"/en/docs/leaf/extension/ax05/","title":"AX05 I Meas"},{"body":"  \n特徴 3.3VおよびVBUSの消費電流を測定することが出来るリーフです。 電流測定リーフでは3.3VとVBUSは表面と裏面のパッドが電気的に切り離されているので、下記の各々スルーホールに電流計を接続することで、電池リーフから遠い部分にある単体リーフあるいは複数リーフ群の全電源電流を測定出来ます。下の例では、センサリーフとBLEリーフが電流測定リーフを介して、電池リーフの遠い側に配置されているので、両リーフの合計電流が測定出来ます。\n性能    Item Description     Dimension  W23×D20.5×H4.7mm    ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"  \n特徴 3.3VおよびVBUSの消費電流を測定することが出来るリーフです。 電流測定リーフでは3.3VとVBUSは表面と裏面のパッドが電気的に切り離されているので、下記の各々スルーホールに電流計を …","ref":"/docs/leaf/extension/ax05/","title":"AX05 I Meas"},{"body":"  \nFeatures Seeed Studio Grove series compliant leafs that operate at 5 V with UART, I2C, analog and digital inputs. 3.3 V to 5 V is converted to 5 V by a step-up power supply circuit and supplied to the Grove. It is possible to turn off the 5V power supply by controlling the I2C Expander to achieve low power consumption.\nSpecification Dimension    Item Description     Dimension  W33.8×D24.7×H4.7mm    Power Supply    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 5V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1B)    Block diagram \nPinassign \nTips About UART, I2C, Analog and Digital \n   Item Description     UART For UART communication   I2C For I2C communication   Analog Analog Signal Inputs   Digital Digital Signal Inputs    Sample App  Distance Sensor Camera  Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history　  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features Seeed Studio Grove series compliant leafs that operate at 5 V with UART, I2C, analog and …","ref":"/en/docs/leaf/extension/ax06/","title":"AX06 Grove\u00265V"},{"body":"  \n特徴 Seeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給します。Grove対応ピンの仕様は以下の通り。 低消費電力を実現するためI2C Expander を制御することにより5Vの電源をオフすることが可能です。\n性能 外形サイズ    Item Description     Dimension  W33.8×D24.7×H4.7mm    電源    Item Description     Part number TPS61099YFFR   Battery voltage 0.7～3.8V   Output voltage 5V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 300mA @3.3V to 5V   Protection circuit Over current protection / Thermal shutdown    I2C I/O Expander    Item Description     Part number PCA9557RGVR   Interface I2C (Address: 0x1B)    ブロック図 \nピン配置 \nTips UART、I2C、Analog、Digitalについて \n   Item Description     UART For UART communication   I2C For I2C communication   Analog Analog Signal Inputs   Digital Digital Signal Inputs    サンプルアプリ  超音波センサで距離測定 カメラの撮影  ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"特徴 Seeed Studio製 Groveシリーズに準拠する5Vで動作するUART、I2C、アナログ入力、デジタル入力が可能なリーフです。3.3Vから昇圧電源回路により5Vに変換しGroveに供給し …","ref":"/docs/leaf/extension/ax06/","title":"AX06 Grove\u00265V"},{"body":"  \nFeatures This leaf is used to invert the leaf with all the leaf I/F terminals connected to it.\nSpecification    Item Description     Dimension  W29×D17×H4.7mm     Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, January 2020  Back to previous page\r","excerpt":"  \nFeatures This leaf is used to invert the leaf with all the leaf I/F terminals connected to it. …","ref":"/en/docs/leaf/extension/ax07/","title":"AX07 Back to back"},{"body":"  \n特徴 全てのリーフI/F端子を接続したリーフを反転させて接続するためのリーフです。\n性能    Item Description     Dimension  W29×D17×H4.7mm     ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2020年1月:初版  前のページに戻る\r","excerpt":"  \n特徴 全てのリーフI/F端子を接続したリーフを反転させて接続するためのリーフです。\n性能    Item Description     Dimension  W29×D17×H4.7mm …","ref":"/docs/leaf/extension/ax07/","title":"AX07 Back to back"},{"body":"  \nFeatures This is a leaf with all 29 pins of the leaf I/F connected to the pin headers.\nSpecification    Item Description     Dimension  W30×D20.5×H10.6mm     Pinassign \nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, January 2020  Back to previous page\r","excerpt":"  \nFeatures This is a leaf with all 29 pins of the leaf I/F connected to the pin headers. …","ref":"/en/docs/leaf/extension/ax08/","title":"AX08 29pin header"},{"body":"  \n特徴 リーフI/Fの29ピン全てをピンヘッダに接続したリーフです。\n性能    Item Description     Dimension  W30×D20.5×H10.6mm     ピン配置 \nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2020年1月:初版  前のページに戻る\r","excerpt":"  \n特徴 リーフI/Fの29ピン全てをピンヘッダに接続したリーフです。\n性能    Item Description     Dimension  W30×D20.5×H10.6mm     ピン配 …","ref":"/docs/leaf/extension/ax08/","title":"AX08 29pin header"},{"body":"  \nFeatures This is a leaf with all 29 pins of the leaf I/F connected to a through-hole.\nSpecification    Item Description     Dimension  W ×D ×H mm    Pinassignment \nDocument  PCBLayout(KiCad) 1  Back to previous page\r  We have prepared data for KiCad, which is widely used by individuals, but since it was created by converting Zuken\u0026rsquo;s CAD data, we cannot eliminate the possibility of conversion errors. Please check the dimensions and other details carefully before use. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"Features This is a leaf with all 29 pins of the leaf I/F connected to a through-hole.\nSpecification …","ref":"/en/docs/leaf/extension/ax09/","title":"AX09 Terminal"},{"body":"  \n特徴 リーフI/Fの29ピン全てをスルーホールに接続したリーフです。\n性能    Item Description     Dimension  W ×D ×H mm    ピン配置 \nドキュメント  レイアウト図(KiCad)  変更履歴  年 月:初版  前のページに戻る\r","excerpt":"  \n特徴 リーフI/Fの29ピン全てをスルーホールに接続したリーフです。\n性能    Item Description     Dimension  W ×D ×H mm    ピン配置 \nドキュメ …","ref":"/docs/leaf/extension/ax09/","title":"AX09 Terminal"},{"body":"Overview An example of using Seeed Studio\u0026rsquo;s Grove series of sensors. The distance measured by the ultrasonic sensor is displayed on the LCD. Ultrasonic sensors are usually input to digital pins, but since LCD\u0026rsquo;s Switch1 and Grove\u0026amp;5V\u0026rsquo;s Din1 use the same pins, they are connected to UART pins and UART pins are used as digital pins.\n\r\rLeaf to use    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI04 LCD 1   AX04 Spacer 1   AX06 Grove\u0026amp;5V 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    Grove – Ultrasonic Distance Sensor 1    CR2032 coin cell battery 1    M2*18mm screw 2    Assembly Assemble the leaves as shown in the figure below.\nSource code  The LCD library and ultrasonic control library \u0026ldquo;Ultrasonic.h\u0026rdquo; are required for writing. Please include them beforehand. For more information, see here. Write the following program in the Arduino IDE.  //===================================================================== // Leafony Platform sample sketch // Platform : Grove + Ultrasonic // Processor : ATmega328P (3.3V /8MHz) // Application : Ultrasonic Ranger demo // // Leaf configuration // (1) AI04 LCD // (2) AP01 AVR MCU // (3) AX01 Grove\u0026amp;5V + Grove - Ultrasonic Ranger (UART pinに接続) // ※ Ultrasonic RangerはGrove\u0026amp;5VのUARTに接続する // (4) AZ01 USB // //\t(c) 2019 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //Grove - Ultrasonic Rangerを使用したデモ //LCDに超音波センサーから取得した対象物からの距離を表示 //===================================================================== //use libraries //ST7032 - Arduino LiquidCrystal compatible library //https://github.com/tomozh/arduino_ST7032 //Grove_Ultrasonic_Ranger //https://github.com/Seeed-Studio/Grove_Ultrasonic_Ranger/ //=====================================================================  #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ST7032.h\u0026gt; // LCD ST7032 lcd; char strMessage[8]; #include \u0026#34;Ultrasonic.h\u0026#34;Ultrasonic ultrasonic(A1); void setup() { Serial.begin(115200); //LCD Initialize  lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(1000); lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(500); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++) { lcd.setCursor(i, 0); delay(100); } for (i=0 ; i\u0026lt;8 ;i++) { lcd.setCursor(i, 1); delay(100); } lcd.noBlink(); } void loop() { long RangeInCentimeters; lcd.clear(); lcd.print(\u0026#34;Distance\u0026#34;); RangeInCentimeters = ultrasonic.MeasureInCentimeters(); sprintf(strMessage,\u0026#34;%5d cm\u0026#34;,RangeInCentimeters); lcd.setCursor(0, 1); lcd.print(strMessage); delay(250); } Grove-Ultrasonic_LCD.ino\nBack to previous page\r","excerpt":"Overview An example of using Seeed Studio\u0026rsquo;s Grove series of sensors. The distance measured by …","ref":"/en/docs/examples/advanced/1_p/exten/distance_sensor/","title":"Distance sensor"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/examples/beginner/2_p/exten/","title":"ESP32 Wi-Fi Kit + Extension Kit"},{"body":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。超音波センサで測定した距離をLCDに表示させます。超音波センサは、通常、デジタルピンに入力するが、LCDのスイッチ1とGrove\u0026amp;5VのDin1が同じピンを使用しているため、UARTピンに接続しUARTピンをデジタルピンとして使用します。\n\r\r使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI04 LCD 1   AX04 Spacer 1   AX06 Grove\u0026amp;5V 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    Grove – Ultrasonic Distance Sensor 1    CR2032 coin cell battery 1    M2*18mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード  書き込みには、LCDライブラリ、超音波制御 ライブラリ（ Ultrasonic.h ）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで下記のプログラムを書きましょう。  //===================================================================== // Leafony Platform sample sketch // Platform : Grove + Ultrasonic // Processor : ATmega328P (3.3V /8MHz) // Application : Ultrasonic Ranger demo // // Leaf configuration // (1) AI04 LCD // (2) AP01 AVR MCU // (3) AX01 Grove\u0026amp;5V + Grove - Ultrasonic Ranger (UART pinに接続) // ※ Ultrasonic RangerはGrove\u0026amp;5VのUARTに接続する // (4) AZ01 USB // //\t(c) 2021 LEAFONY SYSTEMS Co., Ltd //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== //Grove - Ultrasonic Rangerを使用したデモ //LCDに超音波センサーから取得した対象物からの距離を表示 //===================================================================== //use libraries //ST7032 - Arduino LiquidCrystal compatible library //https://github.com/tomozh/arduino_ST7032 //Grove_Ultrasonic_Ranger //https://github.com/Seeed-Studio/Grove_Ultrasonic_Ranger/ //=====================================================================  #include \u0026lt;Wire.h\u0026gt;#include \u0026lt;ST7032.h\u0026gt; // LCD ST7032 lcd; char strMessage[8]; #include \u0026#34;Ultrasonic.h\u0026#34;Ultrasonic ultrasonic(A1); void setup() { Serial.begin(115200); //LCD Initialize  lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(1000); lcd.begin(8, 2); lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(500); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++) { lcd.setCursor(i, 0); delay(100); } for (i=0 ; i\u0026lt;8 ;i++) { lcd.setCursor(i, 1); delay(100); } lcd.noBlink(); } void loop() { long RangeInCentimeters; lcd.clear(); lcd.print(\u0026#34;Distance\u0026#34;); RangeInCentimeters = ultrasonic.MeasureInCentimeters(); sprintf(strMessage,\u0026#34;%5d cm\u0026#34;,RangeInCentimeters); lcd.setCursor(0, 1); lcd.print(strMessage); delay(250); } Grove-Ultrasonic_LCD.ino\n前のページに戻る\r","excerpt":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。超音波センサで測定した距離をLCDに表示させます。超音波センサは、通常、デジタルピンに入力するが、LCDのスイッチ1 …","ref":"/docs/examples/advanced/1_p/exten/distance_sensor/","title":"超音波センサで距離測定"},{"body":"","excerpt":"","ref":"/docs/examples/beginner/2_p/exten/","title":"ESP32 Wi-Fi Kit + Extension Kit"},{"body":"\nFeatures The Leafony Platform is based on ACRs (Anisotropic Conductive Rubber), which is an insulating silicone rubber with metal or conductive elastomeric conductive elements arranged at a narrow pitch, which can be compressed to create an electrical connection.\nTips Installing and removing connectors Attach or remove the connector to the leaf board as shown below.\n\u0026ndash; Installation\n\u0026ndash; Dismantling\nDocument  Connector test results 3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features The Leafony Platform is based on ACRs (Anisotropic Conductive Rubber), which is an …","ref":"/en/docs/leaf/others/az61/","title":"AZ61 Connector"},{"body":"Other Leaves\u0026rsquo;List\nBack to previous page\r","excerpt":"Other Leaves\u0026rsquo;List\nBack to previous page\r","ref":"/en/docs/leaf/others/","title":"Others"},{"body":"  \nFeatures A leaf to connect when writing a sketch to an AVR MCU or using a serial monitor. FTDI\u0026rsquo;s FT232RQ is mounted as a USB-UART conversion IC. It converts from USB VBUS (5V) to 3.3V with a step-down power supply circuit and supplies VBUS and 3.3V to each leaf.\nSpecification Dimension    Item Description     Dimension  W23×D20.9×H4.7mm    USB-UART conversion    Item Description     Part Number FT232RQ   USB USB 2.0 Full Speed   Data transfer rates 300 baud to 3 Mbaud    Power Supply    Item Description     Part number XCL222B331ER-G   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 500mA   Protection circuit Over current protection / thermal shutdown/short-circuit protection    Block diagram \nPinassign \nTips About micro USB and LED \n   Item Description     micro USB It is used for writing a sketch to the MCU and serial monitoring by connecting a PC.This also converts USB’s VBUS(5V) to 3.3V by using step-down power circuit and provide VBUS and 3.3V to each leaf.   LED TX LED which controlled by FT232RQ. Blinks when program is written by UART TX communication.   LED RX LED which controlled by FT232RQ. Blinks when program is written by UART TX communication.    Document  Spec sheet Schematic Component marking PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"Features A leaf to connect when writing a sketch to an AVR MCU or using a serial monitor. …","ref":"/en/docs/leaf/others/az01/","title":"AZ01 USB"},{"body":"  \n特徴 AVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電源回路により3.3Vに変換し、各リーフにVBUSと3.3Vを供給します。\n性能 外形サイズ    Item Description     Dimension  W23×D20.9×H4.7mm    USB-UART変換    Item Description     Part Number FT232RQ   USB USB 2.0 Full Speed   Data transfer rates 300 baud to 3 Mbaud    電源    Item Description     Part number XCL222B331ER-G   Output voltage 3.3V±2%   Controlling method PWM/PFM Automatic switching control   Maximum output current 500mA   Protection circuit Over current protection / thermal shutdown/short-circuit protection    ブロック図 \nピン配置 \nTips micro USB、LEDについて \n   Item Description     micro USB It is used for writing a sketch to the MCU and serial monitoring by connecting a PC.This also converts USB’s VBUS(5V) to 3.3V by using step-down power circuit and provide VBUS and 3.3V to each leaf.   LED TX LED which controlled by FT232RQ. Blinks when program is written by UART TX communication.   LED RX LED which controlled by FT232RQ. Blinks when program is written by UART TX communication.    ドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2019年8月:初版 2022年2月:低電力強化のため47KΩをC129の上段に追加。ドキュメントは、回路図のみ変更。  前のページに戻る\r","excerpt":"特徴 AVR MCU へのスケッチ書き込みやシリアルモニタを使用する場合に接続するリーフです。USB-UART変換ICとしてFTDI製FT232RQを搭載しています。USBのVBUS(5V)から降圧電 …","ref":"/docs/leaf/others/az01/","title":"AZ01 USB"},{"body":"その他リーフ一覧\n前のページに戻る\r","excerpt":"その他リーフ一覧\n前のページに戻る\r","ref":"/docs/leaf/others/","title":"その他"},{"body":"Overview An example of using Seeed Studio\u0026rsquo;s Grove series sensors. Let\u0026rsquo;s try to save an image taken by the camera once a minute to a microSD card. \r\rLeaf to use    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ02 RTC\u0026amp;microSD 1   AX04 Spacer 1   AX06 Grove\u0026amp;5V 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    Grove-Serial Camera Kit 1    microSD card  1    M2*18mm screw 2    Assembly Source code  4-Sensors and AVR MCU library (timer interrupt) are required for writing. Please include the library beforehand. For details, see here. Write the following program in the Arduino IDE.  //===================================================================== // Leafony Platform sample sketch // Platform : Grove + Camera // Processor : ATmega328P (3.3V /8MHz) // Application : Camera // // Leaf configuration // (1) AP01 AVR MCU // (2) AX01 Grove\u0026amp;5V + Grove Serial Camera Kit // (3) AZ01 USB // (4) AZ02 RTC＆MicroSD // //\t(c) 2019 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2019/08/01 First release //===================================================================== //use libraries //=====================================================================  //===================================================================== // difinition //===================================================================== #include \u0026lt;MsTimer2.h\u0026gt;#include \u0026lt;SPI.h\u0026gt;#include \u0026lt;SD.h\u0026gt;#include \u0026lt;SoftwareSerial.h\u0026gt;#include \u0026lt;avr/wdt.h\u0026gt;#include \u0026lt;avr/sleep.h\u0026gt;#include \u0026lt;avr/power.h\u0026gt;//=====================================================================  #define DEBUG  //===================================================================== // SPI CLOCK // SDカードのSPI I/Fのクロック速度4Mでは動作しないので4M以下に設定すること //===================================================================== #define SD_CLCK 2500000  //===================================================================== // 撮影間隔（秒） // //===================================================================== #define SNAP_WAIT 60  //===================================================================== // IOピンの名前定義 // 接続するリーフに合わせて定義する //===================================================================== // -------------------------------------------- // PD port // digital 0: PD0 = PCRX (HW UART) // digital 1: PD1 = PCTX (HW UART) // digital 2: PD2 = INT0# // digital 3: PD3 = INT1# // digital 4: PD4 = RSV // digital 5: PD5 = RSV // digital 6: PD6 = RSV // digital 7: PD7 = RSV // -------------------------------------------- #define PCTX 0 #define PCRX 1 #define INT0 2 #define INT1 3 #define RSV_D4 4 #define RSV_D5 5 #define SD_EN 6 #define RSV_D7 7  // -------------------------------------------- // PB port // digital 8: PB0 = UART2_RX (software UART) /* not use */ // digital 9: PB1 = UART2_TX (software UART) /* not use */ // digital 10:PB2 = CS# // digital 11:PB3 = MOSI // digital 12:PB4 = MISO // digital 13:PB5 = SCK (AVR LED) // PB6 = XTAL1 // PB7 = XTAL2 //--------------------------------------------- #define UART2_RX 8 #define UART2_TX 9 #define SD_CS 10 #define MOSI 11 #define MISO 12 #define LED_PIN 13  // -------------------------------------------- // PC port // digital 14/ Analog0: PC0 = RSV // digital 15/ Analog1: PC1 = CAMERA TX (software UART) // digital 16/ Analog2: PC2 = CAMERA RX (software UART) // digital 17/ Analog3: PC3 = RSV // digital 18/ SDA : PC4 = SDA (I2C) // digital 19/ SCL : PC5 = SCL (I2C) // RESET : PC6 = RESET# //----------------------------------------------- #define RSV_D14 14 #define UART3_TX 15 #define UART3_RX 16 #define RSV_D17 17 #define SDA 18 #define SCL 19 //=====================================================================  //===================================================================== // camera //===================================================================== //Color Setting #define COLOR_2BIT_GRAY 0x01 #define COLOR_4BIT_GRAY 0x02 #define COLOR_8BIT_GRAY 0x03 #define COLOR_2BIT_COLOR 0x05 #define COLOR_4BIT_COLOR 0x06 #define COLOR_JPEG 0x07 //Preview Resolution #define PRE_RES_80_60 0x01 #define PRE_RES_160_120 0x03 //JPEG Resolution #define JPEG_RES_80_60 0x01 #define JPEG_RES_QQVGA 0x03 #define JPEG_RES_QVGA 0x05 #define JPEG_RES_VGA 0x07 //Get Setting #define GET_SNAPCHOT 0x01 #define GET_PRE_PIC 0x02 #define GET_PRE_JPEG 0x03 //Snapshot Setting #define COMPRESSED 0x00 #define UNCOMPRESSED 0x01 //data length #define PIC_PKT_LEN 128  //===================================================================== // SD //===================================================================== File myFile; SoftwareSerial CameraSerial(UART3_RX, UART3_TX); //===================================================================== // 変数定義 //===================================================================== unsigned long picTotalLen = 0; // picture length int picNameNum = 0; char fname[16]; //--------------------------- // interval Timer2 interrupt //--------------------------- volatile bool bInterval = false; volatile int intcnt = 0; //===================================================================== // setup //===================================================================== //----------------------------------------------- // port //----------------------------------------------- //===================================================================== // IOピンの入出力設定 // 接続するリーフに合わせて設定する //===================================================================== void setupPort(){ //---------------------  // PD port  //---------------------  // PD0 : digital 0 = RX  // PD1 : digital 1 = TX  pinMode(INT0, INPUT); // PD2 : digital 2 = INT0#  pinMode(INT1, INPUT); // PD3 : digital 3 = INT1#  pinMode(RSV_D4, OUTPUT); // PD4 : digital 4 = LED  digitalWrite(RSV_D4, LOW); pinMode(RSV_D5, OUTPUT); // PD5 : digital 5 = not used  digitalWrite(RSV_D5, LOW); pinMode(SD_EN, OUTPUT); // PD6 : digital 6 = BLE reset active-low  digitalWrite(SD_EN, HIGH); pinMode(RSV_D7, OUTPUT); // PD7 : digital 7 = BLE sleep  digitalWrite(RSV_D7, HIGH); //---------------------  // PB port  //---------------------  pinMode(UART2_RX, OUTPUT); // PB0 : digital 8 = software UART2  digitalWrite(UART2_RX, LOW); pinMode(UART2_TX, OUTPUT); // PB1 : digital 9 = software UART2  digitalWrite(UART2_TX, LOW); //---------------------  // PC port  //---------------------  pinMode(RSV_D14, OUTPUT); // PC0 : digital 14 = not used  digitalWrite(RSV_D14, LOW); // PC1 : digital 15 = Camera RX  // PC2 : digital 16 = Camera TX  pinMode(RSV_D17, OUTPUT); // PC3 : digital 17 = not used  digitalWrite(RSV_D17, LOW); // PC4 : digital 18 = I2C SDA  // PC5 : digital 19 = I2C SCL } //===================================================================== // 割り込み処理 // //===================================================================== //----------------------------------------------- // timer2 interrupt (interval=1000ms, int=overflow) // メインループのタイマー割り込み設定 //----------------------------------------------- void setupTC2Int(){ MsTimer2::set(1000, intTimer2);} //---------------------------------------------- // Timer2 INT // タイマー割り込み関数 //---------------------------------------------- void intTimer2(){ intcnt++; if (intcnt \u0026gt; SNAP_WAIT) { intcnt = 0; bInterval = true; } } //==================================================================== // camera //==================================================================== //---------------------------------------------- // clearReadBuf // カメラデータの受信バッファクリア //---------------------------------------------- void clearReadBuf() { while (CameraSerial.available()) { CameraSerial.read(); } } //---------------------------------------------- // sendCmd // カメラへのコマンド送信 //---------------------------------------------- void sendCmd(char cmd[], int cmd_len) { for (char i = 0; i \u0026lt; cmd_len; i++) CameraSerial.write(cmd[i]); } //---------------------------------------------- // readRespons // カメラからのデータ受信 //---------------------------------------------- int readRespons(char *dest, int len, unsigned int timeout) { int read_len = 0; unsigned long t = millis(); while (read_len \u0026lt; len) { while (CameraSerial.available()\u0026lt;1) { if ((millis() - t) \u0026gt; timeout) { //Serial.println(\u0026#34;timeout\u0026#34;);  return read_len; } } *(dest+read_len) = CameraSerial.read(); #ifdef DEBUG  //Serial.write(*(dest+read_len),); //debug #endif  read_len++; } return read_len; } //---------------------------------------------- // initialize // カメラとの通信確立 //---------------------------------------------- void initialize() { char cmd[] = {0xaa,0x0d,0x00,0x00,0x00,0x00} ; unsigned char resp[6]; Serial.print(\u0026#34;initializing camera...\u0026#34;); while (1) { sendCmd(cmd,6); if (readRespons((char *)resp, 6,1000) != 6) { Serial.print(\u0026#34;.\u0026#34;); continue; } if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x0d \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) { if (readRespons((char *)resp, 6, 500) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0d \u0026amp;\u0026amp; resp[2] == 0 \u0026amp;\u0026amp; resp[3] == 0 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } } cmd[1] = 0x0e; cmd[2] = 0x0d; sendCmd(cmd, 6); Serial.println(\u0026#34; done.\\r\\n\u0026#34;); } //---------------------------------------------- // preCapture // カメラの初期設定 //---------------------------------------------- void preCapture() { char cmd[] = { 0xaa, 0x01, 0x00, COLOR_JPEG, PRE_RES_80_60, JPEG_RES_VGA }; unsigned char resp[6]; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x01 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } } //---------------------------------------------- // Capture // カメラの撮影実施 //---------------------------------------------- void Capture() { char cmd[] = { 0xaa, 0x06 , 0x08, PIC_PKT_LEN \u0026amp; 0xff, (PIC_PKT_LEN\u0026gt;\u0026gt;8) \u0026amp; 0xff ,0}; unsigned char resp[6]; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x06 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } cmd[1] = 0x05; cmd[2] = 0; cmd[3] = 0; cmd[4] = 0; cmd[5] = 0; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x05 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } cmd[1] = 0x04; cmd[2] = GET_SNAPCHOT; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x04 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) { if (readRespons((char *)resp, 6, 1000) != 6) { continue; } if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0a \u0026amp;\u0026amp; resp[2] == 0x01) { picTotalLen = (resp[3]) | (resp[4] \u0026lt;\u0026lt; 8) | (resp[5] \u0026lt;\u0026lt; 16); //Serial.print(\u0026#34;picTotalLen:\u0026#34;);  //Serial.println(picTotalLen);  break; } } } } //---------------------------------------------- // GetData // カメラからデータを取得しSDに書き込む //---------------------------------------------- void GetData() { char cmd[] = { 0xaa, 0x0e , 0x00, 0x00, 0x00, 0x00 }; unsigned char pkt[PIC_PKT_LEN]; unsigned int pktCnt = (picTotalLen) / (PIC_PKT_LEN - 6); if ((picTotalLen % (PIC_PKT_LEN-6)) != 0) pktCnt += 1; set_filename(); if (SD.exists(fname)) { SD.remove(fname); } myFile = SD.open(fname, FILE_WRITE); if(!myFile){ Serial.println(\u0026#34;myFile open fail...\u0026#34;); } else{ Serial.print(\u0026#34;Saving \u0026#34;);Serial.print(fname); Serial.print(\u0026#34;..... \u0026#34;); for (unsigned int i = 0; i \u0026lt; pktCnt; i++) { cmd[4] = i \u0026amp; 0xff; cmd[5] = (i \u0026gt;\u0026gt; 8) \u0026amp; 0xff; int retry_cnt = 0; retry: delay(10); clearReadBuf(); sendCmd(cmd, 6); uint16_t cnt = readRespons((char *)pkt, PIC_PKT_LEN, 200); unsigned char sum = 0; for (int y = 0; y \u0026lt; cnt - 2; y++) { sum += pkt[y]; } if (sum != pkt[cnt-2]) { if (++retry_cnt \u0026lt; 100) goto retry; else break; } myFile.write((const uint8_t *)\u0026amp;pkt[4], cnt-6); //if (cnt != PIC_PKT_LEN) break;  } cmd[4] = 0xf0; cmd[5] = 0xf0; sendCmd(cmd, 6); } myFile.close(); Serial.println(\u0026#34;end!!\u0026#34;); } //---------------------------------------------- // set_filename // SDに書き込みファイ名を作成IMGxxxx.JPG //---------------------------------------------- void set_filename(){ sprintf(fname, \u0026#34;IMG%04d.JPG\u0026#34;, picNameNum); picNameNum ++; if( picNameNum \u0026gt; 100 ){ picNameNum = 0; // Overwrite  } } //==================================================================== // setup //==================================================================== void setup() { //WDT disable  wdt_disable(); //内部の各モジュールの電源OFF  //power_all_disable();  //power_timer0_enable();  //power_timer2_enable();  //power_spi_enable();  //power_usart0_enable();  delay(10); Serial.begin(115200); CameraSerial.begin(9600); #ifdef DEBUG  Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;setup start\u0026#34;); #endif  setupPort(); delay(10); setupTC2Int(); if (!SD.begin(SD_CLCK,SD_CS)) { Serial.print(\u0026#34;sd init failed\u0026#34;); return; } Serial.print(\u0026#34;sd init finish\\r\\n\u0026#34;); initialize(); delay(1); preCapture(); delay(1000); Capture(); GetData(); MsTimer2::start(); } //==================================================================== // loop //==================================================================== void loop() { if (bInterval == true) { bInterval = false; Capture(); GetData(); } } Grove-Camera_microSD.ino\nBack to previous page\r","excerpt":"Overview An example of using Seeed Studio\u0026rsquo;s Grove series sensors. Let\u0026rsquo;s try to save an …","ref":"/en/docs/examples/advanced/1_p/exten/camera/","title":"Camera"},{"body":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI02 SP\u0026amp;PIR 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n#define LEDC_CHANNEL_0 0 // use first channel of 16 channels (started from zero) #define LEDC_TIMER_13_BIT 13 // use 13 bit precission for LEDC timer #define LEDC_BASE_FREQ 5000 // use 5000 Hz as a LEDC base frequency  //------------------------------ // buzzer output = 13pin //------------------------------ #define BUZZER_OUT 13  const int NOTE_NONE = NOTE_MAX; // notes in the melody: int melody[] = { NOTE_C, NOTE_C, NOTE_G, NOTE_G, NOTE_A, NOTE_A, NOTE_G, NOTE_F, NOTE_F, NOTE_E, NOTE_E,NOTE_D,NOTE_D,NOTE_C }; int noteOctaves[] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }; // note durations: 4 = quarter note, 8 = eighth note, etc.: int noteDurations[] = { 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 2 }; //===================================================================== // setup //===================================================================== void setup() { ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); ledcAttachPin(BUZZER_OUT, LEDC_CHANNEL_0); // iterate over the notes of the melody:  for (int thisNote = 0; thisNote \u0026lt; 14; thisNote++) { // to calculate the note duration, take one second divided by the note type.  //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.  ledcWriteNote(LEDC_CHANNEL_0, (note_t)melody[thisNote], noteOctaves[thisNote]); // to distinguish the notes, set a minimum time between them.  // the note\u0026#39;s duration + 30% seems to work well:  int pauseBetweenNotes = 1000 / noteDurations[thisNote] * 1.30; delay(pauseBetweenNotes); // stop the tone playing:  ledcWriteTone(LEDC_CHANNEL_0, 0); delay(30); } } //===================================================================== // Main loop //===================================================================== void loop() { // no need to repeat the melody. } ESP32_toneMelody_Twinkle.ino\nExecution Results The melody sounds only once from the speakers.\nBack to previous page\r","excerpt":"Overview Use the piezoelectric loudspeaker in the SP\u0026amp;PIR Leaf to make the melody sound.\nLeaf to …","ref":"/en/docs/examples/beginner/2_p/exten/speaker/","title":"Speaker"},{"body":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。定点観測用カメラ。1分に一回カメラで撮影した画像をmicroSDカードに保存してみよう。 \r\r使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AZ02 RTC\u0026amp;microSD 1   AX04 Spacer 1   AX06 Grove\u0026amp;5V 1   AP01 AVR MCU 1   AZ01 USB 1   AV01 CR2032 1    CR2032 coin cell battery 1    Grove-Serial Camera Kit 1    microSD card 1    M2*18mm screw 2    リーフの組み立て ソースコード  書き込みには、4-Sensors、AVR MCUライブラリ（タイマ割り込み）が必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで下記のプログラムを書きましょう。  //===================================================================== // Leafony Platform sample sketch // Platform : Grove + Camera // Processor : ATmega328P (3.3V /8MHz) // Application : Camera // // Leaf configuration // (1) AP01 AVR MCU // (2) AX01 Grove\u0026amp;5V + Grove Serial Camera Kit // (3) AZ01 USB // (4) AZ02 RTC＆MicroSD // //\t(c) 2021 LEAFONY SYSTEMS Co., Ltd //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== //use libraries //=====================================================================  //===================================================================== // difinition //===================================================================== #include \u0026lt;MsTimer2.h\u0026gt;#include \u0026lt;SPI.h\u0026gt;#include \u0026lt;SD.h\u0026gt;#include \u0026lt;SoftwareSerial.h\u0026gt;#include \u0026lt;avr/wdt.h\u0026gt;#include \u0026lt;avr/sleep.h\u0026gt;#include \u0026lt;avr/power.h\u0026gt;//=====================================================================  #define DEBUG  //===================================================================== // SPI CLOCK // SDカードのSPI I/Fのクロック速度4Mでは動作しないので4M以下に設定すること //===================================================================== #define SD_CLCK 2500000  //===================================================================== // 撮影間隔（秒） // //===================================================================== #define SNAP_WAIT 60  //===================================================================== // IOピンの名前定義 // 接続するリーフに合わせて定義する //===================================================================== // -------------------------------------------- // PD port // digital 0: PD0 = PCRX (HW UART) // digital 1: PD1 = PCTX (HW UART) // digital 2: PD2 = INT0# // digital 3: PD3 = INT1# // digital 4: PD4 = RSV // digital 5: PD5 = RSV // digital 6: PD6 = RSV // digital 7: PD7 = RSV // -------------------------------------------- #define PCTX 0 #define PCRX 1 #define INT0 2 #define INT1 3 #define RSV_D4 4 #define RSV_D5 5 #define SD_EN 6 #define RSV_D7 7  // -------------------------------------------- // PB port // digital 8: PB0 = UART2_RX (software UART) /* not use */ // digital 9: PB1 = UART2_TX (software UART) /* not use */ // digital 10:PB2 = CS# // digital 11:PB3 = MOSI // digital 12:PB4 = MISO // digital 13:PB5 = SCK (AVR LED) // PB6 = XTAL1 // PB7 = XTAL2 //--------------------------------------------- #define UART2_RX 8 #define UART2_TX 9 #define SD_CS 10 #define MOSI 11 #define MISO 12 #define LED_PIN 13  // -------------------------------------------- // PC port // digital 14/ Analog0: PC0 = RSV // digital 15/ Analog1: PC1 = CAMERA TX (software UART) // digital 16/ Analog2: PC2 = CAMERA RX (software UART) // digital 17/ Analog3: PC3 = RSV // digital 18/ SDA : PC4 = SDA (I2C) // digital 19/ SCL : PC5 = SCL (I2C) // RESET : PC6 = RESET# //----------------------------------------------- #define RSV_D14 14 #define UART3_TX 15 #define UART3_RX 16 #define RSV_D17 17 #define SDA 18 #define SCL 19 //=====================================================================  //===================================================================== // camera //===================================================================== //Color Setting #define COLOR_2BIT_GRAY 0x01 #define COLOR_4BIT_GRAY 0x02 #define COLOR_8BIT_GRAY 0x03 #define COLOR_2BIT_COLOR 0x05 #define COLOR_4BIT_COLOR 0x06 #define COLOR_JPEG 0x07 //Preview Resolution #define PRE_RES_80_60 0x01 #define PRE_RES_160_120 0x03 //JPEG Resolution #define JPEG_RES_80_60 0x01 #define JPEG_RES_QQVGA 0x03 #define JPEG_RES_QVGA 0x05 #define JPEG_RES_VGA 0x07 //Get Setting #define GET_SNAPCHOT 0x01 #define GET_PRE_PIC 0x02 #define GET_PRE_JPEG 0x03 //Snapshot Setting #define COMPRESSED 0x00 #define UNCOMPRESSED 0x01 //data length #define PIC_PKT_LEN 128  //===================================================================== // SD //===================================================================== File myFile; SoftwareSerial CameraSerial(UART3_RX, UART3_TX); //===================================================================== // 変数定義 //===================================================================== unsigned long picTotalLen = 0; // picture length int picNameNum = 0; char fname[16]; //--------------------------- // interval Timer2 interrupt //--------------------------- volatile bool bInterval = false; volatile int intcnt = 0; //===================================================================== // setup //===================================================================== //----------------------------------------------- // port //----------------------------------------------- //===================================================================== // IOピンの入出力設定 // 接続するリーフに合わせて設定する //===================================================================== void setupPort(){ //---------------------  // PD port  //---------------------  // PD0 : digital 0 = RX  // PD1 : digital 1 = TX  pinMode(INT0, INPUT); // PD2 : digital 2 = INT0#  pinMode(INT1, INPUT); // PD3 : digital 3 = INT1#  pinMode(RSV_D4, OUTPUT); // PD4 : digital 4 = LED  digitalWrite(RSV_D4, LOW); pinMode(RSV_D5, OUTPUT); // PD5 : digital 5 = not used  digitalWrite(RSV_D5, LOW); pinMode(SD_EN, OUTPUT); // PD6 : digital 6 = BLE reset active-low  digitalWrite(SD_EN, HIGH); pinMode(RSV_D7, OUTPUT); // PD7 : digital 7 = BLE sleep  digitalWrite(RSV_D7, HIGH); //---------------------  // PB port  //---------------------  pinMode(UART2_RX, OUTPUT); // PB0 : digital 8 = software UART2  digitalWrite(UART2_RX, LOW); pinMode(UART2_TX, OUTPUT); // PB1 : digital 9 = software UART2  digitalWrite(UART2_TX, LOW); //---------------------  // PC port  //---------------------  pinMode(RSV_D14, OUTPUT); // PC0 : digital 14 = not used  digitalWrite(RSV_D14, LOW); // PC1 : digital 15 = Camera RX  // PC2 : digital 16 = Camera TX  pinMode(RSV_D17, OUTPUT); // PC3 : digital 17 = not used  digitalWrite(RSV_D17, LOW); // PC4 : digital 18 = I2C SDA  // PC5 : digital 19 = I2C SCL } //===================================================================== // 割り込み処理 // //===================================================================== //----------------------------------------------- // timer2 interrupt (interval=1000ms, int=overflow) // メインループのタイマー割り込み設定 //----------------------------------------------- void setupTC2Int(){ MsTimer2::set(1000, intTimer2);} //---------------------------------------------- // Timer2 INT // タイマー割り込み関数 //---------------------------------------------- void intTimer2(){ intcnt++; if (intcnt \u0026gt; SNAP_WAIT) { intcnt = 0; bInterval = true; } } //==================================================================== // camera //==================================================================== //---------------------------------------------- // clearReadBuf // カメラデータの受信バッファクリア //---------------------------------------------- void clearReadBuf() { while (CameraSerial.available()) { CameraSerial.read(); } } //---------------------------------------------- // sendCmd // カメラへのコマンド送信 //---------------------------------------------- void sendCmd(char cmd[], int cmd_len) { for (char i = 0; i \u0026lt; cmd_len; i++) CameraSerial.write(cmd[i]); } //---------------------------------------------- // readRespons // カメラからのデータ受信 //---------------------------------------------- int readRespons(char *dest, int len, unsigned int timeout) { int read_len = 0; unsigned long t = millis(); while (read_len \u0026lt; len) { while (CameraSerial.available()\u0026lt;1) { if ((millis() - t) \u0026gt; timeout) { //Serial.println(\u0026#34;timeout\u0026#34;);  return read_len; } } *(dest+read_len) = CameraSerial.read(); #ifdef DEBUG  //Serial.write(*(dest+read_len),); //debug #endif  read_len++; } return read_len; } //---------------------------------------------- // initialize // カメラとの通信確立 //---------------------------------------------- void initialize() { char cmd[] = {0xaa,0x0d,0x00,0x00,0x00,0x00} ; unsigned char resp[6]; Serial.print(\u0026#34;initializing camera...\u0026#34;); while (1) { sendCmd(cmd,6); if (readRespons((char *)resp, 6,1000) != 6) { Serial.print(\u0026#34;.\u0026#34;); continue; } if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x0d \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) { if (readRespons((char *)resp, 6, 500) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0d \u0026amp;\u0026amp; resp[2] == 0 \u0026amp;\u0026amp; resp[3] == 0 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } } cmd[1] = 0x0e; cmd[2] = 0x0d; sendCmd(cmd, 6); Serial.println(\u0026#34; done.\\r\\n\u0026#34;); } //---------------------------------------------- // preCapture // カメラの初期設定 //---------------------------------------------- void preCapture() { char cmd[] = { 0xaa, 0x01, 0x00, COLOR_JPEG, PRE_RES_80_60, JPEG_RES_VGA }; unsigned char resp[6]; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x01 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } } //---------------------------------------------- // Capture // カメラの撮影実施 //---------------------------------------------- void Capture() { char cmd[] = { 0xaa, 0x06 , 0x08, PIC_PKT_LEN \u0026amp; 0xff, (PIC_PKT_LEN\u0026gt;\u0026gt;8) \u0026amp; 0xff ,0}; unsigned char resp[6]; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x06 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } cmd[1] = 0x05; cmd[2] = 0; cmd[3] = 0; cmd[4] = 0; cmd[5] = 0; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x05 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) break; } cmd[1] = 0x04; cmd[2] = GET_SNAPCHOT; while (1) { clearReadBuf(); sendCmd(cmd, 6); if (readRespons((char *)resp, 6, 100) != 6) continue; if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0e \u0026amp;\u0026amp; resp[2] == 0x04 \u0026amp;\u0026amp; resp[4] == 0 \u0026amp;\u0026amp; resp[5] == 0) { if (readRespons((char *)resp, 6, 1000) != 6) { continue; } if (resp[0] == 0xaa \u0026amp;\u0026amp; resp[1] == 0x0a \u0026amp;\u0026amp; resp[2] == 0x01) { picTotalLen = (resp[3]) | (resp[4] \u0026lt;\u0026lt; 8) | (resp[5] \u0026lt;\u0026lt; 16); //Serial.print(\u0026#34;picTotalLen:\u0026#34;);  //Serial.println(picTotalLen);  break; } } } } //---------------------------------------------- // GetData // カメラからデータを取得しSDに書き込む //---------------------------------------------- void GetData() { char cmd[] = { 0xaa, 0x0e , 0x00, 0x00, 0x00, 0x00 }; unsigned char pkt[PIC_PKT_LEN]; unsigned int pktCnt = (picTotalLen) / (PIC_PKT_LEN - 6); if ((picTotalLen % (PIC_PKT_LEN-6)) != 0) pktCnt += 1; set_filename(); if (SD.exists(fname)) { SD.remove(fname); } myFile = SD.open(fname, FILE_WRITE); if(!myFile){ Serial.println(\u0026#34;myFile open fail...\u0026#34;); } else{ Serial.print(\u0026#34;Saving \u0026#34;);Serial.print(fname); Serial.print(\u0026#34;..... \u0026#34;); for (unsigned int i = 0; i \u0026lt; pktCnt; i++) { cmd[4] = i \u0026amp; 0xff; cmd[5] = (i \u0026gt;\u0026gt; 8) \u0026amp; 0xff; int retry_cnt = 0; retry: delay(10); clearReadBuf(); sendCmd(cmd, 6); uint16_t cnt = readRespons((char *)pkt, PIC_PKT_LEN, 200); unsigned char sum = 0; for (int y = 0; y \u0026lt; cnt - 2; y++) { sum += pkt[y]; } if (sum != pkt[cnt-2]) { if (++retry_cnt \u0026lt; 100) goto retry; else break; } myFile.write((const uint8_t *)\u0026amp;pkt[4], cnt-6); //if (cnt != PIC_PKT_LEN) break;  } cmd[4] = 0xf0; cmd[5] = 0xf0; sendCmd(cmd, 6); } myFile.close(); Serial.println(\u0026#34;end!!\u0026#34;); } //---------------------------------------------- // set_filename // SDに書き込みファイ名を作成IMGxxxx.JPG //---------------------------------------------- void set_filename(){ sprintf(fname, \u0026#34;IMG%04d.JPG\u0026#34;, picNameNum); picNameNum ++; if( picNameNum \u0026gt; 100 ){ picNameNum = 0; // Overwrite  } } //==================================================================== // setup //==================================================================== void setup() { //WDT disable  wdt_disable(); //内部の各モジュールの電源OFF  //power_all_disable();  //power_timer0_enable();  //power_timer2_enable();  //power_spi_enable();  //power_usart0_enable();  delay(10); Serial.begin(115200); CameraSerial.begin(9600); #ifdef DEBUG  Serial.println(\u0026#34;=========================================\u0026#34;); Serial.println(\u0026#34;setup start\u0026#34;); #endif  setupPort(); delay(10); setupTC2Int(); if (!SD.begin(SD_CLCK,SD_CS)) { Serial.print(\u0026#34;sd init failed\u0026#34;); return; } Serial.print(\u0026#34;sd init finish\\r\\n\u0026#34;); initialize(); delay(1); preCapture(); delay(1000); Capture(); GetData(); MsTimer2::start(); } //==================================================================== // loop //==================================================================== void loop() { if (bInterval == true) { bInterval = false; Capture(); GetData(); } } Grove-Camera_microSD.ino\n前のページに戻る\r","excerpt":"概要 Seeed Studio の Grove シリーズのセンサを利用した例。定点観測用カメラ。1分に一回カメラで撮影した画像をmicroSDカードに保存してみよう。 \r\r使用するリー …","ref":"/docs/examples/advanced/1_p/exten/camera/","title":"カメラの撮影"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI02 SP\u0026amp;PIR 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n#define LEDC_CHANNEL_0 0 // use first channel of 16 channels (started from zero) #define LEDC_TIMER_13_BIT 13 // use 13 bit precission for LEDC timer #define LEDC_BASE_FREQ 5000 // use 5000 Hz as a LEDC base frequency  //------------------------------ // buzzer output = 13pin //------------------------------ #define BUZZER_OUT 13  const int NOTE_NONE = NOTE_MAX; // notes in the melody: int melody[] = { NOTE_C, NOTE_C, NOTE_G, NOTE_G, NOTE_A, NOTE_A, NOTE_G, NOTE_F, NOTE_F, NOTE_E, NOTE_E,NOTE_D,NOTE_D,NOTE_C }; int noteOctaves[] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }; // note durations: 4 = quarter note, 8 = eighth note, etc.: int noteDurations[] = { 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 2 }; //===================================================================== // setup //===================================================================== void setup() { ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); ledcAttachPin(BUZZER_OUT, LEDC_CHANNEL_0); // iterate over the notes of the melody:  for (int thisNote = 0; thisNote \u0026lt; 14; thisNote++) { // to calculate the note duration, take one second divided by the note type.  //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.  ledcWriteNote(LEDC_CHANNEL_0, (note_t)melody[thisNote], noteOctaves[thisNote]); // to distinguish the notes, set a minimum time between them.  // the note\u0026#39;s duration + 30% seems to work well:  int pauseBetweenNotes = 1000 / noteDurations[thisNote] * 1.30; delay(pauseBetweenNotes); // stop the tone playing:  ledcWriteTone(LEDC_CHANNEL_0, 0); delay(30); } } //===================================================================== // Main loop //===================================================================== void loop() { // no need to repeat the melody. } ESP32_toneMelody_Twinkle.ino\n実行結果 スピーカーから一度だけメロディが鳴ります。\n前のページに戻る\r","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された圧電スピーカを使って、メロディーを鳴らしましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty …","ref":"/docs/examples/beginner/2_p/exten/speaker/","title":"スピーカ"},{"body":"\nFeatures The Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris.\nDimension \nDocument  3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"\nFeatures The Connector Cover protects the ACR (Anisotropic Conductive Rubber) from dust and debris. …","ref":"/en/docs/leaf/others/az62/","title":"AZ62 Connector Cover"},{"body":"  \nFeatures This leaf is equipped with NXP\u0026rsquo;s Real-Time Clock PCF8523TK and a microSD card slot. The RTC can output interrupts to the MCU with alarms and timers, while the microSD card is accessible via SPI.\nSpecification    Item Description     Part number PCF8523TK   Type Real-Time Clock (RTC) and calendar   Interrupt Alarm and timer   Quartz crystal unit FC-12M 32.768000kHz 7.0 +20.0-20.0   Interfaces I2C(Address: 0x68)   Dimension W23×D20.5×H4.7mm     Block diagram \nPinassign \nSample App  Real Time Clock microSD Card Camera  Library Libraries are available for this leaf. Please install and use the necessary libraries at Environment.\nDocument  Spec sheet Schematic Component marking  PCBLayout(Zuken) PCBLayout(dxf) 3D drawing  Revision history  Rev A1.0: First edition, January 2020  Back to previous page\r","excerpt":"Features This leaf is equipped with NXP\u0026rsquo;s Real-Time Clock PCF8523TK and a microSD card slot. …","ref":"/en/docs/leaf/others/az02/","title":"AZ02 RTC\u0026microSD"},{"body":"  \n特徴 NXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能です。microSDカードはSPIでアクセスします。\n性能　    Item Description     Part number PCF8523TK   Type Real-Time Clock (RTC) and calendar   Interrupt Alarm and timer   Quartz crystal unit FC-12M 32.768000kHz 7.0 +20.0-20.0   Interfaces I2C(Address: 0x68)   Dimension W23×D20.5×H4.7mm     ブロック図 \nピン配置 \nサンプルアプリ  リアルタイムクロック microSD カード カメラの撮影  ライブラリ 本リーフに対応したライブラリがあります。開発環境設定のページで必要なライブラリをインストールして利用して下さい\nドキュメント  仕様書 回路図 部品配置図 レイアウト図(Zuken) レイアウト図(dxf) 3D図面  変更履歴  2020年1月:初版  前のページに戻る\r","excerpt":"特徴 NXPのReal-Time Clock PCF8523TKおよびmicroSDカードスロットを搭載したリーフです。RTCはアラームやタイマによりMCUに割り込み信号を出力することが可能で …","ref":"/docs/leaf/others/az02/","title":"AZ02 RTC\u0026microSD"},{"body":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR Leaf, let\u0026rsquo;s create a system that makes a sound when a person approaches.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI02 SP\u0026amp;PIR 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n For beep sound  //===================================================================== // Leafony Platform sample sketch // Application : Human_Sensing (Beep) // Processor : ESP32-WROOM-32 (ESP32 Dev Module) // Arduino IDE : 1.8.13 // Arduino ESP32: 1.0.4 // // Leaf configuration // (1) AI02 SP\u0026amp;PIR // (2) AP02 ESP32 MCU // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2020/08/20 First release //===================================================================== //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C //----------------------------------------------- // IO pin name definition // Define it according to the leaf to be connected. //----------------------------------------------- #define PIR_INT 4 // D2 IO4 #define BUZZER_OUT 13 // D5 IO13 buzzer output  //------------------------------ // Tone setting //------------------------------ #define LEDC_CHANNEL_0 0 // use first channel of 16 channels (started from zero) #define LEDC_TIMER_13_BIT 13 // use 13 bit precission for LEDC timer #define LEDC_BASE_FREQ 5000 // use 5000 Hz as a LEDC base frequency  //----------------------------------------------- // Define constants to be used in the program //----------------------------------------------- #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; volatile int HumanDetected = 0; //===================================================================== // setup //===================================================================== void setup(){ // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication:  Wire.begin(); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); // Beep  ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); ledcAttachPin(BUZZER_OUT, LEDC_CHANNEL_0); // 人接近検知割り込み  attachInterrupt(PIR_INT,onHumanDetected , FALLING ); } //--------------------------------------------------------------------- // Interrupt setting //--------------------------------------------------------------------- //---------------------------------------------- // Function to be called when a person is detected //---------------------------------------------- void onHumanDetected(){ HumanDetected = 1; } //===================================================================== // Main loop //===================================================================== void loop(){ // Register read  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); // IR Sensor  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); // Sensor temperature  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); if (HumanDetected == 1){ // Human proximity detection  Serial.println(\u0026#34;Detect!\u0026#34;); // Beep  ledcWriteNote(LEDC_CHANNEL_0, NOTE_C, 5); int pauseBetweenNotes = 1000 / 4 * 1.30; delay(pauseBetweenNotes); // stop the tone  ledcWriteTone(LEDC_CHANNEL_0, 0); HumanDetected = 0; } delay(1000); } //===================================================================== double clacTemp(){ double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000){ val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else{ ret = (double)val * 0.0019837; } return ret + 25; } //===================================================================== double clacIR(){ double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ((val \u0026amp; 0x8000) == 0x8000){ val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else{ ret = (double)(val * 0.4578 ); } return ret; } //===================================================================== // I2C control function //===================================================================== //----------------------------------------------- // I2C Write 1 byte to the slave device //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- // I2C Read 1 byte from the slave device //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } //----------------------------------------------- // I2C Write multiple bytes to the slave device //----------------------------------------------- void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } //----------------------------------------------- // I2C Read multiple bytes from the slave device //----------------------------------------------- void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } ESP32_Human_Sensing.ino\nExecution Results It makes a sound when someone approaches.\nBack to previous page\r","excerpt":"Overview Using an infrared sensor IC (AKM AK9754AE) for close-range detection on the SP\u0026amp;PIR …","ref":"/en/docs/examples/beginner/2_p/exten/ir_sensor/","title":"IR sensor"},{"body":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI02 SP\u0026amp;PIR 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n ビープ音の場合  //===================================================================== // Leafony Platform sample sketch // Application : Human_Sensing (Beep) // Processor : ESP32-WROOM-32 (ESP32 Dev Module) // Arduino IDE : 1.8.13 // Arduino ESP32: 1.0.4 // // Leaf configuration // (1) AI02 SP\u0026amp;PIR // (2) AP02 ESP32 MCU // //\t(c) 2021 LEAFONY SYSTEMS Co., Ltd //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C //----------------------------------------------- // IO pin name definition // Define it according to the leaf to be connected. //----------------------------------------------- #define PIR_INT 4 // D2 IO4 #define BUZZER_OUT 13 // D5 IO13 buzzer output  //------------------------------ // Tone setting //------------------------------ #define LEDC_CHANNEL_0 0 // use first channel of 16 channels (started from zero) #define LEDC_TIMER_13_BIT 13 // use 13 bit precission for LEDC timer #define LEDC_BASE_FREQ 5000 // use 5000 Hz as a LEDC base frequency  //----------------------------------------------- // Define constants to be used in the program //----------------------------------------------- #define I2C_PIR_ADDR 0x65 #define I2C_SEND_BUF_LENGTH 10 #define I2C_RECV_BUF_LENGTH 10  unsigned char i2c_sendBuf[I2C_SEND_BUF_LENGTH]; unsigned char i2c_recvBuf[I2C_RECV_BUF_LENGTH]; double irData; double tempData; volatile int HumanDetected = 0; //===================================================================== // setup //===================================================================== void setup(){ // initialize serial communication at 115200 second per second:  Serial.begin(115200); // initialize i2c communication:  Wire.begin(); delay(100); //人感センサ設定  i2c_write_byte(I2C_PIR_ADDR, 0x20, 0xFF); //CNTL1 Resrt  i2c_write_byte(I2C_PIR_ADDR, 0x2A, 0xF2); //CNTL11 人感アルゴリズム有効/割り込み出力有効  i2c_write_byte(I2C_PIR_ADDR, 0x25, 0x0F); //CNTL6 センサゲイン205%(最大)  i2c_write_byte(I2C_PIR_ADDR, 0x2B, 0xFF); //CNTL12 Mode=1 start Meas(連続測定モード)  delay(1000); // Beep  ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); ledcAttachPin(BUZZER_OUT, LEDC_CHANNEL_0); // 人接近検知割り込み  attachInterrupt(PIR_INT,onHumanDetected , FALLING ); } //--------------------------------------------------------------------- // Interrupt setting //--------------------------------------------------------------------- //---------------------------------------------- // Function to be called when a person is detected //---------------------------------------------- void onHumanDetected(){ HumanDetected = 1; } //===================================================================== // Main loop //===================================================================== void loop(){ // Register read  i2c_read(I2C_PIR_ADDR, 0x04, 6, i2c_recvBuf); // IR Sensor  irData = clacIR(); Serial.print(\u0026#34;IR = \u0026#34;); Serial.print(irData,2); Serial.println(\u0026#34; pA\u0026#34;); // Sensor temperature  tempData = clacTemp(); Serial.print(\u0026#34;TSENS = \u0026#34;); Serial.print(tempData,2); Serial.println(\u0026#34; deg\u0026#34;); Serial.println(\u0026#34;===================================\u0026#34;); if (HumanDetected == 1){ // Human proximity detection  Serial.println(\u0026#34;Detect!\u0026#34;); // Beep  ledcWriteNote(LEDC_CHANNEL_0, NOTE_C, 5); int pauseBetweenNotes = 1000 / 4 * 1.30; delay(pauseBetweenNotes); // stop the tone  ledcWriteTone(LEDC_CHANNEL_0, 0); HumanDetected = 0; } delay(1000); } //===================================================================== double clacTemp(){ double ret; unsigned short val = (unsigned short)((i2c_recvBuf[4] \u0026lt;\u0026lt; 8) | i2c_recvBuf[3]); if ( (val \u0026amp; 0x8000) == 0x8000){ val = ~val + 1; ret = (double)((val) * 0.0019837 ) * -1; } else{ ret = (double)val * 0.0019837; } return ret + 25; } //===================================================================== double clacIR(){ double ret; unsigned short val = (unsigned short)((i2c_recvBuf[2] \u0026lt;\u0026lt; 8) | i2c_recvBuf[1]); if ((val \u0026amp; 0x8000) == 0x8000){ val = ~val + 1; ret = (double)(val * 0.4578 ) * -1; } else{ ret = (double)(val * 0.4578 ); } return ret; } //===================================================================== // I2C control function //===================================================================== //----------------------------------------------- // I2C Write 1 byte to the slave device //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- // I2C Read 1 byte from the slave device //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } //----------------------------------------------- // I2C Write multiple bytes to the slave device //----------------------------------------------- void i2c_write(int device_address, int reg_address, int lengrh, unsigned char* write_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); for (int i = 0; i \u0026lt; lengrh; i++){ Wire.write(write_byte[i]); } Wire.endTransmission(); } //----------------------------------------------- // I2C Read multiple bytes from the slave device //----------------------------------------------- void i2c_read(int device_address, int reg_address, int lengrh, unsigned char* read_byte){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, lengrh); for (int i = 0; i \u0026lt; lengrh; i++){ read_byte[i] = Wire.read(); } } ESP32_Human_Sensing.ino\n実行結果 人が近づくと音が鳴ります。\n前のページに戻る\r","excerpt":"概要 SP\u0026amp;PIRリーフに搭載された近距離検出用途の赤外線センサIC(AKM AK9754AE)を使って、人が近づいたら音が鳴るシステムを作りましょう。\n使用するリーフ 以下のリーフを使用しま …","ref":"/docs/examples/beginner/2_p/exten/ir_sensor/","title":"人感センサ"},{"body":"\nFeatures The Nut Plate is used to fix the leaf with a screw. Be careful not to use commercially available hex nuts as they may cause a short circuit by touching the electrodes on the board.\nDimnnsion \nDocument  3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"\nFeatures The Nut Plate is used to fix the leaf with a screw. Be careful not to use commercially …","ref":"/en/docs/leaf/others/az63/","title":"AZ63 Nut Plate"},{"body":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of rotation. You can also turn on the number of LEDs according to the ambient volume with the microphone.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI03 MIC\u0026amp;VR\u0026amp;LED 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\n//===================================================================== // ESP32 Sound level meter // // (c) 2020 Trillion-Node Study Group // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2020/08/20 First release //=====================================================================  // LED4-6:VR level display // LED1-3:MIC sound pressure level display  #define LED1 14 // D6 IO14 #define LED2 15 // D7 IO15 #define LED3 17 // D8 IO17 #define LED4 16 // D9 IO16 #define LED5 5 // D10 IO5 #define LED6 23 // D11 IO23 #define MIC 26 // A2 IO26 #define VR 39 // A3 IO39  unsigned int dataVR; unsigned int dataMic; //----------------------------------------------- // Get VR and MIC data //----------------------------------------------- void getSensorData(){ dataVR = analogRead(VR); dataMic = analogRead(MIC); Serial.println(\u0026#34;---------------------\u0026#34;); Serial.print(\u0026#34;MIC = \u0026#34;); Serial.println(dataMic,DEC); Serial.print(\u0026#34;VR = \u0026#34;); Serial.println(dataVR,DEC); } //----------------------------------------------- // Turn the LEDs on and off according to the VR and MIC values. //----------------------------------------------- void dispSensorData(){ if (dataVR \u0026lt; 1500){ digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 1500 \u0026amp;\u0026amp; dataVR \u0026lt; 2600){ digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 2600 \u0026amp;\u0026amp; dataVR \u0026lt; 3600){ digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else{ digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; 400){ digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= 400 \u0026amp;\u0026amp; dataMic \u0026lt; 600){ digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= 600 \u0026amp;\u0026amp; dataMic \u0026lt; 950){ digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else{ digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup(){ Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); // Startup test(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); } void loop() { getSensorData(); dispSensorData(); delay(100); } ESP32_Sound_Level_Meter.ino\nExecution Results When the volume is rotated, a number of LEDs will light up according to the amount of rotation. When the microphone is turned on, a number of LEDs will light up according to the ambient volume.\nBack to previous page\r","excerpt":"Overview As you rotate the volume, the number of LEDs light up in proportion to the amount of …","ref":"/en/docs/examples/beginner/2_p/exten/sound_level/","title":"Sound level meter"},{"body":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI03 MIC\u0026amp;VR\u0026amp;LED 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\n//===================================================================== // ESP32 Sound level meter // // (c) 2021 LEAFONY SYSTEMS Co., Ltd // Released under the MIT license // https://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //=====================================================================  // LED4-6:VR level display // LED1-3:MIC sound pressure level display  #define LED1 14 // D6 IO14 #define LED2 15 // D7 IO15 #define LED3 17 // D8 IO17 #define LED4 16 // D9 IO16 #define LED5 5 // D10 IO5 #define LED6 23 // D11 IO23 #define MIC 26 // A2 IO26 #define VR 39 // A3 IO39  unsigned int dataVR; unsigned int dataMic; //----------------------------------------------- // Get VR and MIC data //----------------------------------------------- void getSensorData(){ dataVR = analogRead(VR); dataMic = analogRead(MIC); Serial.println(\u0026#34;---------------------\u0026#34;); Serial.print(\u0026#34;MIC = \u0026#34;); Serial.println(dataMic,DEC); Serial.print(\u0026#34;VR = \u0026#34;); Serial.println(dataVR,DEC); } //----------------------------------------------- // Turn the LEDs on and off according to the VR and MIC values. //----------------------------------------------- void dispSensorData(){ if (dataVR \u0026lt; 1500){ digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); } else if (dataVR \u0026gt;= 1500 \u0026amp;\u0026amp; dataVR \u0026lt; 2600){ digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,HIGH); } else if (dataVR \u0026gt;= 2600 \u0026amp;\u0026amp; dataVR \u0026lt; 3600){ digitalWrite(LED4,LOW); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } else{ digitalWrite(LED4,HIGH); digitalWrite(LED5,HIGH); digitalWrite(LED6,HIGH); } if (dataMic \u0026lt; 400){ digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); } else if (dataMic \u0026gt;= 400 \u0026amp;\u0026amp; dataMic \u0026lt; 600){ digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,HIGH); } else if (dataMic \u0026gt;= 600 \u0026amp;\u0026amp; dataMic \u0026lt; 950){ digitalWrite(LED1,LOW); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } else{ digitalWrite(LED1,HIGH); digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); } } void setup(){ Serial.begin(115200); Serial.println(\u0026#34;start!!\u0026#34;); pinMode(LED1, OUTPUT); digitalWrite(LED1, LOW); pinMode(LED2, OUTPUT); digitalWrite(LED2, LOW); pinMode(LED3, OUTPUT); digitalWrite(LED3, LOW); pinMode(LED4, OUTPUT); digitalWrite(LED4, LOW); pinMode(LED5, OUTPUT); digitalWrite(LED5, LOW); pinMode(LED6, OUTPUT); digitalWrite(LED6, LOW); pinMode(MIC, INPUT); pinMode(VR, INPUT); // Startup test(LED)  digitalWrite(LED1,HIGH); delay(200); digitalWrite(LED2,HIGH); delay(200); digitalWrite(LED3,HIGH); delay(200); digitalWrite(LED4,HIGH); delay(200); digitalWrite(LED5,HIGH); delay(200); digitalWrite(LED6,HIGH); delay(200); digitalWrite(LED1,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(LED4,LOW); digitalWrite(LED5,LOW); digitalWrite(LED6,LOW); delay(200); } void loop() { getSensorData(); dispSensorData(); delay(100); } ESP32_Sound_Level_Meter.ino\n実行結果 ボリュームを回転させると回転量に応じた数のLEDが点灯します。マイクにより周囲の音量に応じた数のLEDが点灯します。\n前のページに戻る\r","excerpt":"概要 ボリュームを回転させると回転量に応じた数のLEDが点灯。また、マイクにより周囲の音量に応じた数のLEDを点灯させることが出来ます。\n使用するリーフ 以下のリーフを使用します\n   Type …","ref":"/docs/examples/beginner/2_p/exten/sound_level/","title":"サウンドレベルメータ"},{"body":"\nFeatures This is a case for the Basic Kit. It can be fixed to the wall with the magnets on the bottom.\nDimnnsion \nDocument  3D drawing  Revision history  Rev A1.0: First edition, August 2019  Back to previous page\r","excerpt":"\nFeatures This is a case for the Basic Kit. It can be fixed to the wall with the magnets on the …","ref":"/en/docs/leaf/others/az66/","title":"AZ66 Basic kit case"},{"body":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt also comes with two button switches and can be used as a controller.\nLeaf to use    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI04 LCD 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nSource code Write the following program in the Arduino IDE.\nIn order to make this sketch work, you need to install the libraries If you haven\u0026rsquo;t installed it yet, refer to Environment to install it.\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : ESP32-WROOM-32 (ESP32 Dev Module) // Arduino IDE : 1.8.13 // Arduino ESP32: 1.0.4 // // Leaf configuration // (1) AI04 LCD // (2) AP02 ESP32 MCU // //\t(c) 2020 Trillion-Node Study Group //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2020/08/20 First release //===================================================================== //use libraries //ST7032 - Arduino LiquidCrystal compatible library //https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IO pin name definition // Define it according to the leaf to be connected. //----------------------------------------------- #define SW1 4 // D2 IO4  //----------------------------------------------- // Define constants to be used in the program //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop() { char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C control function //===================================================================== //----------------------------------------------- // I2C Write 1 byte to the slave device //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- // I2C Read 1 byte from the slave device //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } ESP32_LCD-SW_test.ino\nExecution Results On the LCD the screens are displayed in the following order\n The \u0026ldquo;Hello\u0026rdquo; string Moving the cursor Button input status display  Back to previous page\r","excerpt":"Overview With an LCD (liquid crystal display) leaf, you can easily display strings on the screen.\nIt …","ref":"/en/docs/examples/beginner/2_p/exten/lcd/","title":"LCD"},{"body":"概要 LCD(液晶ディスプレイ)リーフを使用すると、文字列を簡単に画面に表示することができます。\nまた、ボタンスイッチが2個搭載されていて、コントローラとして使うこともできます。\n使用するリーフ    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AI04 LCD 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nソースコード Arduino IDEで下記のプログラムを書きましょう。\nこのスケッチを動かすためには、ライブラリのインストールが必要です。 まだインストールしていない場合は開発環境設定ページを参考にライブラリをインストールしてください。\n//===================================================================== // Leafony Platform sample sketch // Application : LCD SW test // Processor : ESP32-WROOM-32 (ESP32 Dev Module) // Arduino IDE : 1.8.13 // Arduino ESP32: 1.0.4 // // Leaf configuration // (1) AI04 LCD // (2) AP02 ESP32 MCU // //\t(c) 2021 LEAFONY SYSTEMS Co., Ltd //\tReleased under the MIT license //\thttps://opensource.org/licenses/MIT // // Rev.00 2021/04/01 First release //===================================================================== //use libraries //ST7032 - Arduino LiquidCrystal compatible library //https://github.com/tomozh/arduino_ST7032 //=====================================================================  //--------------------------------------------------------------------- // difinition //--------------------------------------------------------------------- #include \u0026lt;Wire.h\u0026gt; // I2C#include \u0026lt;ST7032.h\u0026gt; // LCD //----------------------------------------------- // IO pin name definition // Define it according to the leaf to be connected. //----------------------------------------------- #define SW1 4 // D2 IO4  //----------------------------------------------- // Define constants to be used in the program //----------------------------------------------- #define I2C_EXPANDER_ADDR 0x1A  //--------------------------------------------------------------------- // object //--------------------------------------------------------------------- //------------------------------ // LCD //------------------------------ ST7032 lcd; //==================================================================== // setup //==================================================================== void setup(){ pinMode(SW1, INPUT); //LCD SW1  Wire.begin(); // IO　Expander Initialize  i2c_write_byte(I2C_EXPANDER_ADDR, 0x03, 0xFE); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  //LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34; Hello!\u0026#34;); lcd.setCursor(0, 1); delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x00); // LCD Power off  delay(3000); i2c_write_byte(I2C_EXPANDER_ADDR, 0x01, 0x01); // LCD Power on  // LCD Initialize  lcd.begin(8, 2); // 8 characters, 2 lines  lcd.setContrast(30); lcd.clear(); lcd.print(\u0026#34;12345678\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;87654321\u0026#34;); delay(3000); lcd.clear(); lcd.blink(); int i; for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 0); delay(1000); } for (i=0 ; i\u0026lt;8 ;i++){ lcd.setCursor(i, 1); delay(1000); } lcd.noBlink(); } //==================================================================== // Main loop //==================================================================== void loop() { char val; // SW 1  val = digitalRead(SW1); lcd.setCursor(0, 0); if (val == 1) { lcd.print(\u0026#34;SW1 is H\u0026#34;); }else{ lcd.print(\u0026#34;SW1 is L\u0026#34;); } // SW 2  val = i2c_read_byte(I2C_EXPANDER_ADDR, 0x00); lcd.setCursor(0, 1); if ((val \u0026amp; 0x02) == 0x02) { lcd.print(\u0026#34;SW2 is H\u0026#34;); } else { lcd.print(\u0026#34;SW2 is L\u0026#34;); } delay(1000); } //===================================================================== // I2C control function //===================================================================== //----------------------------------------------- // I2C Write 1 byte to the slave device //----------------------------------------------- void i2c_write_byte(int device_address, int reg_address, int write_data){ Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.write(write_data); Wire.endTransmission(); } //----------------------------------------------- // I2C Read 1 byte from the slave device //----------------------------------------------- unsigned char i2c_read_byte(int device_address, int reg_address){ int read_data = 0; Wire.beginTransmission(device_address); Wire.write(reg_address); Wire.endTransmission(false); Wire.requestFrom(device_address, 1); read_data = Wire.read(); return read_data; } ESP32_LCD-SW_test.ino\n実行結果 LCDに下記の順で画面が表示されます。\n 「Hello」の文字列 カーソルの移動 ボタンの入力状態表示  前のページに戻る\r","excerpt":"概要 LCD(液晶ディスプレイ)リーフを使用すると、文字列を簡単に画面に表示することができます。\nまた、ボタンスイッチが2個搭載されていて、コントローラとして使うこともできます。\n使用するリー …","ref":"/docs/examples/beginner/2_p/exten/lcd/","title":"LCD"},{"body":"\n特徴 Leafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属の導電部材が、狭ピッチで配列されており、圧縮されることで電気的接続が実現できます。\nTips コネクタの取り付け・取り外し リーフ基板にコネクタを取り付ける、または、外す場合は下図のように行ってください。\n\u0026ndash; 取り付け\n\u0026ndash; 取り外し\nドキュメント  コネクタの試験結果 3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"\n特徴 Leafony Platformは、ACR (Anisotropic Conductive Rubber)を採用しています。ACRは、絶縁性シリコーンゴムに、金属の導電部材が、狭ピッチで配列さ …","ref":"/docs/leaf/others/az61/","title":"AZ61 Connector"},{"body":"\n特徴 Connector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n外形図 \nドキュメント  3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"\n特徴 Connector Coverは、ACR (Anisotropic Conductive Rubber)に付着するゴミを防御することが出来ます。\n外形図 \nドキュメント  3D …","ref":"/docs/leaf/others/az62/","title":"AZ62 Connector Cover"},{"body":"\n特徴 Nut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n外形図 \nドキュメント  3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"\n特徴 Nut Plateは、リーフをネジで固定する時に使用します。市販の六角ナットを用いると基板の電極に触れて、ショートをおこすことがあるので要注意。\n外形図 \nドキュメント  3D …","ref":"/docs/leaf/others/az63/","title":"AZ63 Nut Plate"},{"body":"\n特徴 Basic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\n外形図 \nドキュメント  3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","excerpt":"\n特徴 Basic Kitのケースです。底面に付いたマグネットで壁に固定することが可能です。\n外形図 \nドキュメント  3D図面  変更履歴  2019年8月:初版  前のページに戻る\r","ref":"/docs/leaf/others/az66/","title":"AZ66 Basic Kit Case"},{"body":"\n特徴 JST製SHピンコネクタが付き、単4電池ホルダです。2V～4.5Vリーフに繋げて使用できます。\n変更履歴  2022年1月:初版  前のページに戻る\r","excerpt":"\n特徴 JST製SHピンコネクタが付き、単4電池ホルダです。2V～4.5Vリーフに繋げて使用できます。\n変更履歴  2022年1月:初版  前のページに戻る\r","ref":"/docs/leaf/others/az67/","title":"AZ67 AAA battery holder"},{"body":"\n特徴 JST製SHコネクタが付き、18650(直径18mmｘ長さ65mm)電池ホルダです。2V～4.5Vリーフに繋げて使用できます。\n18650電池のご購入時の注意 ESP32 Kit 2の18650電池ホルダには、「保護回路なし」の18650電池を使用して下さい。「保護回路付き」の18650電池は、長さ65mmよりも若干長く、統一していないため、市販の電池ホルダが用意されていません。Leafonyは、電池リーフに電流制限が付いているため、「保護回路なし」を選択しています。「保護回路なし」の18650電池は、以下から購入することが出来ます。\n  Amazonで購入する\n  楽天で購入する\n  変更履歴  2022年1月:初版  前のページに戻る\r","excerpt":"\n特徴 JST製SHコネクタが付き、18650(直径18mmｘ長さ65mm)電池ホルダです。2V～4.5Vリーフに繋げて使用できます。\n18650電池のご購入時の注意 ESP32 Kit 2 …","ref":"/docs/leaf/others/az68/","title":"AZ68 18650 battery holder"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/examples/advanced/1_p/basic/","title":"Basic Kit"},{"body":"","excerpt":"","ref":"/docs/examples/advanced/1_p/basic/","title":"Basic Kit 2"},{"body":"in progress\nOverview Minimum configuration project for creating a Beacon.\nWhat to prepare Sample application code Leafony Configuration    Type Name Q\u0026rsquo;ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Assembly Back to previous page\r","excerpt":"in progress\nOverview Minimum configuration project for creating a Beacon.\nWhat to prepare Sample …","ref":"/en/docs/examples/advanced/1_p/basic/simple_ble_advertising/","title":"Simple BLE Advertising"},{"body":"このサンプルはBasic Kit スタートガイドで紹介したものと同様です。ソースコードを読みながら、動作を理解していきましょう。\nはじめに Leafonyは省電力で小型なIoTデバイスの開発を簡単に行えるように、それぞれのリーフが省電力な設計になっています。 バッテリで長時間動作するため、様々な場所に設置してセンサで定点観測を行うことも可能です。\nでは、センサで測定した温度や湿度、照度のようなデータはどのようにして集められるのでしょうか。 一般的にWi-FiやBluetooth、LoRaといった無線通信が用いられるでしょう。 Leafonyでは無線通信規格の中でも省電力なBluetoothを搭載したリーフが存在します。\nBasic Kitは省電力なセンサを複数搭載した4-Sensorリーフと、省電力なBluetooth規格であるBluetooth LE (以下、BLE)を搭載したBLEリーフを使った長時間バッテリ駆動のIoTセンサの開発を簡単に行えるキットです。\nそれでは、Leafonyが送るBLEを受信するためにはどうすれば良いでしょうか。 PCやスマホ・タブレットには色々な環境があります。Windowsが動くPC、MacOSが動くPC、Android、iPhoneなど、身近なものでも非常に沢山の環境が存在します。 これらの環境でBluetoothを使うためには、それぞれの環境に合わせたプログラミング言語で開発するのが普通です。PCであればC言語やPythonなどの言語を使って開発できますが、AndroidやiPhoneであれば、Android StudioやXcode等を使ってまた別のプログラミング言語でソフトを作る必要があります。\n多くの人が様々な環境で使うものを簡単に開発するにはどうすれば良いでしょうか。 今回のサンプルアプリでは一つの方法として、Bluetoothの通信を行いデータを画面に表示するためにWebブラウザを使うことにしました。\n使用する言語はHTMLとJava Scriptです。この2つの言語で記述したプログラムが、Webブラウザ上であればどの環境においても同様に動作します。\nポイント\r Web Bluetoothライブラリを使うと、Bluetooth接続するソフトをWebアプリで記述できる。 Webアプリであればブラウザが動く機器であれば同じソースコードが動く。 表やグラフ等のGUIはHTMLとCSSでラクラク開発  \r用意するもの  Leafony Basic Kit Windows1、 Mac2、 Linux3のどれかのPC (開発用) Android4、 iPhone5、 iPad5のスマートフォンまたはタブレット (テスト用 なくても良い) Google Chrome (バージョン70.0.3526.0以降) Arduino IDE  サンプルアプリのソースコード あらかじめどちらもダウンロードしてください。\n  Arduino スケッチ Arduino IDE 1.8.7、Arduino AVR Boards 1.6.23で動作検証済み。6\n  Web Bluetooth アプリ\n  Leafonyの構成 このサンプルでは下記のリーフ構成で試せます。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nピンアサイン 各リーフのピンアサインは下図を参考\n\n実行方法  Arduino IDEで4-Sensors_BLE.inoを書き込む。Arduino IDE 1.8.7、Arduino AVR Boards 1.6.23で動作検証済み。6 ダウンロードしたWeb Bluetooth アプリのindex.htmlをGoogle Chromeで開く。\nWebアプリの使い方の詳細はBasic Kit クイックスタートガイドを参考  データの送信 BLEでデータを送受信する方法を見てみましょう。\nLeafony側 4-Sensors_BLE.inoの1020行目付近でBluetoothで送信するテキストデータを生成しています。 このテキストを変えることで任意のデータを送信可能です。\nsendLen = sprintf(sendData, \u0026#34;%04s,%04s,%04s,%04s,%04s,%01s\\n\u0026#34;, temp, humid, light, tilt, battVolt, pips) 上記では\u0026lt;温度\u0026gt;,\u0026lt;湿度\u0026gt;,\u0026lt;照度\u0026gt;,\u0026lt;傾き\u0026gt;,\u0026lt;電池電圧\u0026gt;,\u0026lt;サイコロ\u0026gt;のようにカンマ区切りのデータを送信しています。\n実際にこのテキストデータを送信しているのは下記の部分です。(1085行目付近)\nble112.ble_cmd_gatt_server_send_characteristic_notification( 1, 0x000C, sendLen, (const uint8 *)sendData ); Webアプリ側 Webアプリ側ではleafony.jsにデータ受信時の処理が書かれています。\nleafony.jsの75行目の記述で、データを受信した時に呼び出される関数を指定します。 ここではhandleData()という関数が呼び出されます。\nchar.read.addEventListener( \u0026#39;characteristicvaluechanged\u0026#39;, handleData ); handleData()関数もleafony.jsに記述されています。\nBLEで受信したデータはevent.target.valueに含まれています。\n一旦dataという変数に値をコピーした後に、受信データをutf-8でデコードし、改行コード(\\r\\n)を取り除いてから、カンマ,で区切って配列にしています。\nこれらのデータはstateという変数に任意の名前をつけて保存しています。(state.tempやstate.humidなど)\nLeafony側で送るデータを変更した際は、handleData()関数を修正することでデコードすることが可能です。\n/** * Characteristicの値が変化した時に呼び出される関数 * @param {*} event */ function handleData( event ) { // 受信したデータの文字コードを変換して、カンマでデータを分けている  // このサンプルではLeafonyは  // 温度,湿度,傾き,電池の電圧  // のようにカンマ区切りのテキストを送信している。  let data = event.target.value; let decoder = new TextDecoder( \u0026#39;utf-8\u0026#39; ); data = decoder.decode( data ); data = data.replace( /\\r?\\n/g, \u0026#39;\u0026#39; ); data = data.split( \u0026#39;,\u0026#39; ); state.devn = deviceName; state.unin = uniqueName; state.temp = data[0]; state.humd = data[1]; state.illm = data[2]; state.tilt = data[3]; state.batt = data[4]; state.dice = data[5]; // ここで updateTable() が実行されている  onStateChangeCallback( state ); // 省略  } データの受信 Webアプリ側 Webアプリの画面で「LED+」「LED-」ボタンを押すと、LeafonyのLEDの点滅スピードを変えることができます。\nボタン押された時の処理はapp.jsの下記の部分に記述されています。\nbuttonLedPls.addEventListener ( \u0026#39;click\u0026#39;, function () { console.log( \u0026#39;LED Plus Button Clicked\u0026#39; ); leafony.sendCommand( \u0026#39;PLS\u0026#39; ); }); leafony.sendCommand( '文字列' );で任意の文字列をLeafonyに送信しています。\nLeafony側 Webアプリ側から送信された文字列をLeafonyが受信したとき、4-Sensors.inoのmy_evt_gatt_server_attribute_value()関数が呼び出されます。\nデコードされた文字列はrcv_dataという変数にコピーされ、その文字列の内容に応じた処理をしています。\nvoid my_evt_gatt_server_attribute_value( const struct ble_msg_gatt_server_attribute_value_evt_t *msg ) { uint16 attribute = (uint16)msg -\u0026gt; attribute; uint16 offset = 0; uint8 value_len = msg -\u0026gt; value.len; uint8 value_data[20]; String rcv_data; rcv_data = \u0026#34;\u0026#34;; for (uint8_t i = 0; i \u0026lt; value_len; i++) { rcv_data += (char)(msg -\u0026gt; value.data[i]); } // 中略  if( rcv_data.indexOf(\u0026#34;SND\u0026#34;) == 0 ){ bBLEsendData = true; iToggle = 8; } else if( rcv_data.indexOf(\u0026#34;STP\u0026#34;) == 0 ){ bBLEsendData = false; bLCDchange = true; lcd_view_sts = 1; } else if(rcv_data.indexOf(\u0026#34;PLS\u0026#34;) == 0){ if(iToggle \u0026lt; 16){ iToggle += 2; } } else if(rcv_data.indexOf(\u0026#34;MNS\u0026#34;) == 0){ if(iToggle \u0026gt; 2){ iToggle -= 2; } } } 上記の部分を修正することで簡単にデータの送受信を行うことができます。\n仕組み  PeripheralとCentral アドバタイズ GATT Characteristic  Webアプリ側 index.htmlとapp.jsとleafony.jsの3つのファイルで構成されています。\nindex.htmlはボタンや表の配置を行ったり、他2つのjavascriptのファイルを読み込むだけの単純なものです。\napp.jsはボタンが押されたときの処理などメインの処理が記述されています。\nleafony.jsはWeb Bluetoothを使ってLeafonyと接続するための具体的な処理がかかれています。\nWeb Bluetoothの注意点 2022年9月時点ではWeb Bluetoothは以下の点に注意しなければいけません。\n iPhoneのChromeでは動作しません。Bluefyという有料のアプリを使えば利用可能です。 Web Bluetoothの開発状況と対応ブラウザについてはimplementation-status.mdで確認できます。  参考 LeafonyとWeb Bluetoothでラクラク！クロスプラットフォームIoT開発入門\n前のページに戻る\r  Windows 10 version 1703以降 \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite以降 \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow以降 \u0026#x21a9;\u0026#xfe0e;\n iPhoneまたはiPadには Bluefyのアプリが必要です。iPhone、iPad版のChromeではWeb Bluetoothが実装されていないためです。 \u0026#x21a9;\u0026#xfe0e;\n 動作しない場合はArduino IDE 1.8.7、Arduino AVR Boards 1.6.23で書き込みを行ってください。古いバージョンのArduino IDEダウンロードとArduino AVR Boardsの変更方法については Arduino IDE のバージョン参照。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"このサンプルはBasic Kit スタートガイドで紹介したものと同様です。ソースコードを読みながら、動作を理解していきましょう。\nはじめに Leafonyは省電力で小型なIoTデバイスの開発を簡単に行 …","ref":"/docs/examples/advanced/1_p/basic/webbluetooth_iot/","title":"Web Bluetoothを使ったIoTアプリ入門"},{"body":"This sample is the same as the one introduced in Basic Kit Getting Started Guide. Let\u0026rsquo;s read the source code to understand how it works.\nIntroduction Leafony is designed to make it easy to develop small, power-saving IoT devices, and each leaf is designed to save power. Since it runs on battery for a long time, it can be placed in various locations to perform fixed-point observations with sensors.\nSo how can data such as temperature, humidity, and illumination measured by sensors be collected? In general, wireless communication such as Wi-Fi, Bluetooth, and LoRa is used. Leafony has a leaf equipped with Bluetooth, one of the most power-efficient wireless communication standards.\nThe Basic Kit is a kit that makes it easy to develop long battery-powered IoT sensors using the 4-Sensor Leaf, which is equipped with multiple power-saving sensors, and the BLE Leaf, which is equipped with Bluetooth LE (hereinafter referred to as BLE), a power-saving Bluetooth standard.\nSo what do we need to do in order to receive the BLE sent by Leafony? There are many different environments for PCs, smartphones, and tablets: PCs running Windows, PCs running MacOS, Android, iPhone, and so on. In order to use Bluetooth in these environments, it is normal to develop in a programming language tailored to each environment. For PC, you can develop using languages such as C and Python, but for Android and iPhone, you need to use Android Studio, Xcode, etc. to create software in yet another programming language.\nHow can we easily develop something that is used by many people in many different environments? In this sample application, one way to do this is to use a web browser to communicate via Bluetooth and display the data on the screen.\nThe languages used are HTML and Java Script. A program written in these two languages will work equally well in any environment on a web browser.\nPoints\r The Web Bluetooth library allows you to write software for Bluetooth connection in a web application. If it is a web application, the same source code will work on any device that runs a browser. GUIs such as tables and graphs can be easily developed using HTML and CSS.  \rWhat to prepare  Leafony Basic Kit Windows1, Mac2, or Linux3 PC (for development) Android4, iPhone5, iPad5 smartphone or tablet (does not have to be for testing) Google Chrome (Version 70.0.3526.0 or later) Arduino IDE  Sample app source code Please download both in advance.\n Arduino Sketch Web Bluetooth App  Leafony Configuration In this sample, you can try the following leaf configurations.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Assembly Let\u0026rsquo;s assemble leaves as shown in the figure below.\nPin assignment Refer to the figure below for the pin assignment of each leaf.\n\nExecution method  Write 4-Sensors_BLE.ino in Arduino IDE. Open the downloaded index.html of Web Bluetooth App with Google Chrome.\nFor details on how to use the web app, refer to the Basic Kit Getting Started Guide.  Sending data Let\u0026rsquo;s see how to send and receive data with BLE.\nLeafony side In 4-Sensors_BLE.ino, around lAny data can be sent by changing this text.ine 1020, we generate the text data to be sent via Bluetooth. Any data can be sent by changing this text.\nsendLen = sprintf(sendData, \u0026#34;%04s,%04s,%04s,%04s,%04s,%01s\\n\u0026#34;, temp, humid, light, tilt, battVolt, pips) In the above, comma-separated data like \u0026lt;temperature\u0026gt;,\u0026lt;humidity\u0026gt;,\u0026lt;illuminance\u0026gt;,\u0026lt;slope\u0026gt;,\u0026lt;battery voltage\u0026gt;,\u0026lt;dice\u0026gt; is sent.\nThe following is the part that actually sends this text data. (Around line 1085)\nble112.ble_cmd_gatt_server_send_characteristic_notification( 1, 0x000C, sendLen, (const uint8 *)sendData ); Web app side On the web app side, the process for receiving data is written in leafony.js.\nIn line 75 of leafony.js, we specify the function to be called when data is received. Here, the function handleData() is called.\nchar.read.addEventListener( \u0026#39;characteristicvaluechanged\u0026#39;, handleData ); The handleData() function is also described in leafony.js.\nThe data received by the BLE is contained in event.target.value.\nOnce the values are copied into the variable data, the received data is decoded in utf-8, the newline code (\\r\\n) is removed, and then the data is made into an array separated by commas ,.\nThese data are stored in a variable called state with an arbitrary name. (state.temp, state.humid, etc.)\nIf the data sent by the Leafony side is changed, it can be decoded by modifying the handleData() function.\n/** * Characteristicの値が変化した時に呼び出される関数 * @param {*} event */ function handleData( event ) { // 受信したデータの文字コードを変換して、カンマでデータを分けている  // このサンプルではLeafonyは  // 温度,湿度,傾き,電池の電圧  // のようにカンマ区切りのテキストを送信している。  let data = event.target.value; let decoder = new TextDecoder( \u0026#39;utf-8\u0026#39; ); data = decoder.decode( data ); data = data.replace( /\\r?\\n/g, \u0026#39;\u0026#39; ); data = data.split( \u0026#39;,\u0026#39; ); state.devn = deviceName; state.unin = uniqueName; state.temp = data[0]; state.humd = data[1]; state.illm = data[2]; state.tilt = data[3]; state.batt = data[4]; state.dice = data[5]; // ここで updateTable() が実行されている  onStateChangeCallback( state ); // 省略  } Receiving data Web app side By pressing the \u0026ldquo;LED+\u0026rdquo; and \u0026ldquo;LED-\u0026rdquo; buttons on the web app screen, you can change the blinking speed of Leafony\u0026rsquo;s LEDs. The process for when the buttons are pressed is described in the following part of app.js.\nbuttonLedPls.addEventListener ( \u0026#39;click\u0026#39;, function () { console.log( \u0026#39;LED Plus Button Clicked\u0026#39; ); leafony.sendCommand( \u0026#39;PLS\u0026#39; ); }); leafony.sendCommand( 'string' ); to send an arbitrary string to Leafony.\nLeafony side When Leafony receives a string sent from the web app side, the my_evt_gatt_server_attribute_value() function in 4-Sensors.ino will be called. The decoded string is copied to a variable named rcv_data and processed according to the content of the string.\nvoid my_evt_gatt_server_attribute_value( const struct ble_msg_gatt_server_attribute_value_evt_t *msg ) { uint16 attribute = (uint16)msg -\u0026gt; attribute; uint16 offset = 0; uint8 value_len = msg -\u0026gt; value.len; uint8 value_data[20]; String rcv_data; rcv_data = \u0026#34;\u0026#34;; for (uint8_t i = 0; i \u0026lt; value_len; i++) { rcv_data += (char)(msg -\u0026gt; value.data[i]); } // 中略  if( rcv_data.indexOf(\u0026#34;SND\u0026#34;) == 0 ){ bBLEsendData = true; iToggle = 8; } else if( rcv_data.indexOf(\u0026#34;STP\u0026#34;) == 0 ){ bBLEsendData = false; bLCDchange = true; lcd_view_sts = 1; } else if(rcv_data.indexOf(\u0026#34;PLS\u0026#34;) == 0){ if(iToggle \u0026lt; 16){ iToggle += 2; } } else if(rcv_data.indexOf(\u0026#34;MNS\u0026#34;) == 0){ if(iToggle \u0026gt; 2){ iToggle -= 2; } } } You can easily send and receive data by modifying the above sections.\nStructure  Peripheral and Central Advertisement GATT Characteristic  Web app side It consists of three files: index.html, app.js, and leafony.js.\nThe index.html is simple enough to place buttons and tables, and load two other javascript files.\napp.js contains the main processing, such as what happens when a button is pressed.\nleafony.js describes the specific process of connecting to Leafony using Web Bluetooth.\nNotes on Web Bluetooth As of June 2020, Web Bluetooth will need to take the following points into account.\n It does not work with Chrome on iPhone.It is available by using a paid application called WebBLE. The development status of Web Bluetooth and supported browsers can be found at implementation-status.md.  Reference https://qiita.com/s_nkg/items/bdb235388eaeb567b54d\nBack to previous page\r  Windows 10 version 1703 or later \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite or later \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow or later \u0026#x21a9;\u0026#xfe0e;\n For iPhone or iPad, WebBLE(paid) is required.This is because Web Bluetooth is not implemented in the iPhone and iPad versions of Chrome. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"This sample is the same as the one introduced in Basic Kit Getting Started Guide. Let\u0026rsquo;s read …","ref":"/en/docs/examples/advanced/1_p/basic/webbluetooth_iot/","title":"Web Bluetooth IoT"},{"body":"This sample app is a combination of the one introduced in the Basic Kit Web Bluetooth IoT and Motorleaf. Using Bluetooth, you can control the electric pump to turn on and off, water plants, and send sensor information to a smartphone or PC. For details, please refer to Web Bluetooth IoT in Basic Kit.\nWhat to prepare  STM32 MCU, BLE Sugar, 4-Sensors, CR2032, and USB A Windows1, Mac2, or Linux3 PC (for development) Android4, iPhone5, iPad5 smartphone or tablet Google Chrome (Version 70.0.3526.0 or later) Arduino IDE, STM32CubeProgrammer software V2.4.0  Sample app source code Please download both in advance.\n Arduino Sketching Web Bluetooth App  Leafony Configuration In this sample, you can try the following leaf configurations.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AI  Motor 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AZ01 USB 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Assembly Assemble the leaves as shown in the figure below.\nPin assignment Refer to the figure below for the pin assignment of each leaf.\n\nExecution result  Write Motor_BLE_demo.ino in Arduino IDE. Open the downloaded index.html of Web Bluetooth App with Google Chrome.\nFor details on how to use the web app, refer to the Basic Kit Getting Started Guide.  Back to previous page\r  Windows 10 version 1703 or later \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite or later \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow or later \u0026#x21a9;\u0026#xfe0e;\n For iPhone or iPad, WebBLE(paid) is required because Web Bluetooth is not implemented in Chrome for iPhone and iPad. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"This sample app is a combination of the one introduced in the Basic Kit Web Bluetooth IoT and …","ref":"/en/docs/examples/advanced/1_p/motor/motor_demo/","title":"Watering plants with a motor"},{"body":"This sample is an STM32 implementation of the one introduced in the Basic Kit Web Bluetooth IoT. The Web Bluetooth application uses the same one as the Basic Kit. For more details, please refer to Web Bluetooth IoT in Basic Kit.\nWhat to prepare  STM32 MCU, BLE Sugar, 4-Sensors, CR2032, USB Windows1, Mac2, or Linux3 PC (for development) Android4, iPhone5, iPad5 smartphone or tablet Google Chrome (version 70.0.3526.0 or later) Arduino IDE, STM32CubeProgrammer software V2.4.0  Sample app source code Please download both in advance.\n Arduino Sketching Web Bluetooth App  Leafony Configuration In this sample, you can try the following leaf configurations.\n   Type Name Q\u0026rsquo;ty     [AZ62]/en/docs/leaf/others/az62) Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Assembly Assemble the leaves as shown in the figure below.\nPin assignment Refer to the figure below for the pin assignment of each leaf.\n\nExecution method  Write STM32_4-Sensors_BLE.ino in Arduino IDE Open the downloaded index.html of Web Bluetooth App with Google Chrome.\nFor details on how to use the web app, refer to Basic Kit Getting Started Guide.  Back to previous page\r  Windows 10 version 1703 or later \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite or later \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow or later \u0026#x21a9;\u0026#xfe0e;\n For iPhone or iPad, WebBLE(paid) is required because Web Bluetooth is not implemented in Chrome for iPhone and iPad. This is because Web Bluetooth is not implemented in Chrome for iPhone and iPad. \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"This sample is an STM32 implementation of the one introduced in the Basic Kit Web Bluetooth IoT. The …","ref":"/en/docs/examples/advanced/3_p/stm32/stm32_webbluetooth_iot/","title":"Web Bluetooth IoT with STM32"},{"body":"公開予定\n概要 Beaconを作成するための最小構成プロジェクト\n用意するもの サンプルアプリのコード Leafonyの構成    Type Name Q\u0026rsquo;ty     AC02 BLE Sugar 1   AI01 4-Sensors 1   AP01 AVR MCU 1   AV01 CR2032 1   AZ01 USB 1   AZ62 Connector Cover 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Leafonyの組み立て 前のページに戻る\r","excerpt":"公開予定\n概要 Beaconを作成するための最小構成プロジェクト\n用意するもの サンプルアプリのコード Leafonyの構成    Type Name Q\u0026rsquo;ty     AC02 BLE …","ref":"/docs/examples/advanced/1_p/basic/simple_ble_advertising/","title":"Simple BLE Advertising"},{"body":"このサンプルはBasic KitのWeb Bluetoothを使ったIoTアプリ入門で紹介したものとMotorリーフを組み合わせたものです。Bluetoothを使って電動ポンプのオン/オフを制御し植木に水やりをしたり、スマートフォンやパソコンにセンサの情報を送信する事ができます。 詳細はBasic KitのWeb Bluetoothを使ったIoTアプリ入門をご覧ください。\n用意するもの  AVR MCU、BLE Sugar、4-Sensors、CR2032、USB Windows1、 Mac2、 Linux3のどれかのPC (開発用) Android4、 iPhone5、 iPad5のスマートフォンまたはタブレット Google Chrome (バージョン70.0.3526.0以降) Arduino IDE  サンプルアプリのソースコード あらかじめどちらもダウンロードしてください。\n Arduino スケッチ Web Bluetooth アプリ  Leafonyの構成 このサンプルでは下記のリーフ構成で試せます。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AIxx Motor 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AZ01 USB 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nピンアサイン 各リーフのピンアサインは下図を参考\n\n実行方法  Arduino IDEでMotor_BLE_demo.inoを書き込む ダウンロードしたWeb Bluetooth アプリのindex.htmlをGoogle Chromeで開く\nWebアプリの使い方の詳細はBasic Kit クイックスタートガイドを参考  前のページに戻る\r  Windows 10 version 1703以降 \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite以降 \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow以降 \u0026#x21a9;\u0026#xfe0e;\n iPhoneまたはiPadの場合は WebBLE(有料)が必要です。iPhone、iPad版のChromeではWeb Bluetoothが実装されていないためです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"このサンプルはBasic KitのWeb Bluetoothを使ったIoTアプリ入門で紹介したものとMotorリーフを組み合わせたものです。Bluetoothを使って電動ポンプのオン/オフを制御し植木 …","ref":"/docs/examples/advanced/1_p/motor/motor_demo/","title":"Motorを使って植木に水やり"},{"body":"Overview We will create an IoT environment sensor using Leafony Beacon1) and Raspberry Pi, and visualize the sensor data using Google Spreadsheet.\n Beacon is a facility for acquiring various information including location by receiving radio waves on the ground with a specific device. in the case of Bluetooth Beacon devices, a module equipped with sensors such as temperature and air pressure can be installed at any location to observe the environment of that location.  What to prepare  Leafony Basic Kit Raspberry Pi (3, 4, zero, etc.) PC or smartphone with browser access Arduino IDE  Sample app code  Github - Leafony/leafony-beacon  Preparing the Raspberry Pi  If you are new to Raspberry Pi, the Raspberry Pi 3 B+ Starter Kit (https://www.switch-science.com/catalog/3880/) is useful. The microSD containing the Raspbian OS image is included, but the display, keyboard, and mouse are not. The display, keyboard, and mouse are not included. The Raspberry Pi will be connected to the Internet via a wireless LAN. Please prepare this in advance as well.  Leafony Configuration    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Assembly Writing sketches  The BLE and 4-Sensors libraries are required for writing. Please include the libraries beforehand. See here for details. In the Arduino IDE, write the following sketch on the microcontroller board. ・leafony_beacon.ino We have confirmed that it works with Arduino IDE 1.8.9. If you get a write error, please check your IDE version.  Building the Raspberry Pi environment We will use a Raspberry Pi as the receiver for the BLE Beacon. In the sample code we will be using, we use Node.js to receive the BLE Beacon using noble. The received data is written to a Google spreadsheet via Google API.\nExecute the following script (6 items) to build the environment. https://github.com/Leafony/leafony-beacon/tree/master/spreadsheet-logger\nsudo apt update sudo apt upgrade sudo apt install -y bluetooth libbluetooth-dev libudev-dev git git clone https://github.com/Leafony/leafony-beacon cd leafony-beacon/spreadsheet-logger npm install Note: WARNING will be displayed, but please continue.\nGetting the Google Sheets API In order to manipulate Google Spreadsheets in Node.js, we need to obtain an API. First, in Step 1 of Node.js Quick Start below, click Enable the Google Sheets API, and download credentials.json. Next, copy the credentials.json to the leafony-beacon/spreadsheet-logger directory.\nNode.js Quickstart | Sheets API | Google Developers : https://developers.google.com/sheets/api/quickstart/nodejs\nSetting Google Sheets ID and sheet name to index.js Open the Google Spreadsheet and check the \u0026ldquo;Sheet ID\u0026rdquo; and \u0026ldquo;Sheet Name\u0026rdquo; in the red line of the URL.\nleafony-beacon/spreadsheet-loggerディレクトリ「index.js」があります。「index.js」の18, 19行目にある「spreadsheetId」と「sheetName」に、上記の「シートID」と「シート名」を貼り付けることで、データが書き込まれます。\nアプリの実行 Raspberry piのターミナルに「sudo node .」と入力してEnterをクリックしてください。\n上記URLにブラウザでアクセスすると、Googleアカウントに移動し、ご自身のアカウントを選択します。\n「詳細」をクリックしてください。\n「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。\n「詳細」をクリックしてください。\n「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。\n「許可」をクリックしてください。以下のコードをコピーしてください。ターミナル内に貼り付けると、「token.json」というファイルが生成されたあとに、beaconのスキャンが始まります。\nBeaconが見つかるとログが表示されると同時に、スプレッドシートに同じ内容が追記されるので、スプレッドシートを開いてデータを確認してください。\nBack to previous page\r","excerpt":"Overview We will create an IoT environment sensor using Leafony Beacon1) and Raspberry Pi, and …","ref":"/en/docs/examples/advanced/1_p/basic/google_sheets_iot/","title":"Google Sheets IoT"},{"body":"概要 Leafony Beacon1)とRaspberry Piとを使ってIoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\n Beaconとは、地上にある電波を特定の機器で受信することで、位置をはじめとした各種情報を取得するための設備です。BluetoothのBeacon機器の場合、温度や気圧などのセンサを搭載したモジュールを任意の場所に設置して、その場所の環境を観測します。  用意するもの  Leafony Basic Kit Raspberry Pi (3, 4, zero等) ブラウザが閲覧できるPCやスマホ Arduino IDE  サンプルアプリのコード  Github - Leafony/leafony-beacon  Raspberry Piの準備  Raspberry Pi 初めての方は、Raspberry Pi 3 B＋ スターターキット が便利です。Raspbian OSイメージを書き込んだmicroSDが入っていますが、ディスプレイ、キーボード、マウスは有りません。別途　ご用意してください。 Raspberry Pi は、無線LANでインターネットに接続します。こちらも事前にご用意してください。  Leafonyの構成    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    Leafonyの組み立て スケッチの書き込み  書き込みには、BLE、4-Sensorsライブラリが必要です。予め、ライブラリをインクルードしておいてください。詳しくは、こちら。 Arduino IDEで、以下のスケッチをマイコンボードに書き込んでください。 ・leafony_beacon.ino Arduino IDE 1.8.9で動作を確認しています。書き込みエラーが発生したら、IDEのバージョンを確認してください。  Raspberry Piの環境構築 BLE Beaconの受信機にはRaspberry Piを使います。今回使用するサンプルコードでは、Node.jsでnobleを使ってBLE Beaconを受信します。受信したデータはGoogle API経由でGoogle スプレッドシートに書き込んでいます。\n下記のスクリプト(6項目)を実行して環境構築をします。https://github.com/Leafony/leafony-beacon/tree/master/spreadsheet-logger\nsudo apt update sudo apt upgrade sudo apt install -y bluetooth libbluetooth-dev libudev-dev git git clone https://github.com/Leafony/leafony-beacon cd leafony-beacon/spreadsheet-logger npm install 注意:WARNINGと表示されますが、このまま進んでください。\nGoogle Sheets APIの取得 Google スプレットシートをNode.jsで操作するためにはAPIを取得する必要があります。まず、下記 Node.js Quick Start のStep.1で、 Enable the Google Sheets API をクリックし、credentials.jsonをダウンロードします。次に、credentials.jsonをleafony-beacon/spreadsheet-loggerディレクトリにコピーしてください。\nNode.js Quickstart | Sheets API | Google Developers : https://developers.google.com/sheets/api/quickstart/nodejs\nindex.js へGoogle SheetsのIDとシート名の設定 Google スプレッドシート を開いて、URLの赤線部分の「シートID」と「シート名」を確認します。\nleafony-beacon/spreadsheet-loggerディレクトリ「index.js」があります。「index.js」の18, 19行目にある「spreadsheetId」と「sheetName」に、上記の「シートID」と「シート名」を貼り付けることで、データが書き込まれます。\nアプリの実行 Raspberry piのターミナルに「sudo node .」と入力してEnterをクリックしてください。\n上記URLにブラウザでアクセスすると、Googleアカウントに移動し、ご自身のアカウントを選択します。\n「詳細」をクリックしてください。\n「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。\n「詳細」をクリックしてください。\n「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。\n「許可」をクリックしてください。以下のコードをコピーしてください。ターミナル内に貼り付けると、「token.json」というファイルが生成されたあとに、beaconのスキャンが始まります。\nBeaconが見つかるとログが表示されると同時に、スプレッドシートに同じ内容が追記されるので、スプレッドシートを開いてデータを確認してください。\n前のページに戻る\r","excerpt":"概要 Leafony Beacon1)とRaspberry Piとを使ってIoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\n Beaconとは、地上にある電 …","ref":"/docs/examples/advanced/1_p/basic/google_sheets_iot/","title":"Google SheetsをつかったIoTサービス入門"},{"body":"概要 このサンプルはGoogle SheetsをつかったIoTサービス入門で紹介したものと抵抗測定を組み合わせたものです。 Leafony で恒温槽内複数の被測定基板の抵抗と温度を測定してBeaconで送信しRaspberry Piを使ってGoogle スプレッドシートに測定データを保存します。\n用意するもの  Leafony Basic Kit ユニバーサル基板(回路は接続図参照) Raspberry Pi (3, 4等) ブラウザが閲覧できるPCやスマホ Arduino IDE  サンプルアプリのコード  Github - Leafony/  Raspberry Piの準備  Google SheetsをつかったIoTサービス入門 参照。  Leafonyの構成    Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AX02 29pin 2   AP01 AVR MCU 1   AC02 BLE Sugar 1   - M2*18mm screw 2    接続図 回路検討 被測定基板の抵抗値が約2.8Ωで3.0Ωに変化したことを検知したい。 簡単な回路で測定するのでプルアップ抵抗で分圧する方式とします。 測定する抵抗値とプルアップ抵抗を同じくらいの抵抗値にすると分解能が十分に取れますが、抵抗値が小さいため抵抗に流れる電流が大きくなります。そのため、測定する抵抗の10倍程度のプルアップ抵抗とします。 また、消費電流を減らし分解能を上げるため、プルアップする電源電圧を小さくします。AVR MCUリーフのADCのリファレンス電圧を外部から供給することを検討しましたが、うまく動作しなかったため、内部リファレンス(1.1V)を使用することとしました。プルアップする電源電圧も同じ1.1Vにします。\n前のページに戻る\r","excerpt":"概要 このサンプルはGoogle SheetsをつかったIoTサービス入門で紹介したものと抵抗測定を組み合わせたものです。 Leafony で恒温槽内複数の被測定基板の抵抗と温度を測定してBeacon …","ref":"/docs/examples/advanced/1_p/basic/resistance_measurement/","title":"自動測定監視システム(抵抗と温度を測定してGoogle Sheetsに保存)"},{"body":"このサンプルはWeb Bluetoothを使ったIoTアプリ入門で紹介したものと歪センサーを組み合わせたものです。Bluetoothを使って体重をスマートフォンやパソコンに表示する事ができます。\n用意するもの  AVR MCU、BLE Sugar、29pin、CR2032、USB 歪センサー(3線式で50kg/個程度測定できるもの)x4個 HX711基板(ライブラリHX711_ADCが必要です) Windows1、 Mac2、 Linux3いずれかのPC、Android4、 iPhone5、 iPad5のスマートフォンまたはタブレット Google Chrome (バージョン70.0.3526.0以降) Arduino IDE  サンプルアプリのソースコード あらかじめどちらもダウンロードしてください。\n Arduino スケッチ Web Bluetooth アプリ  Leafonyの構成 このサンプルでは下記のリーフ構成で試せます。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AX02 29pin 1   AP01 AVR MCU 1   AC02 BLE Sugar 1   AZ01 USB 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    接続図 実行方法  ライブラリHX711_ADCをダウンロードしてインストールします Arduino IDEのスケッチ例からCalibration.ino開き実行しキャリブレーションします キャリブレーションした値を記録しておき、Arduino IDEでBathroomScales_BLE.inoを開きます 値録したキャリブレーション値を128行のnewCalibrationValueに設定し書き込みます 体重計の上には何も置かずに起動します ダウンロードしたWeb Bluetooth アプリのindex.htmlをGoogle Chromeで開きます\nWebアプリの使い方の詳細はBasic Kit クイックスタートガイドを参考にしてください  前のページに戻る\r  Windows 10 version 1703以降 \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite以降 \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow以降 \u0026#x21a9;\u0026#xfe0e;\n iPhoneまたはiPadの場合は WebBLE(有料)が必要です。iPhone、iPad版のChromeではWeb Bluetoothが実装されていないためです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"このサンプルはWeb Bluetoothを使ったIoTアプリ入門で紹介したものと歪センサーを組み合わせたものです。Bluetoothを使って体重をスマートフォンやパソコンに表示する事ができます。\n用意 …","ref":"/docs/examples/advanced/1_p/basic/bathroom_scales/","title":"体重計"},{"body":"Back to previous page\r","excerpt":"Back to previous page\r","ref":"/en/docs/examples/advanced/1_p/exten/","title":"Basic Kit + Extension Kit"},{"body":"","excerpt":"","ref":"/docs/examples/advanced/1_p/exten/","title":"Basic Kit 2 + Extension Kit"},{"body":"These are sample applications using AVR MCUs.\nBack to previous page\r","excerpt":"These are sample applications using AVR MCUs.\nBack to previous page\r","ref":"/en/docs/examples/beginner/1_p/","title":"AVR MCU Examples"},{"body":"AVR MCUを使ったサンプルアプリです。\n前のページに戻る\r","excerpt":"AVR MCUを使ったサンプルアプリです。\n前のページに戻る\r","ref":"/docs/examples/beginner/1_p/","title":"AVR MCU Examples"},{"body":"These are sample applications using AVR MCUs.\nBack to previous page\r","excerpt":"These are sample applications using AVR MCUs.\nBack to previous page\r","ref":"/en/docs/examples/advanced/1_p/","title":"AVR MCU Examples"},{"body":"AVR MCUを使ったサンプルアプリです。\n前のページに戻る\r","excerpt":"AVR MCUを使ったサンプルアプリです。\n前のページに戻る\r","ref":"/docs/examples/advanced/1_p/","title":"AVR MCU Examples"},{"body":"These are sample applications using ESP32 MCUs.\nBack to previous page\r","excerpt":"These are sample applications using ESP32 MCUs.\nBack to previous page\r","ref":"/en/docs/examples/beginner/2_p/","title":"ESP32 MCU Examples"},{"body":"ESP32 MCUを使ったサンプルアプリです。\n前のページに戻る\r","excerpt":"ESP32 MCUを使ったサンプルアプリです。\n前のページに戻る\r","ref":"/docs/examples/beginner/2_p/","title":"ESP32 MCU Examples"},{"body":"These are sample applications using ESP32 MCUs.\nBack to previous page\r","excerpt":"These are sample applications using ESP32 MCUs.\nBack to previous page\r","ref":"/en/docs/examples/advanced/2_p/","title":"ESP32 MCU Examples"},{"body":"ESP32 MCUを使ったサンプルアプリです。\n前のページに戻る\r","excerpt":"ESP32 MCUを使ったサンプルアプリです。\n前のページに戻る\r","ref":"/docs/examples/advanced/2_p/","title":"ESP32 MCU Examples"},{"body":"These are sample applications using STM32 MCUs.\nBack to previous page\r","excerpt":"These are sample applications using STM32 MCUs.\nBack to previous page\r","ref":"/en/docs/examples/advanced/3_p/","title":"STM32 MCU Examples"},{"body":"These are sample applications using STM32 MCUs.\nBack to previous page\r","excerpt":"These are sample applications using STM32 MCUs.\nBack to previous page\r","ref":"/en/docs/examples/beginner/3_p/","title":"STM32 MCU Examples"},{"body":"STM32 MCUを使ったサンプルアプリです。\n前のページに戻る\r","excerpt":"STM32 MCUを使ったサンプルアプリです。\n前のページに戻る\r","ref":"/docs/examples/advanced/3_p/","title":"STM32 MCU Examples"},{"body":"STM32 MCUを使ったサンプルアプリです。\n前のページに戻る\r","excerpt":"STM32 MCUを使ったサンプルアプリです。\n前のページに戻る\r","ref":"/docs/examples/beginner/3_p/","title":"STM32 MCU Examples"},{"body":"This is a sample app using LoRa.\nBack to previous page\r","excerpt":"This is a sample app using LoRa.\nBack to previous page\r","ref":"/en/docs/examples/advanced/1_p/lora/","title":"Basic Kit + LoRa"},{"body":"LoRaリーフを使ったサンプルアプリです。\n前のページに戻る\r","excerpt":"LoRaリーフを使ったサンプルアプリです。\n前のページに戻る\r","ref":"/docs/examples/advanced/1_p/lora/","title":"Basic Kit 2 + LoRa"},{"body":"電源が入らない Leafonyの電源が入らない場合は、以下の項目をチェックしてください。\n 電池の残量が十分にあるか。 ボタン電池の入れる向きは正しいか。 電源スイッチがONになっているか。 コネクタが汚れていないか。汚れていたら、無水エタノールを含ませた紙製ウエスで軽く拭いてください。それでも改善しない場合は、コネクタを交換してください。詳しくは、こちら。 ネジの締めは問題ないか。緩みがあるならば、ネジを交互に締めてください。\n  シリアルポートが見つからない Leafonyのシリアルポートが見つからない場合は、以下の項目をチェックしてください。\n  USBシリアル変換IC(FT232)のドライバがインストールされていないと、シリアルポートは見つかりません。最新のMac OSの場合は、問題ありませんが、Windowsの場合、自動インストールされないことがあります。インストールの仕方は、以下のFTDI社のマニュアル等を参照して下さい。\n VCP Drivers\n Installation Guides WindowsパソコンにFTDI社製USBシリアルドライバを手動インストールする手順    USB2芯 電源ケーブルは、使用出来ません。\n  前のページに戻る\r","excerpt":"電源が入らない Leafonyの電源が入らない場合は、以下の項目をチェックしてください。\n 電池の残量が十分にあるか。 ボタン電池の入れる向きは正しいか。 電源スイッチがONになっているか。 コネクタ …","ref":"/docs/getting-started/solution/","title":"困ったときには"},{"body":"This is a sample app using Motor leaf.\nBack to previous page\r","excerpt":"This is a sample app using Motor leaf.\nBack to previous page\r","ref":"/en/docs/examples/advanced/1_p/motor/","title":"Basic Kit + Motor"},{"body":"Motorリーフを使ったサンプルアプリです。\n前のページに戻る\r","excerpt":"Motorリーフを使ったサンプルアプリです。\n前のページに戻る\r","ref":"/docs/examples/advanced/1_p/motor/","title":"Basic Kit 2 + Motor"},{"body":"ESP32 MCUリーフを使ったサンプルアプリです。\n","excerpt":"ESP32 MCUリーフを使ったサンプルアプリです。","ref":"/en/docs/examples/advanced/2_p/esp32/","title":"ESP32W-iFi Kit"},{"body":"STM32 MCUリーフを使ったサンプルアプリです。\n","excerpt":"STM32 MCUリーフを使ったサンプルアプリです。","ref":"/en/docs/examples/advanced/3_p/stm32/","title":"STM32"},{"body":"ESP32 MCUリーフを使ったサンプルアプリです。\n前のページに戻る\r","excerpt":"ESP32 MCUリーフを使ったサンプルアプリです。\n前のページに戻る\r","ref":"/docs/examples/advanced/2_p/esp32/","title":"ESP32 W-iFi Kit 2"},{"body":"STM32 MCUリーフを使ったサンプルアプリです。\n前のページに戻る\r","excerpt":"STM32 MCUリーフを使ったサンプルアプリです。\n前のページに戻る\r","ref":"/docs/examples/advanced/3_p/stm32/","title":"Basic Kit 2"},{"body":"このサンプルはBasic KitのWeb Bluetoothを使ったIoTアプリ入門で紹介したものをSTM32で実現したものです。Web Bluetooth アプリはBasic Kitと同じものを使用します。詳細はBasic KitのWeb Bluetoothを使ったIoTアプリ入門をご覧ください。\n用意するもの  STM32 MCU、BLE Sugar、4-Sensors、CR2032、USB Windows1、 Mac2、 Linux3のどれかのPC (開発用) Android4、 iPhone5、 iPad5のスマートフォンまたはタブレット Google Chrome (バージョン70.0.3526.0以降) Arduino IDE、STM32CubeProgrammer software V2.4.0  サンプルアプリのソースコード あらかじめどちらもダウンロードしてください。\n Arduino スケッチ Web Bluetooth アプリ  Leafonyの構成 このサンプルでは下記のリーフ構成で試せます。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 1   AI01 4-Sensors 1   AZ01 USB 1   AP03 STM32 MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    リーフの組み立て 下図のようにリーフを組み立てましょう。\nピンアサイン 各リーフのピンアサインは下図を参考\n\n実行方法  Arduino IDEでSTM32_4-Sensors_BLE.inoを書き込む ダウンロードしたWeb Bluetooth アプリのindex.htmlをGoogle Chromeで開く\nWebアプリの使い方の詳細はBasic Kit クイックスタートガイドを参考  前のページに戻る\r  Windows 10 version 1703以降 \u0026#x21a9;\u0026#xfe0e;\n OS X Yosemite以降 \u0026#x21a9;\u0026#xfe0e;\n Kernel 3.19+ and BlueZ 5.41+ installed. \u0026#x21a9;\u0026#xfe0e;\n Android 6.0 Marshmallow以降 \u0026#x21a9;\u0026#xfe0e;\n iPhoneまたはiPadの場合は WebBLE(有料)が必要です。iPhone、iPad版のChromeではWeb Bluetoothが実装されていないためです。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"このサンプルはBasic KitのWeb Bluetoothを使ったIoTアプリ入門で紹介したものをSTM32で実現したものです。Web Bluetooth アプリはBasic Kitと同じものを使用 …","ref":"/docs/examples/advanced/3_p/stm32/stm32_webbluetooth_iot/","title":"STM32で Web Bluetoothを使ったIoTアプリ入門"},{"body":"Overview Using only an ESP32 MCU leaf and 4-Sensors leaf, you can build an IoT environmental sensor and visualize the sensor data using Google Spreadsheet.\nPreparing Google Sheets Introducing an IoT service that displays sensor data sent by the ESP32 MCU Leaf in Google Sheets. You can check the data anywhere, if you have a PC or smartphone with browser access.\nFirst, let\u0026rsquo;s configure the settings for displaying data in Google Sheets as follows.  Sign in to your Google account and create a new spreadsheet. If you do not have an account, please create one.  \n You can change the title of Google Sheets (default: Untitled Spreadsheet) as you like. You can also change the sheet number (default: sheet 1) as you like also.\n  The symbol sequence in the red frame in the Google Sheets URL section below will be used later to specify the Google Sheet, so please copy it to an appropriate location.\n Here, 1o0cogc3aomAj58CRdMZARNJtoEmf8dB9ebY02jKV9tA.    \n Open the Script Editor from Tools and copy and paste the source code from Github.\n Leafony/Sample-Sketches/ESP32_GoogleSheets/google_scripts_code.js - GitHub    \nEnter the information of the Google Sheets that you just created in the following variables.  google_sheets_id：The symbol string of the URL of Google Sheets that you just copied. sheet_name：Name of the sheet to write to (default: Sheet 1)    \nThis section describes the procedure for publishing Google Sheets.\nClick Publish-\u0026gt;Deploy as a web application.  \nThen, change the access permissions to Anyone, even anonymous, so that anyone can view it.  \nClick the Deploy button to confirm the access permission from Script App to Google Sheets. Click Confirm Permissions.  \nClick on Details at the bottom left.  \nNext you will get a warning, click on Go to (insecure page).  \nFinally, allow the script to request access to the spreadsheet.  \nThe following pop-up window will appear, and a URL specific to the web app you have created will be issued, so copy the URL and click OK.  \n（App-specific URLs ）\nhttps://script.google.com/macros/s/AKfycbw-8Wx8Zf0alULuD3aLQdwnyVM8hSHAiDsrj49wA17ZqE7y-tP8/exec\rChecking the operation of Google Sheets   This time, we will try to write Datetime, UniqueID=Leafony_AP02-1, Temperature=100, Humidity=100, Illumination=100 in Google Sheets.\n  If you add ?UniqueID=Leafony_AP02-1\u0026amp;temperature=100\u0026amp;humidity=100\u0026amp;illumination=100 to the app-specific URL, you will get the following\n  https://script.google.com/macros/s/AKfycbw-8Wx8Zf0alULuD3aLQdwnyVM8hSHAiDsrj49wA17ZqE7y-tP8/exec?UniqueID=Leafony_AP02-1\u0026amp;temperature=100\u0026amp;humidity=100\u0026amp;illumination=100\r\nPaste the above URL into your browser and access it, and the data will be written to the configured Google Sheets.  The column names listed in the first line of Google Sheets are not automatically displayed, so please provide them in advance. \nIf there is a mistake in the script  Modify the script. Click Publish-\u0026gt;`Deploy as a web application``. If you deploy with the exact same settings as the first time, the modified code may not be reflected properly, so when you deploy again, set Project version to New and click Update. The URL of the web app running at that time can be found below.  \nNext ","excerpt":"Overview Using only an ESP32 MCU leaf and 4-Sensors leaf, you can build an IoT environmental sensor …","ref":"/en/docs/examples/advanced/2_p/esp32/esp32_googlesheets_1/","title":"Google Sheets with ESP32"},{"body":"IoT services using Google Sheets ESP32 configuration Assemble the leaves, write a sketch, and make sure the data is written to Google Sheets.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover  2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    Assembly Stack the ESP32 MCU leaf and the 4-Sensors leaf on top of each other and screw them together as shown below.\nSource code Write the program in the Arduino IDE.\n ESP32_GoogleSheets.ino  Note the following bullets in the Github source code, modify it, and write it to ESP32 leaf.\n Substitute the following constants for the information of the WiFi to be accessed.  const char* SSID = \u0026quot;wifi_ssid\u0026quot;; // WiFi SSID\rconst char* PASSWORD = \u0026quot;wifi_password\u0026quot;; // WiFi Password\rSubstitute the following constants for the web app information you just created.  From the app-specific URL：const char* KEY = AKfycbxbxoqWzuN8Eztplnhf3ywC-0QpWc8utkIY1QLngj4fHJFRvZKh    const char* KEY = \u0026quot;google_scripts_key\u0026quot;;\rIf you want to adjust the time interval for writing sensor data, substitute the following constants.  Units are in seconds.    uint64_t DEEP_SLEEP_TIME_SEC = 60;\r#include \u0026lt;Arduino.h\u0026gt;#include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTTPClient.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; // Unique ID String UniqueID = \u0026#34;Leafony_AP02\u0026#34;; // Connecting WiFi Settings const char* SSID = \u0026#34;wifi_ssid\u0026#34;; // WiFi SSID const char* PASSWORD = \u0026#34;wifi_password\u0026#34;; // WiFi Password // Accessed Google Script Settings const char* APP_SERVER = \u0026#34;script.google.com\u0026#34;; const char* KEY = \u0026#34;google_scripts_key\u0026#34;; // Device sleep time (sec) to reduce Joule heat uint64_t DEEP_SLEEP_TIME_SEC = 60; // 省略 Execution result Run Arduino and sequential sensor data will be written to Google Sheets.\n\n前のページに戻る ","excerpt":"IoT services using Google Sheets ESP32 configuration Assemble the leaves, write a sketch, and make …","ref":"/en/docs/examples/advanced/2_p/esp32/esp32_googlesheets_1/esp32_googlesheets_2/","title":" "},{"body":"Overview When shipped from the factory, Arduino sketches are written on the ESP32 MCU leaf, so the touch sensor values can be sent via Wi-Fi from a smartphone or PC, and the display will appear.\nLeaf to use Use the following leaves.\n   Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AX07 Back to back 1   AX08 29pin header 1   AZ62 Connector Cover  2   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*15mm screw 4    φ10x2mm magnet 1    Assembly Assemble the leaves as shown in the figure below.\nPin assignment Refer to the figure below for the pin assignment of each leaf.\n\nSource code The sketch to be used can be found in the GitHub repository below.\nLeafony/Sample-Sketches/ESP32_AP_Touch - GitHub\nExecution method  Insert the batteries into the AAA battery box and turn on the ESP32 leaf power switch. Connect to the following Wi-Fi with your PC or smartphone  SSID: Leafony_ESP32-AP Password: password   Launch a web browser on your PC or smartphone and go to http://192.168.4.1. Pins 7, 9, 22, 24, 26, and 28 of the 29-pin header are assigned to the touch sensor.\nWhen the pin is touched, the capacitance decreases and the value decreases. When the value falls below the threshold of 20, \u0026ldquo;Touch detected\u0026rdquo; is displayed.\n(Pin 24 is hidden in the sample sketch because it interferes with the RTC \u0026amp; microSD. The detection threshold can be changed in the sketch. In the following picture, I am touching pin 26 with my fingertip.)  When you touch pin 26, the browser display will change as shown below.　  Back to previous page\r","excerpt":"Overview When shipped from the factory, Arduino sketches are written on the ESP32 MCU leaf, so the …","ref":"/en/docs/examples/advanced/2_p/esp32/wifi_touchsensor/","title":"Wi-Fi touch sensor"},{"body":"概要 ESP32 MCUリーフと4-Sensorsリーフ（あるいはDHT-22センサ）だけで、IoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\nGoogle Sheetsの準備 ESP32 MCUリーフが送るセンサデータをGoogle Sheetsで表示する、IoTサービスを紹介します。 ブラウザを閲覧できるPCやスマホがあれば、どこでもデータを確認できます。\nまずは、Google Sheetsでデータを表示するための設定を以下の通り行いましょう。  Googleアカウントにログインし、新しいスプレッドシートを作成しましょう。アカウントがない場合は作成してください。  \nGoogle Sheetsのタイトル（デフォルト：無題のスプレッドシート）は自由に変更してください。\nまた、シート番号（デフォルト：シート1）も自由に変更して大丈夫です。  \n下のGoogle SheetsのURLの部分の赤枠で囲った記号列は、後でGoogle Sheetを指定するのに利用するので、適当な場所にコピーしておいてください。  ここでは、1ilM_Qz0A82_PueJtT-2PAzlnJ5ZSRB5OC_JkV4WQQCs になります。    \n\n拡張機能からApps Scriptを開き、Githubのソースコードをコピー\u0026amp;ペーストしてください。  function doGet(e) { let id = \u0026#39;google_sheets_id\u0026#39;; let sheetName = \u0026#39;sheet_name\u0026#39;; var result; // e.parameter has received GET parameters, i.e. temperature, humidity, illumination  if (e.parameter == undefined) { result = \u0026#39;Parameter undefined\u0026#39;; } else { var sheet = SpreadsheetApp.openById(id).getSheetByName(sheetName); var newRow = sheet.getLastRow() + 1; // get row number to be inserted  var rowData = []; // get current time  rowData[0] = new Date(); rowData[1] = e.parameter.UniqueID; rowData[2] = e.parameter.temperature; rowData[3] = e.parameter.humidity; rowData[4] = e.parameter.illumination; // 1 x rowData.length cells from (newRow, 1) cell are specified  var newRange = sheet.getRange(newRow, 1, 1, rowData.length); // insert data to the target cells  newRange.setValues([rowData]); result = \u0026#39;Ok\u0026#39;; } return ContentService.createTextOutput(result); } \n以下の変数に、先ほど作成したGoogle Sheetsの情報を入力してください。  google_sheets_id：先ほどコピーしたGoogle SheetsのURLの記号列 sheet_name：書き込み先のシート名（デフォルト：シート1）    \n\nGoogle Sheetsを公開する手順について、説明します。\n右上のデプロイから新しいデプロイをクリックし、タイプ（ここでは ウェブアプリ ）を選択します。  \n今回は「アクセスできるユーザー」を全員にし、誰でも閲覧できるようにしてから、デプロイをクリックします。  \nデータへのアクセスを許可するために、アクセスを承認をクリックしてください。  \nアカウントの選択で、該当する「アカウント」を選びます。  \n左下の詳細をクリックしてください。  \n次に警告が出るので、無題のプロジェクト（安全ではないページ）に移動 をクリックしてください。  \nスクリプトからスプレッドシートへのアクセスリクエストを許可してください。  \n以下のポップアップ画面が表示され、今回作成した「ウェブアプリ固有のURL」が発行されるので、URLをコピーして完了をクリックしてください。  \n（アプリ固有のURL）\nhttps://script.google.com/macros/s/AKfycbzaAHAO8oBBJ1alqfQAv4h76Q-7ugOLm47jATWiqDczu6vahAl3ZncxSh3tQVRuSVRk/exec\rGoogle Sheetsの動作確認   今回は試しに、Datetime、UniqueID=Leafony_AP02-1、Temperature=100、Humidity=100、Illumination=100 を、Google Sheetsに書き込んでみます。\n  アプリ固有のURLの末尾に、?UniqueID=Leafony_AP02-1\u0026amp;temperature=100\u0026amp;humidity=100\u0026amp;illumination=100を追加すると、以下の通りになります。\n  https://script.google.com/macros/s/AKfycbzaAHAO8oBBJ1alqfQAv4h76Q-7ugOLm47jATWiqDczu6vahAl3ZncxSh3tQVRuSVRk/exec?UniqueID=Leafony_AP02-1\u0026amp;temperature=100\u0026amp;humidity=100\u0026amp;illumination=100\r\n上記のURLをブラウザに貼り付けてアクセスすると(Enter)、設定したGoogle Sheetsにデータが書き込まれます。  Google Sheetsの1行目に記載されているカラム名は自動表示されないため、予めご記載ください。\n\n\nスクリプトのミスがあった場合  スクリプトを修正します。 デプロイを管理をクリックします。 最初と全く同じ設定でデプロイすると修正したコードがうまく反映されないことがあるので、再デプロイのときはデプロイを管理の設定から編集のアイコンをクリックして新バージョンで入力します。 またその時動作しているウェブアプリのURLは以下で確認出来ます。  \n次へ進む 前のページに戻る\r","excerpt":"概要 ESP32 MCUリーフと4-Sensorsリーフ（あるいはDHT-22センサ）だけで、IoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\nGoogle …","ref":"/docs/examples/advanced/2_p/esp32/esp32_googlesheets_1/","title":"Google Apps Scriptを使ったIoTサービス"},{"body":"Google Apps Scriptを使ったIoTサービス ESP32の設定 リーフを組み立ててスケッチを書き込み、データがGoogle Sheetsに書き込まれることを確認しましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name  Q\u0026rsquo;ty     AZ62 Connector Cover  コネクタカバー 2   AI01 4-Sensors 温度、湿度、照度、加速度センサを搭載したリーフ 1   [A\\](/docs/leaf/\\/\\) DHT-22センサ 温湿度センサモジュール 1   AX07 Back to back 背中合わせに接続するリーフ 1   AP02 ESP32 MCU Wi-FiとBluetooth LEを内蔵した32bit MCUリーフ 1   AV04 2V~4.5V JST製SHコネクタと昇降圧回路を搭載した2V～4.5Vのリーフ 1   AZ63 Nut Plate 固定金具 2    AAA battery holder 単4形 アルカリ乾電池ホルダー 1    AAA battery 単4形 アルカリ乾電池 3    M2*8mm screw M2×8ネジ 2    M2*12mm screw M2×12ネジ 2    φ10x2mm magnet φ10x2mmマグネット 1     4-Sensorsリーフを使用する場合は、DHT-22センサは不要 DHT-22センサを使用する場合は、4-Sensorsリーフは不要です。  リーフの組み立て   4-Sensorsリーフの場合   DHT-22センサの場合   \nESP32 MCUリーフと4-Sensorsリーフを重ねて、下図のようにねじ止めします。\nソースコード Arduino IDEでプログラムを書きましょう。\n  4-Sensorsリーフ用　ESP32_GoogleSheets_4-Sensors.ino\n  DHT-22センサ用　ESP32_GoogleSheets_DHT-22.ino ※要変更\n  Githubのソースコードの以下の箇条書きの内容に注意して修正し、ESP32リーフに書き込んで下さい。\n アクセスするWiFiの情報を以下の定数に代入してください。  const char* SSID = \u0026quot;wifi_ssid\u0026quot;; // WiFi SSID\rconst char* PASSWORD = \u0026quot;wifi_password\u0026quot;; // WiFi Password\r先ほど作成したウェブアプリの情報を以下の定数に代入してください。  アプリ固有のURLより：const char* KEY = AKfycbxbxoqWzuN8Eztplnhf3ywC-0QpWc8utkIY1QLngj4fHJFRvZKh    const char* KEY = \u0026quot;google_scripts_key\u0026quot;;\rセンサデータの書き込みの時間間隔を調整したいときは以下の定数に代入してください。  単位は秒です    uint64_t DEEP_SLEEP_TIME_SEC = 60;\r#include \u0026lt;Arduino.h\u0026gt;#include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTTPClient.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; // Unique ID String UniqueID = \u0026#34;Leafony_AP02\u0026#34;; // Connecting WiFi Settings const char* SSID = \u0026#34;wifi_ssid\u0026#34;; // WiFi SSID const char* PASSWORD = \u0026#34;wifi_password\u0026#34;; // WiFi Password // Accessed Google Script Settings const char* APP_SERVER = \u0026#34;script.google.com\u0026#34;; const char* KEY = \u0026#34;google_scripts_key\u0026#34;; // Device sleep time (sec) to reduce Joule heat uint64_t DEEP_SLEEP_TIME_SEC = 60; // 省略 実行結果 Arduinoを実行して、逐次センサデータがGoogle Sheetsに書き込まれます。\n\n前のページに戻る\r","excerpt":"Google Apps Scriptを使ったIoTサービス ESP32の設定 リーフを組み立ててスケッチを書き込み、データがGoogle Sheetsに書き込まれることを確認しましょう。\n使用するリー …","ref":"/docs/examples/advanced/2_p/esp32/esp32_googlesheets_1/esp32_googlesheets_2/","title":" "},{"body":"概要 ESP32 MCUリーフと4-Sensorsリーフだけで、IoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\nGoogle Sheetsの準備 ESP32 MCUリーフが送るセンサデータをGoogle Sheetsで表示する、IoTサービスを紹介します。 ブラウザを閲覧できるPCやスマホがあれば、どこでもデータを確認できます。\nまずは、Google Sheetsでデータを表示するための設定を以下の通り行いましょう。  Googleアカウントにログインし、新しいスプレッドシートを作成しましょう。アカウントがない場合は作成してください。  \n Google Sheetsのタイトル（デフォルト：無題のスプレッドシート）は自由に変更して大丈夫です。\nまた、シート番号（デフォルト：シート1）も自由に変更して大丈夫です。\n  下のGoogle SheetsのURLの部分の赤枠で囲った記号列は、後でGoogle Sheetを指定するのに利用するので、適当な場所にコピーしておいてください。\n ここでは、1o0cogc3aomAj58CRdMZARNJtoEmf8dB9ebY02jKV9tA    \nツールからスクリプトエディタを開き、Githubのソースコードをコピー\u0026amp;ペーストしてください。  Leafony/Sample-Sketches/ESP32_GoogleSheets/google_scripts_code.js - GitHub    \n以下の変数に、先ほど作成したGoogle Sheetsの情報を入力してください。  google_sheets_id：先ほどコピーしたGoogle SheetsのURLの記号列 sheet_name：書き込み先のシート名（デフォルト：シート1）    \nGoogle Sheetsを公開する手順について、説明します。\n公開-\u0026gt;ウェブアプリケーションとして導入をクリックします。  \n続いて、アクセスの権限をAnyone, even anonymousに変更し、誰でも閲覧できるようにします。  \nデプロイボタンを押すと、Script AppからGoogle Sheetsへのアクセス権限の確認が行なわれるので、許可を確認をクリックしてください。  \n左下の詳細をクリックしてください。  \n次に警告が出るので、（安全ではないページ）に移動をクリックしてください。  \n最後にスクリプトからスプレッドシートへのアクセスリクエストを許可してください。  \n以下のポップアップ画面が表示され、今回作成したウェブアプリ固有のURLが発行されるので、URLをコピーしてOKをクリックしてください。  \n（アプリ固有のURL）\nhttps://script.google.com/macros/s/AKfycbw-8Wx8Zf0alULuD3aLQdwnyVM8hSHAiDsrj49wA17ZqE7y-tP8/exec\rGoogle Sheetsの動作確認   今回は試しに、Datetime、UniqueID=Leafony_AP02-1、Temperature=100、Humidity=100、Illumination=100 を、Google Sheetsに書き込んでみます。\n  アプリ固有のURLに、?UniqueID=Leafony_AP02-1\u0026amp;temperature=100\u0026amp;humidity=100\u0026amp;illumination=100を追加すると、以下の通りになります。\n  https://script.google.com/macros/s/AKfycbw-8Wx8Zf0alULuD3aLQdwnyVM8hSHAiDsrj49wA17ZqE7y-tP8/exec?UniqueID=Leafony_AP02-1\u0026amp;temperature=100\u0026amp;humidity=100\u0026amp;illumination=100\r\n上記のURLをブラウザに貼り付け、アクセスすると、設定したGoogle Sheetsにデータが書き込まれます。  Google Sheetsの1行目に記載されているカラム名は自動表示されないため、予めご記載ください。 \nスクリプトのミスがあった場合  スクリプトを修正します。 公開-\u0026gt;ウェブアプリケーションとして導入をクリックします。 最初と全く同じ設定でデプロイすると修正したコードがうまく反映されないことがあるので、再デプロイのときはProject versionをNewに設定して更新をクリックします。 またその時動作しているウェブアプリのURLは以下で確認出来ます。  \n次へ進む 前のページに戻る\r","excerpt":"概要 ESP32 MCUリーフと4-Sensorsリーフだけで、IoT環境センサを作り、Google スプレッドシートを使って、センサデータを可視化します。\nGoogle Sheets …","ref":"/docs/examples/advanced/2_p/esp32/esp32_googlesheets_1_old/","title":"Google Sheetsを使ったIoTサービス"},{"body":"Google Sheetsを使ったIoTサービス ESP32の設定 リーフを組み立ててスケッチを書き込み、データがGoogle Sheetsに書き込まれることを確認しましょう。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover  2   AI01 4-Sensors 1   AX07 Back to back 1   AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*8mm screw 2    M2*12mm screw 2    φ10x2mm magnet 1    リーフの組み立て ESP32 MCUリーフと4-Sensorsリーフを重ねて、下図のようにねじ止めします。\nソースコード Arduino IDEでプログラムを書きましょう。\n ESP32_GoogleSheets.ino  Githubのソースコードの以下の箇条書きの内容に注意して修正し、ESP32リーフに書き込んで下さい。\n アクセスするWiFiの情報を以下の定数に代入してください。  const char* SSID = \u0026quot;wifi_ssid\u0026quot;; // WiFi SSID\rconst char* PASSWORD = \u0026quot;wifi_password\u0026quot;; // WiFi Password\r先ほど作成したウェブアプリの情報を以下の定数に代入してください。  アプリ固有のURLより：const char* KEY = AKfycbxbxoqWzuN8Eztplnhf3ywC-0QpWc8utkIY1QLngj4fHJFRvZKh    const char* KEY = \u0026quot;google_scripts_key\u0026quot;;\rセンサデータの書き込みの時間間隔を調整したいときは以下の定数に代入してください。  単位は秒です    uint64_t DEEP_SLEEP_TIME_SEC = 60;\r#include \u0026lt;Arduino.h\u0026gt;#include \u0026lt;Wire.h\u0026gt;#include \u0026lt;HTTPClient.h\u0026gt;#include \u0026lt;HTS221.h\u0026gt;#include \u0026lt;ClosedCube_OPT3001.h\u0026gt; // Unique ID String UniqueID = \u0026#34;Leafony_AP02\u0026#34;; // Connecting WiFi Settings const char* SSID = \u0026#34;wifi_ssid\u0026#34;; // WiFi SSID const char* PASSWORD = \u0026#34;wifi_password\u0026#34;; // WiFi Password // Accessed Google Script Settings const char* APP_SERVER = \u0026#34;script.google.com\u0026#34;; const char* KEY = \u0026#34;google_scripts_key\u0026#34;; // Device sleep time (sec) to reduce Joule heat uint64_t DEEP_SLEEP_TIME_SEC = 60; // 省略 実行結果 Arduinoを実行して、逐次センサデータがGoogle Sheetsに書き込まれます。\n\n前のページに戻る\r","excerpt":"Google Sheetsを使ったIoTサービス ESP32の設定 リーフを組み立ててスケッチを書き込み、データがGoogle Sheetsに書き込まれることを確認しましょう。\n使用するリーフ 以下の …","ref":"/docs/examples/advanced/2_p/esp32/esp32_googlesheets_1_old/esp32_googlesheets_2_old/","title":" "},{"body":"概要 ESP32 MCUリーフと4-Sensorsリーフの加速度センサを利用して、ポストの開け閉めを検出します。\nバッテリーを長持ちさせるためにESP32は主にDeep Sleep状態で、ポストが開いたときに加速度センサから割り込み信号を生成します。 ESP32が立ち上がってからGoogle Apps Scriptにデータを送信して、そこからLINEに通知を送信します。\n実際にこのシステムは東京大学の桜井研究室で利用されています。\nその時の開発のポイントや、どのように役立っているのかを動画にまとめました。\n  LINE通知サービスの設定 LINE通知にはLINE Notifyを利用します。\n  LINE Notifyのトップページから自分のLINE IDを使ってログインしましょう。\n   メールアドレスとパスワードを入力します。\n   ログイン後にトップ画面からマイページを開きます。\n   トークンの新規作成ボタンをクリック。\n   トークンの名前を入力し、通知を送信するグループを選択する。\n   トークンが発行されたら、しっかりとコピーして下さい。\nこの画面を閉じたらこのトークンの記号列は二度と表示されなくなります。\n   トークンの生成が完了しました。設定したLINEにもメッセージが届いているはずです。\n   Googleクラウドサービスの設定 Google Apps Scriptの設定はGoogle Sheetsを使ったIoTサービスの内容を参照します。\nコードはGithubのgoogle_scripts_code.jsにアップされています。\n  Google Sheetsの準備の1-3の手順に沿ってスプレッドシートの用意をします。\n  Google Sheetsの準備の4の部分で以下のコードを貼り付けます。\nその際，以下の箇所を適宜修正してください。\n 3行目: LINE通知サービスの設定の6の画面で発行されたトークンの記号列に置き換える var token = \u0026#34;line_notify_token\u0026#34;  16-17行目: GoogleスプレッドシートのID let id = \u0026#39;google_sheets_id\u0026#39;; let sheetName = \u0026#39;sheet_name\u0026#39;;  44行目: LINEに送るテキストメッセージ\n例のように+でテキストと変数を連結できます。 var lineMessage = \u0026#34;ポストに投函ました\\n現在のバッテリーの電圧：\u0026#34; + e.parameter.battery + \u0026#34;[V]\u0026#34;;   1// LINEへの送信処理 2function sendToLine(text){ 3var token = \u0026#34;line_notify_token\u0026#34;; 4 5 var options = 6 { 7 \u0026#34;method\u0026#34; : \u0026#34;post\u0026#34;, 8 \u0026#34;payload\u0026#34; : \u0026#34;message=\u0026#34; + text, 9 \u0026#34;headers\u0026#34; : {\u0026#34;Authorization\u0026#34; : \u0026#34;Bearer \u0026#34;+ token} 10 }; 11UrlFetchApp.fetch(\u0026#34;https://notify-api.line.me/api/notify\u0026#34;, options); 12} 13 14function doGet(e) { 15 16 let id = \u0026#39;google_sheets_id\u0026#39;; 17 let sheetName = \u0026#39;sheet_name\u0026#39;; 18 var result; 19 20 // e.parameter has received GET parameters, i.e. temperature, humidity, illumination 21 if (e.parameter == undefined) { 22 result = \u0026#39;Parameter undefined\u0026#39;; 23 } else { 24 var sheet = SpreadsheetApp.openById(id).getSheetByName(sheetName); 25 var newRow = sheet.getLastRow() + 1; // get row number to be inserted 26 var rowData = []; 27 28 // get current time 29 rowData[0] = new Date(); 30 rowData[1] = e.parameter.UniqueID; 31 rowData[2] = e.parameter.temperature; 32 rowData[3] = e.parameter.humidity; 33 rowData[4] = e.parameter.illumination; 34 rowData[5] = e.parameter.battery; 35 36 // 1 x rowData.length cells from (newRow, 1) cell are specified 37 var newRange = sheet.getRange(newRow, 1, 1, rowData.length); 38 39 // insert data to the target cells 40 newRange.setValues([rowData]); 41 result = \u0026#39;Ok\u0026#39;; 42 } 43 44 var lineMessage = \u0026#34;ポストに投函されました\\n現在のバッテリーの電圧：\u0026#34; + e.parameter.battery + \u0026#34;[V]\u0026#34;; 45 sendToLine(lineMessage); 46 47 return ContentService.createTextOutput(result); 48}   Google Sheetsの準備の6-12の手順に沿ってデプロイします。\n  Google Sheetsの動作確認と修正 Google Sheetsを使ったIoTサービスの以下の項目を参照してください。\n  Google Sheetsの動作確認\n  スクリプトのミスがあった場合\n  Leafonyの準備 使用するリーフ ESP32 MCUリーフと4-sensorリーフを重ねます。\n書き込みプログラム ESP32にGithubに上がっている以下のファイルをESP32 MCUリーフに書き込みます。\n ESP32_Post_Notify.ino MyLIS3DH.cpp MyLIS3DH.h  システム全体の制御フローは以下の図ように設計します。\nWi-Fiの設定 ESP32_Post_Notify.inoにWi-FiのSSIDやパスワードなどの設定項目があります。 重要な項目を箇条書きにしたので、適当に設定してください。\n  Wi-Fiを使ってネットに接続する場合はUSE_WiFiを定義します。\n#define USE_WiFi   接続先のWi-FiがWPA2 Personal（自宅のルーターなどで利用される認証方式。通常これ）を利用しているときは以下の変数にSSIDとパスワードを格納します。\nconst char* SSID = \u0026#34;wifi-ssid\u0026#34;; // WiFi SSID const char* PASSWORD = \u0026#34;wifi-pass\u0026#34;; // WiFi Password   特に、接続先のWi-Fiが大学や企業などにあり、EduroamなどのWPA2 Enterpriseを使用しているときのみ、以下を定義します。\n#define USE_WiFi_ENTERPRISE Wi-Fi Enterprise用のIDやパスワードは以下に入力してください。\n///////////////////////////////////////////////////////////////////////////////////////////////////// // parameters for connecting eduroam enterprise ///////////////////////////////////////////////////////////////////////////////////////////////////// #define EAP_IDENTITY \u0026#34;eap_id\u0026#34; //if connecting from another corporation, use identity@organisation.domain in Eduroam #define EAP_PASSWORD \u0026#34;eap_pass\u0026#34; //your Eduroam password const char* SSID_ENT = \u0026#34;eduroam\u0026#34;; // Eduroam SSID /////////////////////////////////////////////////////////////////////////////////////////////////////   接続先Googleクラウドの設定 ESP32_Post_Notify.inoで接続先Googleスクリプトの設定を行っています。 Googleクラウドサービスの設定の3で設定したGoogle Apps Scriptの固有IDを以下の変数に格納します。\nconst char* KEY = \u0026#34;google_scripts_key\u0026#34;; スリープ動作 Wi-Fiに接続してデータを送った後は，EP32 MCUがDeep Sleepモードに入ることで待機電力を極力減らします。\nDeep Sleepモードに入る前にESP32 MCU内のWi-Fiモジュールの電源を切ることを忘れないでください。\nWiFi.disconnect(true) // Wi-Fiをオフにするために，trueを明示してください 加速度センサ(LIS3DH)の設定 加速度センサ用の設定パラメータはレポジトリに上がっているMyLIS3DH.cppで修正できます。\n実際に身の回りのポストに実装する場合にはパラメータを環境に合わせて設定する必要があります。 今回は例として、以下のように蓋が開閉するポストを考えます。\n加速度センサが生成できる割り込み信号は独立に2つ(INT1, INT2)あり、そのうちのINT1を使います。\nデータシートによると割り込み信号の指定にはCTRL_REG3というレジスタに書き込みます。\nCTRL_REG3の説明をデータシートから読んでみます。\nデータシートから、I1_AOI1ビットを1に設定するとINT1の割り込みが有効になります。\nよって、以下のようにプログラムします。\nwriteRegister8(LIS3DH_REG_CTRL3, 0x40); 割り込み信号を生成するための条件（どのような振動の場合に割り込み信号を生成するのか、等）を設定できるのですが、今回主に設定するパラメータは以下の4つです。\n閾値 (Threshold) ポストの蓋の裏面にリーフが張り付けると、蓋が傾いた時に、加速度センサからみた重力加速度の向きが変化します。\nこの加速度の向きを検出することが出来れば、郵便物が投函されたかどうかセンシング出来ます。\nいま、実験により、郵便物が投函されるとき蓋が少なくとも10度は傾くことが分かったとします。\nそのとき、加速度センサのz軸方向の加速度（図中の緑色の矢印）が0gから0.17gまで増加することが分かるので、この0.17gを閾値に設定してあげれば良さそうです。\n一方、加速度センサのLIS3DHはデフォルトでフルスケールが±2gの検出を行います。\n(これはESP32_PostNotify.inoで設定されています。)\nlis.setRange(LIS3DH_RANGE_2_G); // 2, 4, 8 or 16 G! データシートによると、使用している加速度センサは軸の正（負）方向に対してそれぞれ128段階の分解能(フルスケールで8-bitの分解能)を持っています。\n0.17gが2gに対して、どのレベルなのかを128段階のレベルで表すと、\n128 / 2g * 0.17g = 10.88\rなので、閾値レベル11(16進数では0x0B)を設定します。\nこの閾値の情報はINT1THSというレジスタに書き込みます。\n一応、レジスタの情報をデータシートから確認してみると、書き込める数値は0~127までだということが分かります。\nプログラムでは以下のように記述します。\nwriteRegister8(LIS3DH_REG_INT1THS, 0x0B); 検出軸 (Detection Axes) 閾値の項目で考えた通り，今回は加速度の3軸のうち1つの軸のみを使って郵便物の投函を検出します。\n軸の選択には、以下の2つのレジスタに書き込みます。\n  CTRL_REG1\nセンシングする3軸方向の加速度の有効・無効の設定を行います。\n使用する軸以外は無効にすることで電力を抑えられ、バッテリーが長持ちします。\nまた、低電力モード(Low Power Mode)とサンプル周波数の設定もこのレジスタで行います。\n  INT1_CFG\n割り込み用に設定する軸方向の決定を行います。\nまた、軸の選択以外に割り込み信号の発生方法も設定出来ます。\n  CTRL_REG1に関して、今回の用途では、以下のように設定しようと思います。\n Z軸方向のみで検出を行う 理由は後述するが、10Hzで加速度をサンプリングを行う 低電力モードも使う  よってデータシートから、レジスタはODR3からXenまで順に00101100と設定すればいいので以下のようにプログラムします。\n writeRegister8(LIS3DH_REG_CTRL1, 0x2C);\rINT1_CFGに関して、上のデータシートに、AOIと6Dというよく分からない項目があります。\nデータシートのTable 48.を見てみると、どうやらAOIと6Dを使って割り込み信号を生成する方法を設定できるようです。\nORとANDの条件は各軸それぞれに対して割り込みを発生させるときの条件として考えれば良さそうです。\n一方、6 direction movementと6 direction position recognitionはここからだとよく分かりません。\nそれらの説明はアプリケーションノートに以下のように記述されていました。\n少し難しいですが簡単にまとめると、こんな感じになります。\n 6D movement: 指定した閾値を超えたときと、そこから戻るときに一瞬だけ割り込み信号を生成 6D position: 指定した閾値以上になっている間、常に割り込み信号を生成  また、このアプリケーションノートのFigure 12から、X・Y・Z軸の中でも、上方向と下方向で別々に割り込み処理を設定できるということも分かりました。\nこれらの設定がINT1_CFGのZHIE/ZUPE``ZLIE/ZDOWNE・・・XLIE/XDOWNEの箇所で設定できるようです。\n以上のことから、割り込み信号の生成条件としては、\n Z方向の割り込み信号のみを有効 Z方向の指定した閾値を超えたときに一瞬だけ割り込み信号を生成する  以下のようにプログラムすれば良いと分かりました。\n writeRegister8(LIS3DH_REG_INT1CFG, 0x70); サンプリング周波数 (Sampling Rate) \u0026amp; 時間幅 (Duration) サンプリング周波数と時間幅は関連しているので、一緒に説明します。はじめにそれぞれを簡単に説明します。\n サンプリング周波数：センサが加速度を取得する時間間隔を設定できます。周波数が上がるほど，時間分解能は上がりますが，その分センサの消費電力も増加してしまいます。 時間幅：割り込み信号が発生するまでに閾値を何秒間越えなければいけないか、という条件を設定できます。\nポストの蓋に何かがぶつかってしまったりなど、たまたま環境ノイズを拾ってしまったりしたときに、誤って検知してしまうことを防げます。  郵便物が投函されたときに加速度センサの応答が図のように0.3秒以上閾値を超えるとし、それ以下の場合は環境ノイズとして処理します。\nこの場合、サンプリング周波数は10Hzで設定すれば問題なさそうです。\n検出軸の項で説明した通り、設定レジスタはCTRL_REG1です。\nODR0-ODR3でサンプリング周波数を決定できます。\n再掲ですが、以下のようにプログラムします。\n writeRegister8(LIS3DH_REG_CTRL1, 0x2C);\r時間幅の設定レジスタはINT1_DURATIONです。実際にセンサは連続時間を測っているわけではなく、サンプリング回数で時間間隔を計算しています。\n0.3秒以上閾値を超えるようであれば、割り込み信号を生成します。\n今回はサンプル周波数を10Hzで設定しており、設定値は以下のように計算します。\n0.3 / 0.1 = 3\rこれは以下のようにプログラムします。\n writeRegister8(LIS3DH_REG_INT1DUR, 0x03); 実行結果 ESP32を傾けたときにスリープから立ち上がり、Wi-Fiに接続してからLINE Notifyに通知を送信します。\nLINE Notifyで受け取った画面は以下のようになります。\n前のページに戻る\r","excerpt":"概要 ESP32 MCUリーフと4-Sensorsリーフの加速度センサを利用して、ポストの開け閉めを検出します。\nバッテリーを長持ちさせるためにESP32は主にDeep Sleep状態で、ポストが開い …","ref":"/docs/examples/advanced/2_p/esp32/esp32_post_notify/","title":"低電力にポスト投函検出してLINE通知"},{"body":"概要 工場出荷時に、ESP32 MCUリーフにArduinoのスケッチが書き込まれているので、スマートフォンやパソコンのWi-Fiを使ってタッチセンサの値を送信して、表示がされます。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1   AV04 2V~4.5V 1   AX07 Back to back 1   AX08 29pin header 1   AZ62 Connector Cover  2   AZ63 Nut Plate 2    AAA battery holder 1    AAA battery 3    M2*15mm screw 4    φ10x2mm magnet 1    リーフの組み立て 下図のようにリーフを組み立てましょう。\nピンアサイン 各リーフのピンアサインは下図を参考\n\nソースコード 使用するスケッチは下記のGitHubリポジトリにあります。\nLeafony/Sample-Sketches/ESP32_AP_Touch - GitHub\n実行方法  ESP32 Wi-Fi Kitに単4電池3本をセットし、電源スイッチをONにして下さい。\n PC、スマートフォン、またはタブレット等で周辺のWi-Fiを検索し、以下のSSIDのWi-Fiに接続します。  SSID: Leafony_ESP32-AP Password: password   以下のURLをコピーし、WebBLEを立ち上げてアドレスバーに貼り付けてください。   http://192.168.4.1\r 29pin headerの7、9、22、24、26、28ピンがタッチセンサに割り当てられています。\nピンに触れると静電容量が増えるため、値が減少します。値が閾値20以下になると”Touch detected”と表示されます。\n(24ピンはRTC\u0026amp;microSDと干渉しているため、サンプルスケッチでは非表示にしています。検出閾値は、スケッチで変更可能です。以下の写真では、指先で26ピンに触れています。)\n   26ピンに触れていると、以下のようにWebブラウザの表示が変化します。　   ESP32 Wi-Fi KitのNut Plate部分にマグネットが付いています。金属の壁などに設置してみましょう。\n  前のページに戻る\r","excerpt":"概要 工場出荷時に、ESP32 MCUリーフにArduinoのスケッチが書き込まれているので、スマートフォンやパソコンのWi-Fiを使ってタッチセンサの値を送信して、表示がされます。\n使用するリーフ  …","ref":"/docs/examples/advanced/2_p/esp32/wifi_touchsensor/","title":"Wi-Fi タッチセンサ"},{"body":"はじめに STM32リーフを使ったシンプルなBLE Beaconのサンプルデザインです。 「HELLO BEACON」という文字列を一定期間送信してからスリープを繰り返します。\nサンプルのソースコード 使用するスケッチやツールのソースコードは下記のリポジトリで閲覧可能です。\nSample-Sketches/STM32_Simple_Beacon at master · Leafony/Sample-Sketches\n用意するもの 使用するリーフ 動作方法 スケッチの解説 フローチャート STM32_Simple_Beacon.inoのloop()関数の動作は下図のように、STM32リーフとBLEリーフが交互にスリープ状態とアクティブ状態を一定の時間繰り返しながらBeaconのパケット(Advertising data)を送信することで、省電力なシステムを実現しています。\nSTM32リーフがStartAdvData()を実行すると、BLEリーフでブロードキャストしたいAdvertising dataを設定し、送信を開始するコマンドを送ります。\nBLEリーフがAdvertising中、STM32リーフは何もしないため、LowPower.deepSleep()関数でディープスリープモードに移行し、WAKE_INTERVALで設定した時間が経過後、再びアクティブ状態に戻ります。この間、STM32リーフでは必要最小限の電力で動作できるように不要な回路ブロックの電源を落とす等をし、非常に省電力な状態で動作します。\nSTM32リーフがアクティブ状態に移行後、sleepBLE()関数を実行し、BLEリーフのAdvertisingを停止させ、BLEリーフをスリープモードに移行させます。その後すぐにSTM32リーフ自身もLowPower.deepSleep()関数でSLEEP_INTERVALで設定した時間ディープスリープモードに移行します。この状態においては極わずかな電力しか消費せず、SLEEP_INTERVALの時間を長くすればするほど電池の持ちを良くすることができます。\nSTM32リーフがディープスリープから復帰後、すぐにBLEリーフを起動させ、再びStartAdvData()を実行して最初の処理に戻ります。\nAdvertising dataの仕様 STM32_Simple_Beacon.inoのStartAdvData()関数では、BLEリーフにAdvertising dataを設定し、BLE Client（PCやスマホ、Raspberry Pi等のLeafonyとBLE接続する機器）でLeafonyを検出した際に表示されるデバイス名を「Leaf_A」とし、ユーザデータとして「HELLO BEACON」という文字列を送信しています。\nadv_data[]配列がAdvertising dataです。この配列はコメントに記載されているように、AD Structure 1～AD Structure 3というデータの塊を繋げたデータとなっています。これらのデータの内容については後述します。\nble112.ble_cmd_le_gap_set_adv_data()でadv_dataをBLEリーフに登録し、BLEリーフ側から登録完了の信号が来るのを待つために、ble112.checkActivity()を実行しています。\nble112.ble_cmd_le_gap_start_advertising()を実行することで、BLEがAdvertisingを開始して、先程設定したAdvertising dataをブロードキャストし始めます。LE_GA_SCANNABLE_NON_CONNECTALBEを設定したことで、BLE Client側はAdvertising dataをスキャンすることはできますが、このデバイスと接続を確立することは禁止しています。これは、接続要求が来た場合に発生するイベントの処理を減らして電力を削減するための設定です。\nvoid StartAdvData() { // Advertising data; 25byte MAX  uint8_t adv_data[] = { // AD Structure 1: Flag  (2), //0: field length  BGLIB_GAP_AD_TYPE_FLAGS, //1: field type (0x01)  (6), //2: data  // AD Structure 2: Complete local name  (7), //3: field length  BGLIB_GAP_AD_TYPE_LOCALNAME_COMPLETE, //4: field type (0x09)  (\u0026#39;L\u0026#39;), //5:  (\u0026#39;e\u0026#39;), //6:  (\u0026#39;a\u0026#39;), //7:  (\u0026#39;f\u0026#39;), //8:  (\u0026#39;_\u0026#39;), //9:  (\u0026#39;A\u0026#39;), //10:  // AD Structure 3: Manufacture specific  (13), //11: field length  (0xff), //12: field type (0xff)  (\u0026#39;H\u0026#39;), //13:  (\u0026#39;E\u0026#39;), //14:  (\u0026#39;L\u0026#39;), //15:  (\u0026#39;L\u0026#39;), //16:  (\u0026#39;O\u0026#39;), //17:  (\u0026#39; \u0026#39;), //18:  (\u0026#39;B\u0026#39;), //19:  (\u0026#39;E\u0026#39;), //20:  (\u0026#39;A\u0026#39;), //21:  (\u0026#39;C\u0026#39;), //22:  (\u0026#39;O\u0026#39;), //23:  (\u0026#39;N\u0026#39;), //24:  }; // Register advertising packet  uint8_t stLen = sizeof(adv_data); ble112.ble_cmd_le_gap_set_adv_data(SCAN_RSP_ADVERTISING_PACKETS, stLen, adv_data); while (ble112.checkActivity(1000)); // index = 0 LE_GAP_SCANNABLE_NON_CONNECTABLE / LE_GAP_UNDIRECTED_CONNECTABLE  ble112.ble_cmd_le_gap_start_advertising(0, LE_GAP_USER_DATA, LE_GAP_SCANNABLE_NON_CONNECTABLE); while (ble112.checkActivity(1000)); } 下図はBLEのAdvertisingで使用される、Advertising dataのフォーマットを表しています。\nAdvertising dataは複数のAD Structureというデータの塊から構成されています。各AD Structureの中身はLengthとDataに分けられ、Lengthには、Dataのオクテット数(何byteか)が登録されます。\nDataの中身は更に、AD TypeとAD Dataに分けられ、AD TypeでこのAD Structureがどのような意味のデータなのかが分かるようになっています。\n例えば、上記コードのAD Structure 2はLengthが7で、AD TypeはBGLIB_GAP_AD_TYPE_LOCALNAME_COMPLETE (0x09)でデバイスのローカルネームであることがわかり、DataにLeaf_Aと登録されています。\nAD Structure 3のAD Typeは0xffで、このAD Structureには任意のデータを登録することができます。Dataには「HELLO BEACON」というテキストが登録されていて、このデータを変えれば自由にデータをAdvertising dataに載せてブロードキャストすることができます。\nBLEリーフの動作  各種設定 イベントハンドラ  前のページに戻る\r","excerpt":"はじめに STM32リーフを使ったシンプルなBLE Beaconのサンプルデザインです。 「HELLO BEACON」という文字列を一定期間送信してからスリープを繰り返します。\nサンプルのソースコー …","ref":"/docs/examples/advanced/3_p/stm32/stm32_simple_ble_beacon/","title":"STM32 Simple BLE Beacon"},{"body":"Introduction This is an example of a BLE Beacon type environmental sensor application using ESP32. By adding sensor data to the Attribute of the GATT Server, it can act as a beacon that broadcasts the data. When a connection request is received from the outside, the GATT Server will communicate with the server client and exchange log data with the Characteristic.\nThe loss of data due to packet reception failure that occurs in the Beacon type is prevented by leaving the sensor data in the non-volatile memory in the ESP32. Users can connect and read log data at any time, and the system will immediately switch to Beacon mode after data transfer is completed, greatly reducing power consumption.\nSample app\u0026rsquo;s source code The source code for the sketches and tools used can be viewed in the repository below.\nSample-Sketches/ESP32_BLE_Beacon at master · Leafony/Sample-Sketches\nWhat to prepare  Leafony ESP32 Wi-Fi Kit Leafony Basic Kit Raspberry Pi Android Smartphone USB micro cable  Leaf to use    Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1   AI01 4-Sensors 1    M2 screw 2    Action Method This section describes the steps to run the sample project. If you want to understand how each source code works, please refer to Mechanism described below.\n1. Writing a sketch to an ESP32 leaf Connect the ESP32 leaf to the PC via USB and write the ino file using the Arduino IDE.\nThe sample code uses the ESP32 Logging Library. The sample code uses the ESP32 Logging Library.\nBy setting the Tools → Code Debug Level in the Arduino IDE to the desired level, debug messages will be displayed on the serial monitor.\n2. Run the beacon scanner app. For scanning Advertising packets, use an app that runs on Node.js.\nAny environment can be used as long as it runs Node.js, but this time we will assume that it will be a Beacon receiver set up at a fixed point outdoors, and we will explain how to run the application using a Raspberry Pi 4. In this article, we will explain how to run the application using a Raspberry Pi 4.\nInstall the necessary packages and run the application.\ncd ./tools/node-scanner npm install npm start 3. Run the logging application. A web application is used to retrieve log data and display graphs.\nESP32 Sensors Logger\nStructure How BLE Beacon works GATT Advertising Characteristic Back to previous page\r","excerpt":"Introduction This is an example of a BLE Beacon type environmental sensor application using ESP32. …","ref":"/en/docs/examples/advanced/2_p/esp32/esp32_ble_beacon/","title":"ESP32 BLE Beacon"},{"body":"Introduction This is a sample design of a BLE Beacon that can record temperature, humidity and measurement time using the Flash memory in the STM32 leaf.\nThe temperature/humidity measurement method using Beacon can only provide the temperature/humidity at the current time, and in order to know the measured values up to now, it was necessary to constantly receive Beacon radio waves with a separately installed receiver.\nSince Beacon\u0026rsquo;s radio wave is very weak and its transmission time is short, it is often missed during reception, which is insufficient for stable measurement.\nHowever, in this sample, the measurement record can be kept in the non-volatile memory installed in the STM32, so even if the Beacon signal is not received, the data recorded in the non-volatile memory can be retrieved later by connecting to Leafony.\nThis sample also includes a web application sample that can both receive Beacon and read data written to STM32 Flash memory.\nSample source code The source code for the sketches and tools used can be viewed in the repository below.\nSample-Sketches/STM32_Logger_Beacon at master · Leafony/Sample-Sketches\nSTM32 Sensors Logger Web Application\nWhat to prepare  Leafony Android smartphone  Laef to use    Type Name Q\u0026rsquo;ty     AI01 4-Sensors 1   AP03 STM32 MCU 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    How it works Write a sample sketch on the STM32 leaf.\nOpen the web app on your Android smartphone, and once it is connected to Leafony, the current time on your smartphone will be registered. After that, once the connection with Lefaony is disconnected, it will shift to Beacon operation.\nThe web app side receives the Beacon signal and displays the current temperature.\nWhen you connect Leafony again and press the Log button, the STM32\u0026rsquo;s Flash memory will be read out and a graph of the past temperature and humidity will be displayed.\nOperation Description Back to previous page\r","excerpt":"Introduction This is a sample design of a BLE Beacon that can record temperature, humidity and …","ref":"/en/docs/examples/advanced/3_p/stm32/stm32_logger_ble_beacon/","title":"STM32 Logger Beacon"},{"body":"Introduction This is a simple BLE Beacon sample design using STM32 Leaf. Send the string \u0026ldquo;HELLO BEACON\u0026rdquo; for a period of time, then repeat the sleep cycle.\nSample source code The source code for the sketches and tools used can be viewed in the repository below.\nSample-Sketches/STM32_Simple_Beacon at master · Leafony/Sample-Sketches\nWhat to prepare Leaf to use How it works Explanation of the sketch Flowchart As shown in the figure below, the loop() function of STM32_Simple_Beacon.ino works by sending Beacon packets (Advertising data) while the STM32 leaf and BLE leaf alternately repeat the sleep state and active state for a certain period of time. We have achieved a power-saving system.\nWhen the STM32 leaf executes StartAdvData(), it sets the Advertising data it wants to broadcast on the BLE leaf and sends a command to start sending it.\nSince the STM32 leaf does not do anything while the BLE leaf is Advertising, it enters the deep sleep mode with the LowPower.deepSleep() function, and returns to the active state after the time set with WAKE_INTERVAL has passed. During this time, the STM32 leaf operates in a very power-saving state by turning off the power of unnecessary circuit blocks, etc. so that it can operate with the minimum necessary power.\nSince the STM32 leaf does not do anything while the BLE leaf is Advertising, it enters the deep sleep mode with the LowPower.deepSleep() function, and returns to the active state after the time set with WAKE_INTERVAL has passed. During this time, the STM32 leaf operates in a very power-saving state by turning off the power of unnecessary circuit blocks, etc. so that it can operate with the minimum necessary power.\nAfter the STM32 leaf comes back from deep sleep, we immediately wake up the BLE leaf and run StartAdvData() again to return to the initial process.\nAdvertising data specifications In the StartAdvData() function of STM32_Simple_Beacon.ino, we set the BLE leaf to Advertising data, set the device name to \u0026ldquo;Leaf_A\u0026rdquo; that will be displayed when the BLE Client (PC, smartphone, Raspberry Pi, or other device connected to BLE with Leafony) detects Leafony and sends the string \u0026ldquo;HELLO BEACON\u0026rdquo; as user data.\nThe adv_data[] array is the Advertising data. As described in the comments, this array is the data that connects the chunks of data AD Structure 1 to AD Structure 3. The contents of these data will be described later.\nRegister adv_data to the BLE leaf with ble112.ble_cmd_le_gap_set_adv_data() and run ble112.checkActivity() to wait for the signal from the BLE leaf side that the registration is completed.\nBy running ble112.ble_cmd_le_gap_start_advertising(), BLE will start Advertising and start broadcasting the Advertising data that you just set. By setting LE_GA_SCANNABLE_NON_CONNECTALBE, the BLE Client side can scan the Advertising data, but it is not allowed to establish a connection with this device. This setting is to save power by reducing the processing of the events that occur when a connection request comes in.\nvoid StartAdvData() { // Advertising data; 25byte MAX  uint8_t adv_data[] = { // AD Structure 1: Flag  (2), //0: field length  BGLIB_GAP_AD_TYPE_FLAGS, //1: field type (0x01)  (6), //2: data  // AD Structure 2: Complete local name  (7), //3: field length  BGLIB_GAP_AD_TYPE_LOCALNAME_COMPLETE, //4: field type (0x09)  (\u0026#39;L\u0026#39;), //5:  (\u0026#39;e\u0026#39;), //6:  (\u0026#39;a\u0026#39;), //7:  (\u0026#39;f\u0026#39;), //8:  (\u0026#39;_\u0026#39;), //9:  (\u0026#39;A\u0026#39;), //10:  // AD Structure 3: Manufacture specific  (13), //11: field length  (0xff), //12: field type (0xff)  (\u0026#39;H\u0026#39;), //13:  (\u0026#39;E\u0026#39;), //14:  (\u0026#39;L\u0026#39;), //15:  (\u0026#39;L\u0026#39;), //16:  (\u0026#39;O\u0026#39;), //17:  (\u0026#39; \u0026#39;), //18:  (\u0026#39;B\u0026#39;), //19:  (\u0026#39;E\u0026#39;), //20:  (\u0026#39;A\u0026#39;), //21:  (\u0026#39;C\u0026#39;), //22:  (\u0026#39;O\u0026#39;), //23:  (\u0026#39;N\u0026#39;), //24:  }; // Register advertising packet  uint8_t stLen = sizeof(adv_data); ble112.ble_cmd_le_gap_set_adv_data(SCAN_RSP_ADVERTISING_PACKETS, stLen, adv_data); while (ble112.checkActivity(1000)); // index = 0 LE_GAP_SCANNABLE_NON_CONNECTABLE / LE_GAP_UNDIRECTED_CONNECTABLE  ble112.ble_cmd_le_gap_start_advertising(0, LE_GAP_USER_DATA, LE_GAP_SCANNABLE_NON_CONNECTABLE); while (ble112.checkActivity(1000)); } The figure below shows the format of the Advertising data used in BLE Advertising.\nAdvertising data is composed of multiple chunks of data called AD Structure. The content of each AD Structure is divided into Length and Data, and the number of octets (bytes) of Data is registered in Length.\nThe contents of Data are further divided into AD Type and AD Data, with AD Type telling you what kind of data this AD Structure is.\nFor example, in the above code, AD Structure 2 has a Length of 7, the AD Type is BGLIB_GAP_AD_TYPE_LOCALNAME_COMPLETE (0x09) which is the local name of the device, and Leaf_A is registered in Data.\nThe AD Type of AD Structure 3 is 0xff, and any data can be registered in this AD Structure. The Data is the text \u0026ldquo;HELLO BEACON\u0026rdquo;, and you can broadcast any data on Advertising data by changing this data.\nBLE leaf\u0026rsquo;s motion  Various settings Event handler  Back to previous page\r","excerpt":"Introduction This is a simple BLE Beacon sample design using STM32 Leaf. Send the string …","ref":"/en/docs/examples/advanced/3_p/stm32/stm32_simple_ble_beacon/","title":"STM32 Simple BLE Beacon"},{"body":"はじめに ESP32を使ったBLE Beacon型の環境センサアプリケーションの例です。 GATT ServerのAttributeにセンサデータを入れることで、データをブロードキャストするBeaconとして動作するとともに、 外部から接続要求があった場合にはサーバクライアント型の通信を行い、Characteristicでログデータのやり取りを行います。\nBeacon型で発生するパケットの受信失敗によるデータの損失を、ESP32内の不揮発メモリにセンサデータを残すことで防ぎます。 ユーザは任意のタイミングで接続してログデータを読み出す事ができ、データ転送完了後にはすぐにBeaconモードに移行することで電力の消費を大幅に抑えます。\nサンプルのソースコード 使用するスケッチやツールのソースコードは下記のリポジトリで閲覧可能です。\nSample-Sketches/ESP32_BLE_Beacon at master · Leafony/Sample-Sketches\n用意するもの  Leafony ESP32 Wi-Fi Kit Leafony Basic Kit Raspberry Pi Androidスマートフォン USB microケーブル  使用するリーフ    Type Name Q\u0026rsquo;ty     AP02 ESP32 MCU 1   AI01 4-Sensors 1    M2 screw 2    動作方法 サンプルのプロジェクトを動かす手順について説明します。各ソースコードの動作の仕組みについて理解したい場合は、後述する仕組みをご覧ください。\n1. ESP32リーフにスケッチを書き込む ESP32リーフとPCをUSBで接続し、Arduino IDEでinoファイルを書き込んでください。\nサンプルコードにはESP32 Logging Libraryが使用されています。\nArduino IDEの「ツール → Code Debug Level」を任意のレベルに設定することでシリアルモニタにデバッグメッセージが表示されるようになります。\n2. ビーコンスキャナアプリを実行 AdvertisingパケットのScanningにはNode.jsで動くアプリを使用します。\nNode.jsが動く環境であれば動作環境は問いませんが、今回は屋外に定点設置するBeacon受信機とすることを想定し、 Raspberry Pi 4を使ってアプリの動作方法について解説します。\n必要なパッケージをインストールしてアプリ実行します。\ncd ./tools/node-scanner npm install npm start 3. ログ取得アプリを実行 ログデータの取得とグラフの表示にはWebアプリケーションを使用します。\nESP32 Sensors Logger\n仕組み BLE Beaconの仕組み GATT Advertising Characteristic 前のページに戻る\r","excerpt":"はじめに ESP32を使ったBLE Beacon型の環境センサアプリケーションの例です。 GATT ServerのAttributeにセンサデータを入れることで、データをブロードキャストす …","ref":"/docs/examples/advanced/2_p/esp32/esp32_ble_beacon/","title":"ESP32 BLE Beacon"},{"body":"はじめに STM32リーフに搭載されたFlashメモリを使って、温湿度と測定時間を記録することが可能なBLE Beaconのサンプルデザインです。\nSTM32リーフとBLEリーフを使った、センサデータのログ機能付きの実用的なIoTシステムのサンプルデザインです。\nこのサンプルには下記の機能が実装されています。\n 温度、湿度、照度の観測 測定データをBLEのBeacon機能で送信 オンチップFlashに測定データを保存 リアルタイムクロックを使った測定時刻の保存 ブラウザアプリでデバイスの設定変更 ブラウザアプリで測定データの吸い出しとグラフ化 加速度センサを使った振動検知機能によるBLE送信モードの変更 低電力動作モードで半年以上の連続駆動  サンプルのソースコード 使用するスケッチやツールのソースコードは下記のリポジトリで閲覧可能です。\n  Sample-Sketches/STM32_Logger_Beacon at master · Leafony/Sample-Sketches\n  STM32 Sensors Logger Webアプリケーション\n  対応環境  Windows 10 Version 1703以降  Beacon機能は利用不可   Mac OS X Yosemite以降 Android 6.0 Marshmallow以降 Linux Kernel 3.19+ 以降 対応状況詳細はWebbluetooth Implementation Statusを御覧ください。  用意するもの  Leafony Google Chrome  使用するリーフ    Type Name Q\u0026rsquo;ty     AI01 4-Sensors 1   AP03 STM32 MCU 1   AZ01 USB 1   AC02 BLE Sugar 1   AV01 CR2032 1   - CR2032 coin cell battery 1   - M2*18mm screw 2    動作方法   STM32リーフにサンプルスケッチSTM32_Logger_Beacon.inoを書き込んでください。\n  Google ChromeでSTM32 Sensors Logger Webアプリケーションを開いてださい。\n  Start Scanningボタンを押すと、Bluetooth利用許可を求めるポップアップウィンドウ表示されます。許可を押すとBeaconの電波の受信を開始します。\nLeafonyから発されるBeaconの電波を受信すると、画面の温度/電池電圧/受信時刻表示が更新されます。\n  Connectボタンを押すとLeafonyに接続され、数秒ほど待つとFlashメモリに保存されていた過去の測定データを受信し、画面上のグラフが更新されます。\n  受信完了後はDisconnectボタンを押しLeafonyと切断すると、Leafonyは再度Beaconモードに移行し、センサ情報の記録を再開します。\n  動作解説 回路全体のブロック図 本サンプルコードで利用する回路は下図のとおりです。\n主にBLE、センサ、STM32リーフで構成され、特にSTM32リーフでは内部のRTC(リアルタイムクロック)とFlashを利用しています。\nRTCは、BLEを経由してPCやスマートフォンから時刻を設定して使います。\nFlashはプログラムメモリの保存以外に、末尾2kBをユーザがデータを保存できる領域として使うことができます。本サンプルでは、この領域にセンサデータと測定時刻を保存し、本体の電源が切れた後もデータを保持できる仕組みとなっています。\nセンサリーフからは温度、湿度、照度センサがSTM32によって読み出され、BLEでデータが送信されます。加速度センサは振動によって割り込み信号を発生し、STM32をスリープから復帰させる役割があります。\n動作の流れ このサンプルコードでは主に以下の2つの動作モードが存在します。\n Beaconモード Connectionモード  Leafonyに電源を入れると、まず初めに本体の初期化を行なった後にBeaconモードに入ります。\nBeaconモードでは、通常は本体が長時間のスリープ状態に入り、一定時間が経過すると本体がスリープから復帰します。（このスリープ時間はユーザが任意に設定できます。)\n本体がスリープから復帰すると、まずSTM32が起動し、センサを起動させ、温度、湿度、照度を測定します。\nこのとき、STM32に搭載されたリアルタイムクロックに時刻が設定されている場合、測定されたデータはSTM32に搭載されたFlashに保存されます。\nその後、BLEリーフを起動し、Advertisingパケットにセンサデータを設定し、BLEリーフが一定期間Advertisingを開始します。\nこのAdvertisingパケットをウェブアプリで受信することで、温度、湿度、照度のデータをPCやスマートフォンで見ることができます。\n一定期間のAdvertising後は即座に本体がスリープし、消費電力を最小に抑えます。\nBeaconモードでの動作時間が長いほど、電池消費を抑えることが可能です。\nConnectionモードでは、主にPCやスマートフォンでと双方向で通信して、スリープ時間やAdvertising時間を設定したり、Flashに保存されたデータの吸い出しを行い、ウェブアプリでグラフ化するための通信を行います。\nこのモードでは通信中、またはPCやスマートフォンと接続を確立するためのAdvertising期間、常に本体がアクティブ状態にあり、電池消費が大きくなります。\nConnectionモードは、本体の時刻を設定するなどの初回起動時や、ある程度ログデータが溜まった後にデータを吸い出すといったような、利用シーンが限られてくるため、特定の条件でのみこのモードに入るよう設定されています。\nこのサンプルではConnectionモードに入るためには、Leafony本体を左右に強く振ることでConnectionモードに入ることができます。\nこれは、4-Sensorsリーフに搭載された加速度センサが、常に振動を観測し、振動を検知すると即座にSTM32リーフに割り込み信号を送信することで実現されています。\n動作モードの切り替え BeaconモードとConnectionモードの切り替えには加速度センサによる割り込みを使います。\nウェブアプリでBluetoothデバイスを検出するためには、LeafonyがConnectionモードに切り替わり、最低でも数秒から数十秒程度の長い間BLEがAdvertisingする必要があります。\nこれを毎スリープからの復帰後に行なっていると電池消費が非常に大きくなってしまうため、BLEで接続したい時だけConnectionモードに入り長時間Advertisingさせたくなります。\n今回はこれを加速度センサを使った振動検出割り込みで実現しました。\n4-Sensorsに搭載された加速度センサは、振動(指で本体をタップする動作)を検出すると、STM32のINT1ピンに割り込み信号を出します。\n下記の記述で加速度センサのタップ検出を有効化し、その割り込みによってSTM32がスリープから復帰する仕組みを実現しています。\nか速度センサの割り込みによって起動した場合のみConnectモードとして起動させることで、必要な時だけBLEで接続可能な仕組みを実現しました。\naccel.setClick(DOUBLETAP, CLICKTHRESHHOLD); // enable click interrupt  // enable interrupt from accelerometer click event LowPower.attachInterruptWakeup(INT_1, onClicked, RISING, DEEP_SLEEP_MODE); 不揮発メモリのアドレスマップ STM32リーフには内部に不揮発性メモリ（Flashメモリ）が搭載されています。\n本サンプルでは、このFlashメモリを、ユーザ設定の保存と、測定データ保存用のリングバッファとして扱います。\n下図のように、メモリの先頭からいくつかの番地には、スリープ時間や起動時間などのユーザ設定を保存する領域があります。\nそれらを除いた部分を、時刻とセンサのデータを保持するリングバッファとして扱います。\nまた、Flashに書き込まれているデータが、本サンプルスケッチによって書き込まれたものなのかを確かめるため、先頭2バイトに0xAAという値を保存しています。\n本サンプルではこの0xAAが書き込まれていればいれば、保存されている設定を読み込み、書き込まれていなければ新規に初期値をFlashに保存するという動作をします。\nBeacon送信データ Beaconモードで動作している場合、BLEはセンサのデータを含むAdvertisingパケットを送信しています。\nAdvertisingパケットの構造は次の図のように、AD Structureというデータの塊が連なった形式となっています。\nAD Structureはさらに細かく見ると、Length:データの長さ、AD Type:データの種類・意味、AD Data:送信したいデータで構成されています。\n実際に本サンプルでは下記のコードのように、AD Structure 1にAdvertisingのモード設定、AD Structure 2にデバイス名、AD Structure 3にセンサのデータを保存して送信しています。\nBeaconで送信するデータを変更したい場合はAD Structure 3を任意に変更してください。\nhttps://github.com/Leafony/Sample-Sketches/blob/4e474bcb1f154025873ecf883ddc998df58605cf/STM32_Logger_Beacon/STM32_Logger_Beacon.ino#L272-L302\n//-------------------------  // Advertising Packet  //-------------------------  // AD Structure 1 (Flags)  adv_data[index++] = 0x02; // field length  adv_data[index++] = BGLIB_GAP_AD_TYPE_FLAGS; // AD Type (Flags)  adv_data[index++] = (1 \u0026lt;\u0026lt; 1) | (1 \u0026lt;\u0026lt; 2); // LE General Discover Mode | BR/EDR Not Supported  // AD Structure 2 (Complete Local Name)  adv_data[index++] = strDeviceName.length() + 1; // field length  adv_data[index++] = BGLIB_GAP_AD_TYPE_LOCALNAME_COMPLETE; // AD Type (Complete Local Name)  for (uint8_t i = 0; i \u0026lt; strDeviceName.length(); i++) { adv_data[index++] = strDeviceName.charAt(i); // Local Name  } // AD Structure 3 (Manufacturer Specific Data)  adv_data[index++] = 9; // field lengh  adv_data[index++] = 0xff; // AD Type (Manufacturer Specific Data)  adv_data[index++] = (illum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF; // Illuminance (Upper)  adv_data[index++] = illum \u0026amp; 0xFF; // Illuminance (Lower)  adv_data[index++] = (temp \u0026gt;\u0026gt; 8) \u0026amp; 0xFF; // Temperature (Upper)  adv_data[index++] = temp \u0026amp; 0xFF; // Temperature (Lower)  adv_data[index++] = (humid \u0026gt;\u0026gt; 8) \u0026amp; 0xFF; // Humidity (Upper)  adv_data[index++] = humid \u0026amp; 0xFF; // Humidity (Lower)  adv_data[index++] = (battVolt \u0026gt;\u0026gt; 8) \u0026amp; 0xFF; // Battery Voltage (Upper)  adv_data[index++] = battVolt \u0026amp; 0xFF; // Battery Boltage (Lower)  // register advertising packet  stLen = index; ble112.ble_cmd_le_gap_set_adv_data(SCAN_RSP_ADVERTISING_PACKETS, stLen, adv_data); while (ble112.checkActivity(1000)); センサの変更方法 本サンプルでは4-Sensorsリーフに搭載された、温度・湿度・照度センサ、バッテリーリーフに搭載されたADCを読み出す仕組みとなっています。\nこれらのセンサは、setup()関数内のsetupSensors()関数で初期化し、loop()関数内のwakeupSensors()でスリープから復帰、getSensors()でデータを取得、sleepSensors()でスリープを行なっています。\nhttps://github.com/Leafony/Sample-Sketches/blob/4e474bcb1f154025873ecf883ddc998df58605cf/STM32_Logger_Beacon/STM32_Logger_Beacon.ino#L767-L771\n任意のセンサを追加したい場合はこれらの関数内に必要な処理を記述してください。\nBLEコマンドの変更方法 BLEで接続したPCやスマートフォンからコマンドを送信してLeafony側の設定を変更したり、データの転送を開始したりすることができます。\n下記のソースコードの部分でそのコマンドと処理を記述しています。\nhttps://github.com/Leafony/Sample-Sketches/blob/4e474bcb1f154025873ecf883ddc998df58605cf/STM32_Logger_Beacon/STM32_Logger_Beacon.ino#L934-L1107\n== 任意のコマンドを追加する場合は上記部分を修正してください。\n前のページに戻る\r","excerpt":"はじめに STM32リーフに搭載されたFlashメモリを使って、温湿度と測定時間を記録することが可能なBLE Beaconのサンプルデザインです。\nSTM32リーフとBLEリーフを使った、センサデータ …","ref":"/docs/examples/advanced/3_p/stm32/stm32_logger_ble_beacon/","title":"STM32 Logger Beacon"},{"body":"概要 Leafony blockは、センシングデータをBeacon1の電波で飛ばします。beaconの電波をRaspberry Piが受け、インターネット経由でGoogle スプレッドシートに書かせて、データの可視化が出来ます。\n用意するもの  Basic Kit 2 Raspberry Pi 3B等 ブラウザが閲覧できるパソコンやスマホ  システム構成 Leafony block、Raspbery Pi、インターネット、そして、Google スプレットシートだけで、センシングしたデータを可視化出来ます。システム構成図を以下に記します。また、Leafony blockは、Basic Kit 2 スタートガイドで使用したものとスケッチ含め一緒です。\nRaspberry Piの環境構築 初めてRaspberry Piをご使用になる方は、Raspberry Pi 3 B＋ スターターキット が便利です。Raspbian OSイメージを書き込んだmicroSDが入っています。Raspberry Pi は、無線LANでインターネットに接続して使用します。\n今回使用するサンプルコードでは、Node.jsでnobleを使ってBLE Beaconを受信します。受信したデータはGoogle API経由でGoogle スプレッドシートに書き込みます。\n下記のスクリプト(6項目)を実行して環境構築をします。https://github.com/Leafony/leafony-beacon/tree/master/spreadsheet-logger\nsudo apt update sudo apt upgrade sudo apt install -y bluetooth libbluetooth-dev libudev-dev git git clone https://github.com/Leafony/leafony-beacon cd leafony-beacon/spreadsheet-logger npm install 注意:WARNINGと表示されますが、このまま進んでください。\nGoogle スプレットシートのAPIの取得  Google スプレットシートをNode.jsで操作するためには、APIを取得する必要があります。下記 Node.js Quick Start のStep.1で、 Enable the Google Sheets API をクリックし、credentials.jsonをダウンロードします。  Node.js Quickstart | Sheets API | Google Developers : https://developers.google.com/sheets/api/quickstart/nodejs\nRaspberry Piのleafony-beacon/spreadsheet-loggerディレクトリに、credentials.jsonをコピーしてください。  Google スプレッドシートのIDと名前の設定  Google スプレッドシート を開いて、URLの赤線部分のspredsheetIDとsheetNameを確認します。  Raspberry Piのleafony-beacon/spreadsheet-loggerディレクトリの「index.js」のファイルに、スプレッドシートのIDと名前を書き込みます。 「index.js」の18, 19行目に上記のspredsheetIDとsheetNameを貼り付けて下さい。  Raspberry Pi でBeaconの受信の仕方   Raspberry piのターミナルに「sudo node .」と入力してEnterをクリックしてください。   上記URLにブラウザでアクセスすると、Googleアカウントに移動し、ご自身のアカウントを選択します。   「詳細」をクリックしてください。   「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。   「詳細」をクリックしてください。   「Leafony Beacon Logger「安全ではないページ」に移動」をクリックしてください。   「許可」をクリックしてください。以下のコードをコピーしてください。ターミナル内に貼り付けると、「token.json」というファイルが生成されたあとに、beaconのスキャンが始まります。   Beaconが見つかるとログが表示されると同時に、スプレッドシートに同じ内容が追記されるので、スプレッドシートを開いてデータを確認してください。   前のページに戻る\r  　Beaconとは、地上にある電波を特定の機器で受信することで、位置をはじめとした各種情報を取得するための設備です。BluetoothのBeacon機器の場合、温度や気圧などのセンサを搭載したモジュールを任意の場所に設置して、その場所の環境を観測します。 \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"概要 Leafony blockは、センシングデータをBeacon1の電波で飛ばします。beaconの電波をRaspberry Piが受け、インターネット経由でGoogle スプレッドシートに書かせ …","ref":"/docs/examples/advanced/3_p/stm32/stm32_google_sheets_iot/","title":"Google Sheetsを使ったIoTサービス"},{"body":"概要 カメラで画像データを取得し，学習済みネットワークを利用して人物検出を行います。\nここではSTM32リーフ上にネットワークを実装する方法を説明します。\n実装の際にはカメラやディスプレイが必要ですが，最小限の説明に留めていますので予めご了承ください。\n使用するリーフ 以下のリーフを使用します。\n   Type Name Q\u0026rsquo;ty     AZ62 Connector Cover 2   AZ01 USB 1   AP04 STM32 MCU 2Bus 1   AI02 SP\u0026amp;PIR 1   AX08 29pin header 2   AZ63 Nut Plate 2    M2*10mm screw 4    事前準備 カメラの準備 Leafonyにはカメラ専用コネクタがありません。\n今回はSPI通信でデータ通信が可能なArduCAM Mini (2メガピクセル)を用意しました。\nディスプレイの準備 カメラから正しくデータを受け取れているかを確認するためにディスプレイを用意します。\n今回はSPI通信でデータを表示することが可能なPmod MTDSを利用しました。\n深層学習ネットワークの準備 今回の人物検出はSTマイクロ社が用意されている学習済みネットワークを利用します。\nまずは，FP-AI-VISION1をダウンロードします。\n各種ドライバの準備 カメラのドライバ githubにArduCAMがArduino環境用に用意されたライブラリがアップロードされています。\n今回はHALライブラリを利用するのでSPIを通信する部分を少し書き換える必要があります\nSTM32用のライブラリもアップロードされていますが，Standard Peripheral Libraryを利用しており，今回は使えません。\nディスプレイのドライバ digilent社の公式のgithubにディスプレイをコントロールする関数が公開されています。\nこちらもHALライブラリを利用するのでSPIの通信に関する関数を書き換える必要があります。\nSTMマイコンの基本的な設定 ピン設定 ターゲットマイコンにSTM31L452RETxを選択\n推論ネットワークの初期化コードの設定 STMマイコンに深層学習を実装するにはSTマイクロ社が用意しているツール(X-CUBE-AI)を利用するのが一番手軽に実装できます。\nさらに同社からAIアプリケーション用の便利な関数パック(FP-AI-VISION1)が配布されています。\nこの中にExampleとして人物検出用の学習済みネットワークが含まれていますので，これを今回の推論ネットワークとして利用しました。\nX-CUBE-AIのインストール X-CUBE-AIはオプションのツールなので，IDEへ導入する必要があります。\n はじめにManage Software Packsをクリックしてください。   Emmbedded Software Packages Managerというウィンドウが開かれます。 STMicroelectronicsというタブを選択します。 X-CUBE-AIをクリックすると様々なバージョンのArtificial Intelligenceが表示されますので，導入したいバージョンのチェックボックをクリックし，下のInstall Nowボタンをクリックしてインストールしてください。  ニューラルネットワーク用の設定 ダウンロードしたFP_AI_VISION1の中に人物検出ネットワークが入っています。\n FP_AI_VISION1/Utilities/AI_resources/PersonDetection/Google_Model/person_detect.tflite  これを次の手順でX-CUBE-AIに読みこませます。\n Pinout \u0026amp; Configurationのタブをクリック Software Packsを選択 Configurationが開かれるので，networkのタブをクリック Model inputsにネットワーク情報を入力します  choose model: TFLite Saved Model Model: 先ほどのFP_AI_VISION1内のネットワークファイルを指定   ネットワークの圧縮と検証用の設定を入力します  Compression: None Validation inputs: Random numbers Validation outputs: None     Analyzeボタンをクリックすると解析が始まります 以下の画面が出れば完了です   最後に，設定した内容でコードが生成されるようにModeで以下の箇所にチェックボックスにチェックを入れます  Artificial Intelligence X-CUBE-AI Artificial Intelligence Application    初期化コードの生成 設定が完了したのでコードを生成します。\nProject -\u0026gt; Generate Codeをクリックして生成してください。\n(Alt+Kでも生成できます。)\nプロジェクトの構成 はじめにドライバや画像処理用のファイルを追加します。\nSTM32CubeIDEのProject Explorerを見ると次のフォルダが自動生成されていることが分かります。\n Core Drivers X-CUBE-AI  まずArduCAMとPmod MTDS制御用のコードをDriverに配置します。\n次にFP_AI_VISION1内の画像処理用の便利な関数を利用したいので，以下のフォルダを作成します。\n Middlewares  ダウンロードしたFP_AI_VISION1内の{FP_AI_VISION1}/Middlewares/ST/STM32_Imageを作成したMiddlewaresにインポートしてください。\nグレイスケールからRGB画像データに変換する関数や画サイズを変換する関数が用意されています。\nまた，私は人物検出のネットワークのファイルを以下のように作成して入れました。\nこれは読み込ませたニューラルネットワークのファイルを分かりやすい場所においておきたいだけで必須ではありません。\n Utilities  推論実行部のコード 自動生成されたコードであるX-CUBE-AI/App内のapp_x-cube-ai.cのコード内にMX_X_CUBE_AI_Processという関数があります。\nこの関数内部で以下の関数が重要です。\n acquire_and_process_data()  ネットワークに入力するデータを取得する   ai_run()  推論を実行する   post_process()  推論実行後のデータに対する対応を記述    それぞれ以下のように実装しましょう\nai_runはメモリ確保された入力データと出力データのポインタを渡して上げるだけで，自動生成されたコードだけで実行されます。\nですからほぼ修正する必要がありません。とても便利ですね。\nint acquire_and_process_data(uint8_t *data) { uint32_t sTime; uint32_t eTime; uint8_t eMsg[256] = {0}; extern Image_t cameraImg; extern Image_t resizedImg; extern Image_t inputImg; sTime = HAL_GetTick(); captureBMP565(); eTime = HAL_GetTick(); sprintf(eMsg, \u0026#34; Done : %lums\\r\\n\u0026#34;, eTime-sTime); HAL_UART_Transmit(\u0026amp;huart2, (uint8_t *)eMsg, sizeof(eMsg), 0xFFFF); if ((cameraImg.width != inputImg.width) || (cameraImg.height != inputImg.height)) { ImgResize(\u0026amp;cameraImg, \u0026amp;resizedImg, NEAREST); ImgToGrayscale(\u0026amp;resizedImg, \u0026amp;inputImg); } else { ImgToGrayscale(\u0026amp;cameraImg, \u0026amp;inputImg); } memcpy(data, inputImg.pData, INPUT_IMG_HEIGHT*INPUT_IMG_WIDTH); return 0; } static int ai_run(void *data_in, void *data_out) { ai_i32 batch; ai_buffer *ai_input = network_info.inputs; ai_buffer *ai_output = network_info.outputs; ai_input[0].data = AI_HANDLE_PTR(data_in); ai_output[0].data = AI_HANDLE_PTR(data_out); batch = ai_network_run(network, ai_input, ai_output); if (batch != 1) { ai_log_err(ai_network_get_error(network), \u0026#34;ai_network_run\u0026#34;); return -1; } return 0; } int post_process(uint8_t *data) { uint32_t sTime; uint32_t eTime; uint8_t eMsg[256] = {0}; extern Image_t inputImg; extern Image_t cameraImg; #if defined(USE_PMODMTDS)  sTime = HAL_GetTick(); displayReInit(); displayImage(\u0026amp;cameraImg, 120-cameraImg.height/2, 160-cameraImg.width/2); eTime = HAL_GetTick(); sprintf(eMsg, \u0026#34;Done : %lums\\r\\n\u0026#34;, eTime-sTime); HAL_UART_Transmit(\u0026amp;huart2, (uint8_t *)eMsg, sizeof(eMsg), 0xFFFF); #endif  if ((data[1] \u0026gt; data[2])) { char msg[] = \u0026#34;\\r\\n______ Person Detected!!\\r\\n\\r\\n\u0026#34;; HAL_UART_Transmit(\u0026amp;huart2, (uint8_t *)msg, sizeof(msg), 0xFFFF); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, GPIO_PIN_SET); #if defined(USE_BUZZER)  myPWMStart(10, 1000, 500); HAL_Delay(100); myPWMStop(); HAL_Delay(100); myPWMStart(10, 1000, 500); HAL_Delay(100); myPWMStop(); #endif #if defined(USE_PMODMTDS)  displayPersonDetected(); #endif  } else { char msg[] = \u0026#34;\\r\\n______ No Person\\r\\n\\r\\n\u0026#34;; HAL_UART_Transmit(\u0026amp;huart2, (uint8_t *)msg, sizeof(msg), 0xFFFF); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, GPIO_PIN_RESET); #if defined(USE_BUZZER)  myPWMStop(); #endif #if defined(USE_PMODMTDS)  displayNoPersonDetected(); #endif  } return 0; } この3つの関数は自動生成されたコードに修正を加えなくてもmain.cppから勝手に呼び出され，ずっとループ実行されます。\n各種インタフェースのドライバの初期化コードをmain.cppに追加し，以上のようにデータの取得時の動作と推論実行後の動作を記述してあげるだけで，実装は終了です。\n","excerpt":"概要 カメラで画像データを取得し，学習済みネットワークを利用して人物検出を行います。\nここではSTM32リーフ上にネットワークを実装する方法を説明します。\n実装の際にはカメラやディスプレイが必要です …","ref":"/docs/examples/advanced/3_p/stm32/stm32_person_detection/","title":"STM32で人物検出する推論ネットワークの実装"},{"body":"はじめに 屋外のセンサデータを一定間隔で取得し、クラウドのダッシュボードで確認したり、異常値をメールやLINEで知る一般的なIoTサービスが、KDDIが開発した「LTE-M1リーフ」を使えば、簡単に実現出来ます。\nKDDI「LTE-Mリーフ」の特長  KDDI は、約23×30mmと超小型でLTE-M 通信機能に対応したLTE-Mリーフの開発に成功しました。 小さな基板上に、データ通信用のアンテナを内蔵し（技適取得済）、外部アンテナは不要です。 SIMカードは、KDDIのLTE-M通信網に対応したソラコムのLTE-Mサービス「SORACOM Air for セルラー(plan-KM1)」が利用出来ます。 省電力性能は、通信モジュールが具備するスリープ等の機能だけでなく、ソフトウェア設定で通信モジュールへの給電自体を遮断する機能を搭載しており、長期間使用しない時は電池の消費を限りなくゼロに近づけることが可能にしました。 電池は、単3電池やリチウムイオン電池等で、データ送信の頻度や回数等のユースケースに応じて選択することが出来ます。 電池寿命は約200日2です。 毎月の通信量は従量制です。(作成中)  \r\rLeafonyの設定 用意するもの   LTE-M King M、 LTE-M King S\n  SORACOM IoT SIM(plan-KM1)\n  Basic Kit 2、Nut Plate\n  開発用パソコン\n  単3ニッケル⽔素電池x3本\n  単3x3本電池ボックス(JST製PHコネクタ付き)3\n  \nサンプルアプリのソースコード Leafonyのデータを送信する際の通信プロトコルは、TCPとUDPの二通りあり、Arduinoのスケッチだけでなく、 SORACOMの設定も異なります。また、TCPのスケッチは、テキストデータで送信する設定になっていますが、UDPのスケッチは、通信量を減らすため、バイナリーデータにしています。 初めての方は、TCPのスケッチがお勧めで、通信コストを抑えたい方は、UDPのをお使い下さい。\n  Arduino スケッチ(TCP用)　\n  Arduino スケッチ(UDP用)　\n  Leafonyの構成 このサンプルでは下記のリーフ構成で試せます。\n   Type Name  Q\u0026rsquo;ty     AZ62 Connector Cover コネクタカバー 1   AI01 4-Sensors 温度、湿度、照度、加速度センサを搭載したリーフ 1   AP03 STM32 MCU STM32L452REシリーズを使用した32bit MCUリーフ 1   AC04 LTE-M King M LTE-M (LTE Cat-M1)リーフ 1   AV05 LTE-M King S LTE-M用電源リーフ 1   AZ63 Nut Plate 固定金具 1   - IoT SIM(plan-KM1)  1   - M2*18mm screw  2   - 単3x3本電池ボックス  1   - 単3ニッケル⽔素電池   3    リーフの組み立て  IoT SIM(plan-KM1)をLTE-M King MのnanoSIM card slotに差し込んで下さい。 上から4-Sensorsリーフ、STM32 MCUリーフ、LTE-M King Mリーフ、LTE-M King Sリーフの順番で組み立て、ネジ止めして下さい。  \nUSBドライバーのインストール  Arduinoのスケッチは、LTE-M King Sリーフを使って書き込んで下さい。LTE-M king SリーフのUSB-UART変換ICは、調達の都合上、MaxLinear社のIC(XR21B1411IL16-F)を採用しました。インストール方法は、こちらを参照して下さい。  スケッチの書き込み  STM32 MCUのArduino IDE設定が、まだ済んでない方は、インストールして下さい。 Arduinoのボードは、ツール→ Board part number→ Leafony STM32 MCU(16MHz)を選択します。 Arduinoのスケッチを書き込んで下さい。 STM32RTC.hでコンパイルエラーが発生した時は、STM32RTC.hのバージョンを最新から1.2.0または、1.1.0に変更すると改善された事例があります。4  \r\rSORACOMの設定 SORACOMは、複数のSIMを束ねたSIMグループで、クラウドの設定をします。以下の手順で、SORACOM上に送信したデータを確認することが出来ます。\nSIMグループの設定をする TCPの場合のSIMグループの設定  ユーザコンソールを開き、 左上のメニュー　→　SIMグループ　→　追加をクリックします。 グループ名は、KM-1_SORACOM-Lagoon（例）とします。 SORACOM Air for セルラー設定の簡易位置情報をONにします。 SORACOM Harvest Data設定をONにする。 Unified Endpoint設定が、Auto(デフォルト)であることを確認します。  UDPの場合のSIMグループの設定  ユーザコンソールを開き、 左上のメニュー　→　SIMグループ　→　追加をクリックします。 グループ名は、KM-1_SORACOM-Lagoon_udp（例）とします。 SORACOM Air for セルラー設定の簡易位置情報とバイナリーパーサをONにし、フォーマットに下記を入力します。 Temperature:0:float:32 Humidity:4:float:32 Illuminance:8:float:32 Battery_Level:12:float:32 Signal_Power:16:float:32 SORACOM Harvest Data設定をONにする。 Unified Endpoint設定   フォーマットは、カスタムを選択します。 成功時のレスポンスのHTTP ステータスコードは200を選択、CONTENT-TYPE ヘッダーの値はtext/plan　を入力、ステータスコードのボックスにチェック（レ点）を入れてます。 失敗時のレスポンスは、ステータスコードのボックスにチェック（レ点）を入れます。   IoT SIMを登録する  ユーザコンソールを開き、 左上のメニュー　→　発注 をクリックします。 注文履歴に購入したSIMを確認し、受け取り確認 を押します。  以下の画面が出てくるので登録する を押します。  左上のメニュー　→　SIM管理 をクリック、。  名前を決め、グループ名は、KM-1_SORACOM-Lagoonを選択します。   IoT SIMの通信を開始する  こちらを参照し、有効期限とアクションを設定します。 ユーザコンソールを開き、 操作 →　使用開始をクリックします。  SORACOM Harvest上でLeafonyが送信したデータを確認する  Leafonyの電源をONにしてデータを送信します。 ユーザコンソールを開き、 左上のメニュー　→　データ収集・蓄積・可視化 → SORACOM Harvest Dataをクリックします。 SORACOM Harvest Dataの左上のリソースからSIMを選択し、Leafonyが送付したデータが確認出来れば、正しくデータが送付されています。   SORACOM の利用料金について  SORACOMの利用料金は、ユーザコンソールを開き、右上のオペレータ →　ご利用料金 で確認出来ます。 通信料金は、従量制(0.55 円/KB)なので、設定金額を上回った時にオペレーターに通知がくる設定をしておくのがよろしいです。  SORACOM Lagoon (ダッシュボード)について  SORACOM Lagoon は、SORACOM Harvest Data に蓄積したデータを用いて、グラフ・地図などを使ったダッシュボードを作成いただけるサービスです。\n  ユーザコンソールを開き、 左上のメニュー　→　データ収集・蓄積・可視化 → SORACOM Harvest Lagoonをクリックします。\n  Lagoonの利用を開始するをクリックします。 \n  プランを選択します。使用するプランに基づいて月額の利用料金が発生しますが、無料利用枠からでも始められます。 \n  パスワードは、アカウント(オペレータ)作成時に設定したパスワードと同じ方でも構いません。 \n  Lagoonコンソールをクリックします。 \n  SORACOM Lagoonの画面を出てくることを確認して下さい。 \n  こちらを参照し、SORACOM Lagoonを始めて下さい。\n    LTEは通常使用している携帯電話・スマートフォン用広域無線通信規格のことで、LTE-Mはこの通信技術を応用し通信速度を下げて超低電力化している無線規格です。  \u0026#x21a9;\u0026#xfe0e;\n 3000mAhの18650電池を使用し、1時間に1回データ送信した時の計算値  \u0026#x21a9;\u0026#xfe0e;\n 写真の電池ボックスの購入先  ・単3x3本電池ボックス(秋月)：https://akizukidenshi.com/catalog/g/gP-02667/　 ・JST製PHコネクタ(秋月):https://akizukidenshi.com/catalog/g/gP-12665/　 ・接続コネクタ(エーモン)：https://www.amon.jp/diy/index.php?diy_id=63\u0026amp;mode=contents  \u0026#x21a9;\u0026#xfe0e;\n 　STM32RTC.hでコンパイルエラーのログ  \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"はじめに 屋外のセンサデータを一定間隔で取得し、クラウドのダッシュボードで確認したり、異常値をメールやLINEで知る一般的なIoTサービスが、KDDIが開発した「LTE-M1リーフ」を使えば、簡単に実 …","ref":"/docs/examples/advanced/3_p/stm32/lte-m_soracom_1/","title":"LTE-Mを使ったIoTサービス"},{"body":"はじめに 屋外のセンサデータを一定間隔で取得し、クラウドのダッシュボードで確認したり、異常値をメールやLINEで知る一般的なIoTサービスが、KDDIが開発した「LTE-M1リーフ」を使えば、簡単に実現出来ます。\nKDDI「LTE-Mリーフ」の特長  KDDI は、約23×30mmと超小型でLTE-M 通信機能に対応したLTE-Mリーフの開発に成功しました。 小さな基板上に、データ通信用のアンテナを内蔵し（技適取得済）、外部アンテナは不要です。 SIMカードは、KDDIのLTE-M通信網に対応したソラコムのLTE-Mサービス「SORACOM Air for セルラー(plan-KM1)」が利用出来ます。 省電力性能は、通信モジュールが具備するスリープ等の機能だけでなく、ソフトウェア設定で通信モジュールへの給電自体を遮断する機能を搭載しており、長期間使用しない時は電池の消費を限りなくゼロに近づけることが可能にしました。 電池は、単3電池やリチウムイオン電池等で、データ送信の頻度や回数等のユースケースに応じて選択することが出来ます。 電池寿命は約200日2です。 毎月の通信量は従量制です。(作成中)  \r\rLeafonyの設定 用意するもの   LTE-M King M、 LTE-M King S\n  SORACOM IoT SIM(plan-KM1)\n  Basic Kit 2、Nut Plate\n  開発用パソコン\n  単3ニッケル⽔素電池x3本\n  単3x3本電池ボックス(JST製PHコネクタ付き)3\n  \nサンプルアプリのソースコード Leafonyのデータを送信する際の通信プロトコルは、TCPとUDPの二通りあり、Arduinoのスケッチだけでなく、 SORACOMの設定も異なります。また、TCPのスケッチは、テキストデータで送信する設定になっていますが、UDPのスケッチは、通信量を減らすため、バイナリーデータにしています。 初めての方は、TCPのスケッチがお勧めで、通信コストを抑えたい方は、UDPのをお使い下さい。\n  Arduino スケッチ(TCP用)　\n  Arduino スケッチ(UDP用)　\n  Leafonyの構成 このサンプルでは下記のリーフ構成で試せます。\n   Type Name  Q\u0026rsquo;ty     AZ62 Connector Cover コネクタカバー 1   AI01 4-Sensors 温度、湿度、照度、加速度センサを搭載したリーフ 1   AP03 STM32 MCU STM32L452REシリーズを使用した32bit MCUリーフ 1   AC04 LTE-M King M LTE-M (LTE Cat-M1)リーフ 1   AV05 LTE-M King S LTE-M用電源リーフ 1   AZ63 Nut Plate 固定金具 1   - IoT SIM(plan-KM1)  1   - M2*18mm screw  2   - 単3x3本電池ボックス  1   - 単3ニッケル⽔素電池   3    リーフの組み立て  IoT SIM(plan-KM1)をLTE-M King MのnanoSIM card slotに差し込んで下さい。 上から4-Sensorsリーフ、STM32 MCUリーフ、LTE-M King Mリーフ、LTE-M King Sリーフの順番で組み立て、ネジ止めして下さい。  \nUSBドライバーのインストール  Arduinoのスケッチは、LTE-M King Sリーフを使って書き込んで下さい。LTE-M king SリーフのUSB-UART変換ICは、調達の都合上、MaxLinear社のIC(XR21B1411IL16-F)を採用しました。インストール方法は、こちらを参照して下さい。   スケッチの書き込み  STM32 MCUのArduino IDE設定が、まだ済んでない方は、インストールして下さい。 Arduinoのボードは、ツール→ Board part number→ Leafony STM32 MCU(16MHz)を選択します。 Arduinoのスケッチ[^4]を書き込んで下さい。  \r\rAWSの設定 ※以下、要変更 AWSは、複数のSIMを束ねたSIMグループで、クラウドの設定をします。以下の手順で、SORACOM上に送信したデータを確認することが出来ます。\nAWSの設定をする 仕掛中\nTCPの場合のSIMグループの設定  ユーザコンソールを開き、 左上のメニュー　→　SIMグループ　→　追加をクリックします。 グループ名は、KM-1_SORACOM-Lagoon（例）とします。 SORACOM Air for セルラー設定の簡易位置情報をONにします。 SORACOM Harvest Data設定をONにする。 Unified Endpoint設定が、Auto(デフォルト)であることを確認します。  UDPの場合のSIMグループの設定  ユーザコンソールを開き、 左上のメニュー　→　SIMグループ　→　追加をクリックします。 グループ名は、KM-1_SORACOM-Lagoon_udp（例）とします。 SORACOM Air for セルラー設定の簡易位置情報とバイナリーパーサをONにし、フォーマットに下記を入力します。 Temperature:0:float:32 Humidity:4:float:32 Illuminance:8:float:32 Battery_Level:12:float:32 Signal_Power:16:float:32 SORACOM Harvest Data設定をONにする。 Unified Endpoint設定   フォーマットは、カスタムを選択します。 成功時のレスポンスのHTTP ステータスコードは200を選択、CONTENT-TYPE ヘッダーの値はtext/plan　を入力、ステータスコードのボックスにチェック（レ点）を入れてます。 失敗時のレスポンスは、ステータスコードのボックスにチェック（レ点）を入れます。   IoT SIMを登録する  ユーザコンソールを開き、 左上のメニュー　→　発注 をクリックします。 注文履歴に購入したSIMを確認し、受け取り確認 を押します。  以下の画面が出てくるので登録する を押します。  左上のメニュー　→　SIM管理 をクリック、。  名前を決め、グループ名は、KM-1_SORACOM-Lagoonを選択します。   IoT SIMの通信を開始する  こちらを参照し、有効期限とアクションを設定します。 ユーザコンソールを開き、 操作 →　使用開始をクリックします。  SORACOM Harvest上でLeafonyが送信したデータを確認する  Leafonyの電源をONにしてデータを送信します。 ユーザコンソールを開き、 左上のメニュー　→　データ収集・蓄積・可視化 → SORACOM Harvest Dataをクリックします。 SORACOM Harvest Dataの左上のリソースからSIMを選択し、Leafonyが送付したデータが確認出来れば、正しくデータが送付されています。   SORACOM の利用料金について  SORACOMの利用料金は、ユーザコンソールを開き、右上のオペレータ →　ご利用料金 で確認出来ます。 通信料金は、従量制(0.55 円/KB)なので、設定金額を上回った時にオペレーターに通知がくる設定をしておくのがよろしいです。  SORACOM Lagoon (ダッシュボード)について  SORACOM Lagoon は、SORACOM Harvest Data に蓄積したデータを用いて、グラフ・地図などを使ったダッシュボードを作成いただけるサービスです。\n  ユーザコンソールを開き、 左上のメニュー　→　データ収集・蓄積・可視化 → SORACOM Harvest Lagoonをクリックします。\n  Lagoonの利用を開始するをクリックします。 \n  プランを選択します。使用するプランに基づいて月額の利用料金が発生しますが、無料利用枠からでも始められます。 \n  パスワードは、アカウント(オペレータ)作成時に設定したパスワードと同じ方でも構いません。 \n  Lagoonコンソールをクリックします。 \n  SORACOM Lagoonの画面を出てくることを確認して下さい。 \n  こちらを参照し、SORACOM Lagoonを始めて下さい。\n    LTEは通常使用している携帯電話・スマートフォン用広域無線通信規格のことで、LTE-Mはこの通信技術を応用し通信速度を下げて超低電力化している無線規格です。  \u0026#x21a9;\u0026#xfe0e;\n 3000mAhの18650電池を使用し、1時間に1回データ送信した時の計算値  \u0026#x21a9;\u0026#xfe0e;\n 写真の電池ボックスの購入先  ・単3x3本電池ボックス(秋月)：https://akizukidenshi.com/catalog/g/gP-02667/　 ・JST製PHコネクタ(秋月):https://akizukidenshi.com/catalog/g/gP-12665/　 ・接続コネクタ(エーモン)：https://www.amon.jp/diy/index.php?diy_id=63\u0026amp;mode=contents  \u0026#x21a9;\u0026#xfe0e;\n   ","excerpt":"はじめに 屋外のセンサデータを一定間隔で取得し、クラウドのダッシュボードで確認したり、異常値をメールやLINEで知る一般的なIoTサービスが、KDDIが開発した「LTE-M1リーフ」を使えば、簡単に実 …","ref":"/docs/examples/advanced/3_p/stm32/lte-m_aws_1/","title":"LTE-Mを使ったAWS IoTサービス（仕掛中）"},{"body":"","excerpt":"","ref":"/en/index.json","title":""},{"body":"","excerpt":"","ref":"/index.json","title":""},{"body":"Overview  Introduction Our Products Terms Licecnse Contacts  System  Getting-Started Environment Settings Sample App Home-made leaf development  Leaf  Leafony-bus Individual Leaf Technical Data  Back to previous page\r","excerpt":"Overview  Introduction Our Products Terms Licecnse Contacts  System  Getting-Started Environment …","ref":"/en/docs/","title":"Documentation"},{"body":"Overview  はじめに 製品一覧 用語の説明 ライセンス お問い合わせ  System  クイックスタート 開発環境設定 Arduino サンプルアプリ・応用例 STM32CubeIDE サンプルアプリ・応用例 省電力化の流れ 自作リーフ開発  Leaf  Leafony バス 個別リーフ技術資料  前のページに戻る\r","excerpt":"Overview  はじめに 製品一覧 用語の説明 ライセンス お問い合わせ  System  クイックスタート 開発環境設定 Arduino サンプルアプリ・応用例 STM32CubeIDE サンプ …","ref":"/docs/","title":"Documentation"},{"body":"\r\r#td-cover-block-0 {\rbackground-image: url(/en/featured-background_hubf9a9d0a00ddac7fb58721d040adf027_267411_960x540_fill_q75_catmullrom_top.jpg); }\r@media only screen and (min-width: 1200px) {\r#td-cover-block-0 {\rbackground-image: url(/en/featured-background_hubf9a9d0a00ddac7fb58721d040adf027_267411_1920x1080_fill_q75_catmullrom_top.jpg); }\r}\r\rLeafony\rDocumentation \r\rAn open innovation platform\n\r\r\r\r\r\r\r\rEnjoy IoT with the Leafony\r\r\r\r\r\r\rEasy Circuit Development\rLeafony makes the circuit design easy. Stack each module and make new circuits.\n\r\r\rOpen Source Hardware\rLeafony is an OSS project. All codes, circuits and designes are available on GitHub. Free for both personal and commercial use.\nRead more …\n\r\r\rNews\rCheck the latest news\nRead more …\n\r\r\r\r--\r","excerpt":"#td-cover-block-0 {\rbackground-image: …","ref":"/en/","title":"Leafony"},{"body":"\r\r#td-cover-block-0 {\rbackground-image: url(/featured-background_hubf9a9d0a00ddac7fb58721d040adf027_267411_960x540_fill_q75_catmullrom_top.jpg); }\r@media only screen and (min-width: 1200px) {\r#td-cover-block-0 {\rbackground-image: url(/featured-background_hubf9a9d0a00ddac7fb58721d040adf027_267411_1920x1080_fill_q75_catmullrom_top.jpg); }\r}\r\rLeafony\rDocumentation \r\rAn open innovation platform\n\r\r\r\r\r\r\r\rIoT向けのシステムを誰でも簡単に創れる小型・低消費電力プラットフォーム「Leafony」 \r\r\r\r\r\r超小型・簡単\r1円玉と同じ大きさ　新規開発のコネクタで組立はブロック玩具のように簡単　足りない機能だけをリーフ（電子基板モジュール）にするので短期間で開発\n\r\r\r低消費電力\rスタンバイモードやソフトウェアで制御可能な電源スイッチを搭載しているのでコイン電池駆動可能\n\r\r\rオープン\r商用でも無償で使える仕様、回路図、基板レイアウトなどのハードウェアやソフトウェアを公開\n\r\u0026ndash;\u0026gt;\n\r\r\r活用事例\r\r\r\r\rサードパーティ\r\r\r\r\r作品例\r\r\r\r\r\r\r\r// --\r","excerpt":"\r\r#td-cover-block-0 {\rbackground-image: …","ref":"/","title":"Leafony"},{"body":"","excerpt":"","ref":"/en/search/","title":"Search Results"},{"body":"\r\r\r\r\r\r\r\r\r\rLeafony\rhttps://leafony.com\r\r\r　　\r　\r\r\r\r\r\rDAIWA corporation\rhttp://daiwa-leafony.jp/\r\r\r　\r　\r\r\r\r\r日昭無線ネットショップPOWERED\rhttps://www.powered.jp/SHOP/list.php?Search=leafony\r\r\r　\r　\r\r\r\r\rChip One Stop\rhttps://www.chip1stop.com/sp/products/leafony?cid=top_Features_bn_leafony\r\r\r　\r　\r\r\r\r\rMeico Electronic Co.,Ltd.\rhttps://eee.meicodenshi.com/Trend/leafony\r\r\r　\r　\r\r\r","excerpt":"\r\r\r\r\r\r\r\r\r\rLeafony\rhttps://leafony.com\r\r\r　　\r　\r\r\r\r\r\rDAIWA corporation\rhttp://daiwa-leafony.jp/ …","ref":"/en/shop/","title":"Shop"},{"body":"\r\r\r\r\r\r\r\r\r\rLeafony\rhttps://shop.leafony.com/\r\r\r　　\r　\r\r\r\r\r\rDAIWA corporation\rhttps://daiwa-leafony.jp/\r\r\r　\r　\r\r\r\r\r日昭無線ネットショップPOWERED\rhttps://www.powered.jp/SHOP/list.php?Search=leafony\r\r\r　\r　\r\r\r\r\rChip One Stop\rhttps://www.chip1stop.com/sp/products/leafony?cid=top_Features_bn_leafony\r\r\r　\r　\r\r\r\r\rMeico Electronic Co.,Ltd.\rhttps://eee.meicodenshi.com/Trend/leafony\r\r\r　\r　\r\r\r\r\rTOKYO ELECTRON DEVICE LIMITED\rhttps://www.teldevice.co.jp/\r\r\r　\r　\r\r\r前のページに戻る\r","excerpt":"Leafony\rhttps://shop.leafony.com/\r\r\r　　\r　\r\r\r\r\r\rDAIWA corporation\rhttps://daiwa-leafony.jp/\r\r\r　\r　\r\r\r\r\r …","ref":"/shop/","title":"Shop"},{"body":"","excerpt":"","ref":"/search/","title":"検索結果"}]